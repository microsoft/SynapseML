---
title: switch
type: output
status: stable
categories: ["Utility"]
---

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the contents of:
     lib/output/switch.go
-->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


The switch output type allows you to route messages to different outputs based on their contents.


<Tabs defaultValue="common" values={[
  { label: 'Common', value: 'common', },
  { label: 'Advanced', value: 'advanced', },
]}>

<TabItem value="common">

```yaml
# Common config fields, showing default values
output:
  label: ""
  switch:
    retry_until_success: true
    cases: []
```

</TabItem>
<TabItem value="advanced">

```yaml
# All config fields, showing default values
output:
  label: ""
  switch:
    retry_until_success: true
    strict_mode: false
    max_in_flight: 1
    cases: []
```

</TabItem>
</Tabs>

Messages must successfully route to one or more outputs, otherwise this is considered an error and the message is reprocessed. In order to explicitly drop messages that do not match your cases add one final case with a [drop output](/docs/components/outputs/drop).

## Examples

<Tabs defaultValue="Basic Multiplexing" values={[
{ label: 'Basic Multiplexing', value: 'Basic Multiplexing', },
{ label: 'Control Flow', value: 'Control Flow', },
]}>

<TabItem value="Basic Multiplexing">


The most common use for a switch output is to multiplex messages across a range of output destinations. The following config checks the contents of the field `type` of messages and sends `foo` type messages to an `amqp_1` output, `bar` type messages to a `gcp_pubsub` output, and everything else to a `redis_streams` output.

Outputs can have their own processors associated with them, and in this example the `redis_streams` output has a processor that enforces the presence of a type field before sending it.

```yaml
output:
  switch:
    cases:
      - check: this.type == "foo"
        output:
          amqp_1:
            url: amqps://guest:guest@localhost:5672/
            target_address: queue:/the_foos

      - check: this.type == "bar"
        output:
          gcp_pubsub:
            project: dealing_with_mike
            topic: mikes_bars

      - output:
          redis_streams:
            url: tcp://localhost:6379
            stream: everything_else
          processors:
            - bloblang: |
                root = this
                root.type = this.type | "unknown"
```

</TabItem>
<TabItem value="Control Flow">


The `continue` field allows messages that have passed a case to be tested against the next one also. This can be useful when combining non-mutually-exclusive case checks.

In the following example a message that passes both the check of the first case as well as the second will be routed to both.

```yaml
output:
  switch:
    cases:
      - check: 'this.user.interests.contains("walks").catch(false)'
        output:
          amqp_1:
            url: amqps://guest:guest@localhost:5672/
            target_address: queue:/people_what_think_good
        continue: true

      - check: 'this.user.dislikes.contains("videogames").catch(false)'
        output:
          gcp_pubsub:
            project: people
            topic: that_i_dont_want_to_hang_with
```

</TabItem>
</Tabs>

## Fields

### `retry_until_success`

If a selected output fails to send a message this field determines whether it is
reattempted indefinitely. If set to false the error is instead propagated back
to the input level.

If a message can be routed to >1 outputs it is usually best to set this to true
in order to avoid duplicate messages being routed to an output.


Type: `bool`  
Default: `true`  

### `strict_mode`

This field determines whether an error should be reported if no condition is met.
If set to true, an error is propagated back to the input level. The default
behavior is false, which will drop the message.


Type: `bool`  
Default: `false`  

### `max_in_flight`

The maximum number of parallel message batches to have in flight at any given time. Note that if a child output has a higher `max_in_flight` then the switch output will automatically match it, therefore this value is the minimum `max_in_flight` to set in cases where the child values can't be inferred (such as when using resource outputs as children).


Type: `int`  
Default: `1`  

### `cases`

A list of switch cases, outlining outputs that can be routed to.


Type: `array`  
Default: `[]`  

```yaml
# Examples

cases:
  - check: this.urls.contains("http://benthos.dev")
    continue: true
    output:
      cache:
        key: ${!json("id")}
        target: foo
  - output:
      s3:
        bucket: bar
        path: ${!json("id")}
```

### `cases[].check`

A [Bloblang query](/docs/guides/bloblang/about/) that should return a boolean value indicating whether a message should be routed to the case output. If left empty the case always passes.


Type: `string`  
Default: `""`  

```yaml
# Examples

check: this.type == "foo"

check: this.contents.urls.contains("https://benthos.dev/")
```

### `cases[].output`

An [output](/docs/components/outputs/about/) for messages that pass the check to be routed to.


Type: `output`  
Default: `{}`  

### `cases[].continue`

Indicates whether, if this case passes for a message, the next case should also be tested.


Type: `bool`  
Default: `false`  


