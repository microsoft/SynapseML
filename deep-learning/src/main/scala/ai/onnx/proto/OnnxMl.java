// SPDX-License-Identifier: Apache-2.0

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx-ml.proto

package ai.onnx.proto;

public final class OnnxMl {
    private OnnxMl() {}
    public static void registerAllExtensions(
            com.google.protobuf.ExtensionRegistryLite registry) {
    }

    public static void registerAllExtensions(
            com.google.protobuf.ExtensionRegistry registry) {
        registerAllExtensions(
                (com.google.protobuf.ExtensionRegistryLite) registry);
    }
    /**
     * <pre>
     * Versioning
     * ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
     * To be compatible with both proto2 and proto3, we will use a version number
     * that is not defined by the default value but an explicit enum number.
     * </pre>
     *
     * Protobuf enum {@code onnx.Version}
     */
    public enum Version
            implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <pre>
         * proto3 requires the first enum value to be zero.
         * We add this just to appease the compiler.
         * </pre>
         *
         * <code>_START_VERSION = 0;</code>
         */
        _START_VERSION(0),
        /**
         * <pre>
         * The version field is always serialized and we will use it to store the
         * version that the  graph is generated from. This helps us set up version
         * control.
         * For the IR, we are using simple numbers starting with 0x00000001,
         * which was the version we published on Oct 10, 2017.
         * </pre>
         *
         * <code>IR_VERSION_2017_10_10 = 1;</code>
         */
        IR_VERSION_2017_10_10(1),
        /**
         * <pre>
         * IR_VERSION 2 published on Oct 30, 2017
         * - Added type discriminator to AttributeProto to support proto3 users
         * </pre>
         *
         * <code>IR_VERSION_2017_10_30 = 2;</code>
         */
        IR_VERSION_2017_10_30(2),
        /**
         * <pre>
         * IR VERSION 3 published on Nov 3, 2017
         * - For operator versioning:
         *    - Added new message OperatorSetIdProto
         *    - Added opset_import in ModelProto
         * - For vendor extensions, added domain in NodeProto
         * </pre>
         *
         * <code>IR_VERSION_2017_11_3 = 3;</code>
         */
        IR_VERSION_2017_11_3(3),
        /**
         * <pre>
         * IR VERSION 4 published on Jan 22, 2019
         * - Relax constraint that initializers should be a subset of graph inputs
         * - Add type BFLOAT16
         * </pre>
         *
         * <code>IR_VERSION_2019_1_22 = 4;</code>
         */
        IR_VERSION_2019_1_22(4),
        /**
         * <pre>
         * IR VERSION 5 published on March 18, 2019
         * - Add message TensorAnnotation.
         * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
         * </pre>
         *
         * <code>IR_VERSION_2019_3_18 = 5;</code>
         */
        IR_VERSION_2019_3_18(5),
        /**
         * <pre>
         * IR VERSION 6 published on Sep 19, 2019
         * - Add support for sparse tensor constants stored in model.
         *   - Add message SparseTensorProto
         *   - Add sparse initializers
         * </pre>
         *
         * <code>IR_VERSION_2019_9_19 = 6;</code>
         */
        IR_VERSION_2019_9_19(6),
        /**
         * <pre>
         * IR VERSION 7 published on &lt;TBD&gt;
         * - Add support to allow function body graph to rely on multiple external opreator sets.
         * - Add a list to promote inference graph's initializers to global and
         *   mutable variables. Global variables are visible in all graphs of the
         *   stored models.
         * - Add message TrainingInfoProto to store initialization
         *   method and training algorithm. The execution of TrainingInfoProto
         *   can modify the values of mutable variables.
         * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
         * </pre>
         *
         * <code>IR_VERSION = 7;</code>
         */
        IR_VERSION(7),
        ;

        /**
         * <pre>
         * proto3 requires the first enum value to be zero.
         * We add this just to appease the compiler.
         * </pre>
         *
         * <code>_START_VERSION = 0;</code>
         */
        public static final int _START_VERSION_VALUE = 0;
        /**
         * <pre>
         * The version field is always serialized and we will use it to store the
         * version that the  graph is generated from. This helps us set up version
         * control.
         * For the IR, we are using simple numbers starting with 0x00000001,
         * which was the version we published on Oct 10, 2017.
         * </pre>
         *
         * <code>IR_VERSION_2017_10_10 = 1;</code>
         */
        public static final int IR_VERSION_2017_10_10_VALUE = 1;
        /**
         * <pre>
         * IR_VERSION 2 published on Oct 30, 2017
         * - Added type discriminator to AttributeProto to support proto3 users
         * </pre>
         *
         * <code>IR_VERSION_2017_10_30 = 2;</code>
         */
        public static final int IR_VERSION_2017_10_30_VALUE = 2;
        /**
         * <pre>
         * IR VERSION 3 published on Nov 3, 2017
         * - For operator versioning:
         *    - Added new message OperatorSetIdProto
         *    - Added opset_import in ModelProto
         * - For vendor extensions, added domain in NodeProto
         * </pre>
         *
         * <code>IR_VERSION_2017_11_3 = 3;</code>
         */
        public static final int IR_VERSION_2017_11_3_VALUE = 3;
        /**
         * <pre>
         * IR VERSION 4 published on Jan 22, 2019
         * - Relax constraint that initializers should be a subset of graph inputs
         * - Add type BFLOAT16
         * </pre>
         *
         * <code>IR_VERSION_2019_1_22 = 4;</code>
         */
        public static final int IR_VERSION_2019_1_22_VALUE = 4;
        /**
         * <pre>
         * IR VERSION 5 published on March 18, 2019
         * - Add message TensorAnnotation.
         * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
         * </pre>
         *
         * <code>IR_VERSION_2019_3_18 = 5;</code>
         */
        public static final int IR_VERSION_2019_3_18_VALUE = 5;
        /**
         * <pre>
         * IR VERSION 6 published on Sep 19, 2019
         * - Add support for sparse tensor constants stored in model.
         *   - Add message SparseTensorProto
         *   - Add sparse initializers
         * </pre>
         *
         * <code>IR_VERSION_2019_9_19 = 6;</code>
         */
        public static final int IR_VERSION_2019_9_19_VALUE = 6;
        /**
         * <pre>
         * IR VERSION 7 published on &lt;TBD&gt;
         * - Add support to allow function body graph to rely on multiple external opreator sets.
         * - Add a list to promote inference graph's initializers to global and
         *   mutable variables. Global variables are visible in all graphs of the
         *   stored models.
         * - Add message TrainingInfoProto to store initialization
         *   method and training algorithm. The execution of TrainingInfoProto
         *   can modify the values of mutable variables.
         * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
         * </pre>
         *
         * <code>IR_VERSION = 7;</code>
         */
        public static final int IR_VERSION_VALUE = 7;


        public final int getNumber() {
            return value;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Version valueOf(int value) {
            return forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value.
         */
        public static Version forNumber(int value) {
            switch (value) {
                case 0: return _START_VERSION;
                case 1: return IR_VERSION_2017_10_10;
                case 2: return IR_VERSION_2017_10_30;
                case 3: return IR_VERSION_2017_11_3;
                case 4: return IR_VERSION_2019_1_22;
                case 5: return IR_VERSION_2019_3_18;
                case 6: return IR_VERSION_2019_9_19;
                case 7: return IR_VERSION;
                default: return null;
            }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Version>
        internalGetValueMap() {
            return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
                Version> internalValueMap =
                new com.google.protobuf.Internal.EnumLiteMap<Version>() {
                    public Version findValueByNumber(int number) {
                        return Version.forNumber(number);
                    }
                };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
            return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
            return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.getDescriptor().getEnumTypes().get(0);
        }

        private static final Version[] VALUES = values();

        public static Version valueOf(
                com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
            if (desc.getType() != getDescriptor()) {
                throw new java.lang.IllegalArgumentException(
                        "EnumValueDescriptor is not for this type.");
            }
            return VALUES[desc.getIndex()];
        }

        private final int value;

        private Version(int value) {
            this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:onnx.Version)
    }

    public interface AttributeProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.AttributeProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();

        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return Whether the refAttrName field is set.
         */
        boolean hasRefAttrName();
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The refAttrName.
         */
        java.lang.String getRefAttrName();
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The bytes for refAttrName.
         */
        com.google.protobuf.ByteString
        getRefAttrNameBytes();

        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();

        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
         * @return Whether the type field is set.
         */
        boolean hasType();
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
         * @return The type.
         */
        ai.onnx.proto.OnnxMl.AttributeProto.AttributeType getType();

        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return Whether the f field is set.
         */
        boolean hasF();
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return The f.
         */
        float getF();

        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return Whether the i field is set.
         */
        boolean hasI();
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return The i.
         */
        long getI();

        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return Whether the s field is set.
         */
        boolean hasS();
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return The s.
         */
        com.google.protobuf.ByteString getS();

        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         * @return Whether the t field is set.
         */
        boolean hasT();
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         * @return The t.
         */
        ai.onnx.proto.OnnxMl.TensorProto getT();
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTOrBuilder();

        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         * @return Whether the g field is set.
         */
        boolean hasG();
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         * @return The g.
         */
        ai.onnx.proto.OnnxMl.GraphProto getG();
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGOrBuilder();

        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return Whether the sparseTensor field is set.
         */
        boolean hasSparseTensor();
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return The sparseTensor.
         */
        ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensor();
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         */
        ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder();

        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return A list containing the floats.
         */
        java.util.List<java.lang.Float> getFloatsList();
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return The count of floats.
         */
        int getFloatsCount();
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @param index The index of the element to return.
         * @return The floats at the given index.
         */
        float getFloats(int index);

        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return A list containing the ints.
         */
        java.util.List<java.lang.Long> getIntsList();
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return The count of ints.
         */
        int getIntsCount();
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @param index The index of the element to return.
         * @return The ints at the given index.
         */
        long getInts(int index);

        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return A list containing the strings.
         */
        java.util.List<com.google.protobuf.ByteString> getStringsList();
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return The count of strings.
         */
        int getStringsCount();
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @param index The index of the element to return.
         * @return The strings at the given index.
         */
        com.google.protobuf.ByteString getStrings(int index);

        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.TensorProto>
        getTensorsList();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProto getTensors(int index);
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        int getTensorsCount();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
        getTensorsOrBuilderList();
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(
                int index);

        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.GraphProto>
        getGraphsList();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProto getGraphs(int index);
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        int getGraphsCount();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
        getGraphsOrBuilderList();
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(
                int index);

        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto>
        getSparseTensorsList();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensors(int index);
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        int getSparseTensorsCount();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
        getSparseTensorsOrBuilderList();
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
                int index);
    }
    /**
     * <pre>
     * Attributes
     * A named attribute containing either singular float, integer, string, graph,
     * and tensor values, or repeated float, integer, string, graph, and tensor values.
     * An AttributeProto MUST contain the name field, and *only one* of the
     * following content fields, effectively enforcing a C/C++ union equivalent.
     * </pre>
     *
     * Protobuf type {@code onnx.AttributeProto}
     */
    public static final class AttributeProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.AttributeProto)
            AttributeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use AttributeProto.newBuilder() to construct.
        private AttributeProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private AttributeProto() {
            name_ = "";
            refAttrName_ = "";
            docString_ = "";
            type_ = 0;
            s_ = com.google.protobuf.ByteString.EMPTY;
            floats_ = emptyFloatList();
            ints_ = emptyLongList();
            strings_ = java.util.Collections.emptyList();
            tensors_ = java.util.Collections.emptyList();
            graphs_ = java.util.Collections.emptyList();
            sparseTensors_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new AttributeProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private AttributeProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            name_ = bs;
                            break;
                        }
                        case 21: {
                            bitField0_ |= 0x00000010;
                            f_ = input.readFloat();
                            break;
                        }
                        case 24: {
                            bitField0_ |= 0x00000020;
                            i_ = input.readInt64();
                            break;
                        }
                        case 34: {
                            bitField0_ |= 0x00000040;
                            s_ = input.readBytes();
                            break;
                        }
                        case 42: {
                            ai.onnx.proto.OnnxMl.TensorProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000080) != 0)) {
                                subBuilder = t_.toBuilder();
                            }
                            t_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(t_);
                                t_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000080;
                            break;
                        }
                        case 50: {
                            ai.onnx.proto.OnnxMl.GraphProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000100) != 0)) {
                                subBuilder = g_.toBuilder();
                            }
                            g_ = input.readMessage(ai.onnx.proto.OnnxMl.GraphProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(g_);
                                g_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000100;
                            break;
                        }
                        case 61: {
                            if (!((mutable_bitField0_ & 0x00000400) != 0)) {
                                floats_ = newFloatList();
                                mutable_bitField0_ |= 0x00000400;
                            }
                            floats_.addFloat(input.readFloat());
                            break;
                        }
                        case 58: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000400) != 0) && input.getBytesUntilLimit() > 0) {
                                floats_ = newFloatList();
                                mutable_bitField0_ |= 0x00000400;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                floats_.addFloat(input.readFloat());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 64: {
                            if (!((mutable_bitField0_ & 0x00000800) != 0)) {
                                ints_ = newLongList();
                                mutable_bitField0_ |= 0x00000800;
                            }
                            ints_.addLong(input.readInt64());
                            break;
                        }
                        case 66: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000800) != 0) && input.getBytesUntilLimit() > 0) {
                                ints_ = newLongList();
                                mutable_bitField0_ |= 0x00000800;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                ints_.addLong(input.readInt64());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 74: {
                            if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                                strings_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
                                mutable_bitField0_ |= 0x00001000;
                            }
                            strings_.add(input.readBytes());
                            break;
                        }
                        case 82: {
                            if (!((mutable_bitField0_ & 0x00002000) != 0)) {
                                tensors_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorProto>();
                                mutable_bitField0_ |= 0x00002000;
                            }
                            tensors_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 90: {
                            if (!((mutable_bitField0_ & 0x00004000) != 0)) {
                                graphs_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.GraphProto>();
                                mutable_bitField0_ |= 0x00004000;
                            }
                            graphs_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.GraphProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 106: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000004;
                            docString_ = bs;
                            break;
                        }
                        case 160: {
                            int rawValue = input.readEnum();
                            @SuppressWarnings("deprecation")
                            ai.onnx.proto.OnnxMl.AttributeProto.AttributeType value = ai.onnx.proto.OnnxMl.AttributeProto.AttributeType.valueOf(rawValue);
                            if (value == null) {
                                unknownFields.mergeVarintField(20, rawValue);
                            } else {
                                bitField0_ |= 0x00000008;
                                type_ = rawValue;
                            }
                            break;
                        }
                        case 170: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000002;
                            refAttrName_ = bs;
                            break;
                        }
                        case 178: {
                            ai.onnx.proto.OnnxMl.SparseTensorProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000200) != 0)) {
                                subBuilder = sparseTensor_.toBuilder();
                            }
                            sparseTensor_ = input.readMessage(ai.onnx.proto.OnnxMl.SparseTensorProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(sparseTensor_);
                                sparseTensor_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000200;
                            break;
                        }
                        case 186: {
                            if (!((mutable_bitField0_ & 0x00008000) != 0)) {
                                sparseTensors_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.SparseTensorProto>();
                                mutable_bitField0_ |= 0x00008000;
                            }
                            sparseTensors_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.SparseTensorProto.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000400) != 0)) {
                    floats_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00000800) != 0)) {
                    ints_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00001000) != 0)) {
                    strings_ = java.util.Collections.unmodifiableList(strings_); // C
                }
                if (((mutable_bitField0_ & 0x00002000) != 0)) {
                    tensors_ = java.util.Collections.unmodifiableList(tensors_);
                }
                if (((mutable_bitField0_ & 0x00004000) != 0)) {
                    graphs_ = java.util.Collections.unmodifiableList(graphs_);
                }
                if (((mutable_bitField0_ & 0x00008000) != 0)) {
                    sparseTensors_ = java.util.Collections.unmodifiableList(sparseTensors_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_AttributeProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_AttributeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.AttributeProto.class, ai.onnx.proto.OnnxMl.AttributeProto.Builder.class);
        }

        /**
         * <pre>
         * Note: this enum is structurally identical to the OpSchema::AttrType
         * enum defined in schema.h.  If you rev one, you likely need to rev the other.
         * </pre>
         *
         * Protobuf enum {@code onnx.AttributeProto.AttributeType}
         */
        public enum AttributeType
                implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>UNDEFINED = 0;</code>
             */
            UNDEFINED(0),
            /**
             * <code>FLOAT = 1;</code>
             */
            FLOAT(1),
            /**
             * <code>INT = 2;</code>
             */
            INT(2),
            /**
             * <code>STRING = 3;</code>
             */
            STRING(3),
            /**
             * <code>TENSOR = 4;</code>
             */
            TENSOR(4),
            /**
             * <code>GRAPH = 5;</code>
             */
            GRAPH(5),
            /**
             * <code>SPARSE_TENSOR = 11;</code>
             */
            SPARSE_TENSOR(11),
            /**
             * <code>FLOATS = 6;</code>
             */
            FLOATS(6),
            /**
             * <code>INTS = 7;</code>
             */
            INTS(7),
            /**
             * <code>STRINGS = 8;</code>
             */
            STRINGS(8),
            /**
             * <code>TENSORS = 9;</code>
             */
            TENSORS(9),
            /**
             * <code>GRAPHS = 10;</code>
             */
            GRAPHS(10),
            /**
             * <code>SPARSE_TENSORS = 12;</code>
             */
            SPARSE_TENSORS(12),
            ;

            /**
             * <code>UNDEFINED = 0;</code>
             */
            public static final int UNDEFINED_VALUE = 0;
            /**
             * <code>FLOAT = 1;</code>
             */
            public static final int FLOAT_VALUE = 1;
            /**
             * <code>INT = 2;</code>
             */
            public static final int INT_VALUE = 2;
            /**
             * <code>STRING = 3;</code>
             */
            public static final int STRING_VALUE = 3;
            /**
             * <code>TENSOR = 4;</code>
             */
            public static final int TENSOR_VALUE = 4;
            /**
             * <code>GRAPH = 5;</code>
             */
            public static final int GRAPH_VALUE = 5;
            /**
             * <code>SPARSE_TENSOR = 11;</code>
             */
            public static final int SPARSE_TENSOR_VALUE = 11;
            /**
             * <code>FLOATS = 6;</code>
             */
            public static final int FLOATS_VALUE = 6;
            /**
             * <code>INTS = 7;</code>
             */
            public static final int INTS_VALUE = 7;
            /**
             * <code>STRINGS = 8;</code>
             */
            public static final int STRINGS_VALUE = 8;
            /**
             * <code>TENSORS = 9;</code>
             */
            public static final int TENSORS_VALUE = 9;
            /**
             * <code>GRAPHS = 10;</code>
             */
            public static final int GRAPHS_VALUE = 10;
            /**
             * <code>SPARSE_TENSORS = 12;</code>
             */
            public static final int SPARSE_TENSORS_VALUE = 12;


            public final int getNumber() {
                return value;
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static AttributeType valueOf(int value) {
                return forNumber(value);
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static AttributeType forNumber(int value) {
                switch (value) {
                    case 0: return UNDEFINED;
                    case 1: return FLOAT;
                    case 2: return INT;
                    case 3: return STRING;
                    case 4: return TENSOR;
                    case 5: return GRAPH;
                    case 11: return SPARSE_TENSOR;
                    case 6: return FLOATS;
                    case 7: return INTS;
                    case 8: return STRINGS;
                    case 9: return TENSORS;
                    case 10: return GRAPHS;
                    case 12: return SPARSE_TENSORS;
                    default: return null;
                }
            }

            public static com.google.protobuf.Internal.EnumLiteMap<AttributeType>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                    AttributeType> internalValueMap =
                    new com.google.protobuf.Internal.EnumLiteMap<AttributeType>() {
                        public AttributeType findValueByNumber(int number) {
                            return AttributeType.forNumber(number);
                        }
                    };

            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.AttributeProto.getDescriptor().getEnumTypes().get(0);
            }

            private static final AttributeType[] VALUES = values();

            public static AttributeType valueOf(
                    com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                            "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }

            private final int value;

            private AttributeType(int value) {
                this.value = value;
            }

            // @@protoc_insertion_point(enum_scope:onnx.AttributeProto.AttributeType)
        }

        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        private volatile java.lang.Object name_;
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int REF_ATTR_NAME_FIELD_NUMBER = 21;
        private volatile java.lang.Object refAttrName_;
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return Whether the refAttrName field is set.
         */
        @java.lang.Override
        public boolean hasRefAttrName() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The refAttrName.
         */
        @java.lang.Override
        public java.lang.String getRefAttrName() {
            java.lang.Object ref = refAttrName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    refAttrName_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
         * In this case, this AttributeProto does not contain data, and it's a reference of attribute
         * in parent scope.
         * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
         * </pre>
         *
         * <code>optional string ref_attr_name = 21;</code>
         * @return The bytes for refAttrName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getRefAttrNameBytes() {
            java.lang.Object ref = refAttrName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                refAttrName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int DOC_STRING_FIELD_NUMBER = 13;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this attribute. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 13;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int TYPE_FIELD_NUMBER = 20;
        private int type_;
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
         * @return Whether the type field is set.
         */
        @java.lang.Override public boolean hasType() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The type field MUST be present for this version of the IR.
         * For 0.0.1 versions of the IR, this field was not defined, and
         * implementations needed to use has_field heuristics to determine
         * which value field was in use.  For IR_VERSION 0.0.2 or later, this
         * field MUST be set and match the f|i|s|t|... field in use.  This
         * change was made to accommodate proto3 implementations.
         * </pre>
         *
         * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
         * @return The type.
         */
        @java.lang.Override public ai.onnx.proto.OnnxMl.AttributeProto.AttributeType getType() {
            @SuppressWarnings("deprecation")
            ai.onnx.proto.OnnxMl.AttributeProto.AttributeType result = ai.onnx.proto.OnnxMl.AttributeProto.AttributeType.valueOf(type_);
            return result == null ? ai.onnx.proto.OnnxMl.AttributeProto.AttributeType.UNDEFINED : result;
        }

        public static final int F_FIELD_NUMBER = 2;
        private float f_;
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return Whether the f field is set.
         */
        @java.lang.Override
        public boolean hasF() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Exactly ONE of the following fields must be present for this version of the IR
         * </pre>
         *
         * <code>optional float f = 2;</code>
         * @return The f.
         */
        @java.lang.Override
        public float getF() {
            return f_;
        }

        public static final int I_FIELD_NUMBER = 3;
        private long i_;
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return Whether the i field is set.
         */
        @java.lang.Override
        public boolean hasI() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * int
         * </pre>
         *
         * <code>optional int64 i = 3;</code>
         * @return The i.
         */
        @java.lang.Override
        public long getI() {
            return i_;
        }

        public static final int S_FIELD_NUMBER = 4;
        private com.google.protobuf.ByteString s_;
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return Whether the s field is set.
         */
        @java.lang.Override
        public boolean hasS() {
            return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * UTF-8 string
         * </pre>
         *
         * <code>optional bytes s = 4;</code>
         * @return The s.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getS() {
            return s_;
        }

        public static final int T_FIELD_NUMBER = 5;
        private ai.onnx.proto.OnnxMl.TensorProto t_;
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         * @return Whether the t field is set.
         */
        @java.lang.Override
        public boolean hasT() {
            return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         * @return The t.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getT() {
            return t_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : t_;
        }
        /**
         * <pre>
         * tensor value
         * </pre>
         *
         * <code>optional .onnx.TensorProto t = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTOrBuilder() {
            return t_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : t_;
        }

        public static final int G_FIELD_NUMBER = 6;
        private ai.onnx.proto.OnnxMl.GraphProto g_;
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         * @return Whether the g field is set.
         */
        @java.lang.Override
        public boolean hasG() {
            return ((bitField0_ & 0x00000100) != 0);
        }
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         * @return The g.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getG() {
            return g_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : g_;
        }
        /**
         * <pre>
         * graph
         * </pre>
         *
         * <code>optional .onnx.GraphProto g = 6;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGOrBuilder() {
            return g_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : g_;
        }

        public static final int SPARSE_TENSOR_FIELD_NUMBER = 22;
        private ai.onnx.proto.OnnxMl.SparseTensorProto sparseTensor_;
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return Whether the sparseTensor field is set.
         */
        @java.lang.Override
        public boolean hasSparseTensor() {
            return ((bitField0_ & 0x00000200) != 0);
        }
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         * @return The sparseTensor.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensor() {
            return sparseTensor_ == null ? ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        }
        /**
         * <pre>
         * sparse tensor value
         * </pre>
         *
         * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
            return sparseTensor_ == null ? ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        }

        public static final int FLOATS_FIELD_NUMBER = 7;
        private com.google.protobuf.Internal.FloatList floats_;
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return A list containing the floats.
         */
        @java.lang.Override
        public java.util.List<java.lang.Float>
        getFloatsList() {
            return floats_;
        }
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @return The count of floats.
         */
        public int getFloatsCount() {
            return floats_.size();
        }
        /**
         * <pre>
         * list of floats
         * </pre>
         *
         * <code>repeated float floats = 7;</code>
         * @param index The index of the element to return.
         * @return The floats at the given index.
         */
        public float getFloats(int index) {
            return floats_.getFloat(index);
        }

        public static final int INTS_FIELD_NUMBER = 8;
        private com.google.protobuf.Internal.LongList ints_;
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return A list containing the ints.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getIntsList() {
            return ints_;
        }
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @return The count of ints.
         */
        public int getIntsCount() {
            return ints_.size();
        }
        /**
         * <pre>
         * list of ints
         * </pre>
         *
         * <code>repeated int64 ints = 8;</code>
         * @param index The index of the element to return.
         * @return The ints at the given index.
         */
        public long getInts(int index) {
            return ints_.getLong(index);
        }

        public static final int STRINGS_FIELD_NUMBER = 9;
        private java.util.List<com.google.protobuf.ByteString> strings_;
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return A list containing the strings.
         */
        @java.lang.Override
        public java.util.List<com.google.protobuf.ByteString>
        getStringsList() {
            return strings_;
        }
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @return The count of strings.
         */
        public int getStringsCount() {
            return strings_.size();
        }
        /**
         * <pre>
         * list of UTF-8 strings
         * </pre>
         *
         * <code>repeated bytes strings = 9;</code>
         * @param index The index of the element to return.
         * @return The strings at the given index.
         */
        public com.google.protobuf.ByteString getStrings(int index) {
            return strings_.get(index);
        }

        public static final int TENSORS_FIELD_NUMBER = 10;
        private java.util.List<ai.onnx.proto.OnnxMl.TensorProto> tensors_;
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.TensorProto> getTensorsList() {
            return tensors_;
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
        getTensorsOrBuilderList() {
            return tensors_;
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public int getTensorsCount() {
            return tensors_.size();
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getTensors(int index) {
            return tensors_.get(index);
        }
        /**
         * <pre>
         * list of tensors
         * </pre>
         *
         * <code>repeated .onnx.TensorProto tensors = 10;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(
                int index) {
            return tensors_.get(index);
        }

        public static final int GRAPHS_FIELD_NUMBER = 11;
        private java.util.List<ai.onnx.proto.OnnxMl.GraphProto> graphs_;
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.GraphProto> getGraphsList() {
            return graphs_;
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
        getGraphsOrBuilderList() {
            return graphs_;
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public int getGraphsCount() {
            return graphs_.size();
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getGraphs(int index) {
            return graphs_.get(index);
        }
        /**
         * <pre>
         * list of graph
         * </pre>
         *
         * <code>repeated .onnx.GraphProto graphs = 11;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(
                int index) {
            return graphs_.get(index);
        }

        public static final int SPARSE_TENSORS_FIELD_NUMBER = 23;
        private java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> sparseTensors_;
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> getSparseTensorsList() {
            return sparseTensors_;
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
        getSparseTensorsOrBuilderList() {
            return sparseTensors_;
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public int getSparseTensorsCount() {
            return sparseTensors_.size();
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensors(int index) {
            return sparseTensors_.get(index);
        }
        /**
         * <pre>
         * list of sparse tensors
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
                int index) {
            return sparseTensors_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeFloat(2, f_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                output.writeInt64(3, i_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                output.writeBytes(4, s_);
            }
            if (((bitField0_ & 0x00000080) != 0)) {
                output.writeMessage(5, getT());
            }
            if (((bitField0_ & 0x00000100) != 0)) {
                output.writeMessage(6, getG());
            }
            for (int i = 0; i < floats_.size(); i++) {
                output.writeFloat(7, floats_.getFloat(i));
            }
            for (int i = 0; i < ints_.size(); i++) {
                output.writeInt64(8, ints_.getLong(i));
            }
            for (int i = 0; i < strings_.size(); i++) {
                output.writeBytes(9, strings_.get(i));
            }
            for (int i = 0; i < tensors_.size(); i++) {
                output.writeMessage(10, tensors_.get(i));
            }
            for (int i = 0; i < graphs_.size(); i++) {
                output.writeMessage(11, graphs_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 13, docString_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                output.writeEnum(20, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 21, refAttrName_);
            }
            if (((bitField0_ & 0x00000200) != 0)) {
                output.writeMessage(22, getSparseTensor());
            }
            for (int i = 0; i < sparseTensors_.size(); i++) {
                output.writeMessage(23, sparseTensors_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeFloatSize(2, f_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(3, i_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeBytesSize(4, s_);
            }
            if (((bitField0_ & 0x00000080) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(5, getT());
            }
            if (((bitField0_ & 0x00000100) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(6, getG());
            }
            {
                int dataSize = 0;
                dataSize = 4 * getFloatsList().size();
                size += dataSize;
                size += 1 * getFloatsList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < ints_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeInt64SizeNoTag(ints_.getLong(i));
                }
                size += dataSize;
                size += 1 * getIntsList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < strings_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeBytesSizeNoTag(strings_.get(i));
                }
                size += dataSize;
                size += 1 * getStringsList().size();
            }
            for (int i = 0; i < tensors_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(10, tensors_.get(i));
            }
            for (int i = 0; i < graphs_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(11, graphs_.get(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, docString_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeEnumSize(20, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(21, refAttrName_);
            }
            if (((bitField0_ & 0x00000200) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(22, getSparseTensor());
            }
            for (int i = 0; i < sparseTensors_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(23, sparseTensors_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.AttributeProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.AttributeProto other = (ai.onnx.proto.OnnxMl.AttributeProto) obj;

            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (hasRefAttrName() != other.hasRefAttrName()) return false;
            if (hasRefAttrName()) {
                if (!getRefAttrName()
                        .equals(other.getRefAttrName())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (hasType() != other.hasType()) return false;
            if (hasType()) {
                if (type_ != other.type_) return false;
            }
            if (hasF() != other.hasF()) return false;
            if (hasF()) {
                if (java.lang.Float.floatToIntBits(getF())
                        != java.lang.Float.floatToIntBits(
                        other.getF())) return false;
            }
            if (hasI() != other.hasI()) return false;
            if (hasI()) {
                if (getI()
                        != other.getI()) return false;
            }
            if (hasS() != other.hasS()) return false;
            if (hasS()) {
                if (!getS()
                        .equals(other.getS())) return false;
            }
            if (hasT() != other.hasT()) return false;
            if (hasT()) {
                if (!getT()
                        .equals(other.getT())) return false;
            }
            if (hasG() != other.hasG()) return false;
            if (hasG()) {
                if (!getG()
                        .equals(other.getG())) return false;
            }
            if (hasSparseTensor() != other.hasSparseTensor()) return false;
            if (hasSparseTensor()) {
                if (!getSparseTensor()
                        .equals(other.getSparseTensor())) return false;
            }
            if (!getFloatsList()
                    .equals(other.getFloatsList())) return false;
            if (!getIntsList()
                    .equals(other.getIntsList())) return false;
            if (!getStringsList()
                    .equals(other.getStringsList())) return false;
            if (!getTensorsList()
                    .equals(other.getTensorsList())) return false;
            if (!getGraphsList()
                    .equals(other.getGraphsList())) return false;
            if (!getSparseTensorsList()
                    .equals(other.getSparseTensorsList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasRefAttrName()) {
                hash = (37 * hash) + REF_ATTR_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getRefAttrName().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasType()) {
                hash = (37 * hash) + TYPE_FIELD_NUMBER;
                hash = (53 * hash) + type_;
            }
            if (hasF()) {
                hash = (37 * hash) + F_FIELD_NUMBER;
                hash = (53 * hash) + java.lang.Float.floatToIntBits(
                        getF());
            }
            if (hasI()) {
                hash = (37 * hash) + I_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getI());
            }
            if (hasS()) {
                hash = (37 * hash) + S_FIELD_NUMBER;
                hash = (53 * hash) + getS().hashCode();
            }
            if (hasT()) {
                hash = (37 * hash) + T_FIELD_NUMBER;
                hash = (53 * hash) + getT().hashCode();
            }
            if (hasG()) {
                hash = (37 * hash) + G_FIELD_NUMBER;
                hash = (53 * hash) + getG().hashCode();
            }
            if (hasSparseTensor()) {
                hash = (37 * hash) + SPARSE_TENSOR_FIELD_NUMBER;
                hash = (53 * hash) + getSparseTensor().hashCode();
            }
            if (getFloatsCount() > 0) {
                hash = (37 * hash) + FLOATS_FIELD_NUMBER;
                hash = (53 * hash) + getFloatsList().hashCode();
            }
            if (getIntsCount() > 0) {
                hash = (37 * hash) + INTS_FIELD_NUMBER;
                hash = (53 * hash) + getIntsList().hashCode();
            }
            if (getStringsCount() > 0) {
                hash = (37 * hash) + STRINGS_FIELD_NUMBER;
                hash = (53 * hash) + getStringsList().hashCode();
            }
            if (getTensorsCount() > 0) {
                hash = (37 * hash) + TENSORS_FIELD_NUMBER;
                hash = (53 * hash) + getTensorsList().hashCode();
            }
            if (getGraphsCount() > 0) {
                hash = (37 * hash) + GRAPHS_FIELD_NUMBER;
                hash = (53 * hash) + getGraphsList().hashCode();
            }
            if (getSparseTensorsCount() > 0) {
                hash = (37 * hash) + SPARSE_TENSORS_FIELD_NUMBER;
                hash = (53 * hash) + getSparseTensorsList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.AttributeProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.AttributeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Attributes
         * A named attribute containing either singular float, integer, string, graph,
         * and tensor values, or repeated float, integer, string, graph, and tensor values.
         * An AttributeProto MUST contain the name field, and *only one* of the
         * following content fields, effectively enforcing a C/C++ union equivalent.
         * </pre>
         *
         * Protobuf type {@code onnx.AttributeProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.AttributeProto)
                ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_AttributeProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_AttributeProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.AttributeProto.class, ai.onnx.proto.OnnxMl.AttributeProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.AttributeProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getTFieldBuilder();
                    getGFieldBuilder();
                    getSparseTensorFieldBuilder();
                    getTensorsFieldBuilder();
                    getGraphsFieldBuilder();
                    getSparseTensorsFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                name_ = "";
                bitField0_ = (bitField0_ & ~0x00000001);
                refAttrName_ = "";
                bitField0_ = (bitField0_ & ~0x00000002);
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000004);
                type_ = 0;
                bitField0_ = (bitField0_ & ~0x00000008);
                f_ = 0F;
                bitField0_ = (bitField0_ & ~0x00000010);
                i_ = 0L;
                bitField0_ = (bitField0_ & ~0x00000020);
                s_ = com.google.protobuf.ByteString.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000040);
                if (tBuilder_ == null) {
                    t_ = null;
                } else {
                    tBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                if (gBuilder_ == null) {
                    g_ = null;
                } else {
                    gBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000100);
                if (sparseTensorBuilder_ == null) {
                    sparseTensor_ = null;
                } else {
                    sparseTensorBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000200);
                floats_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000400);
                ints_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000800);
                strings_ = java.util.Collections.emptyList();
                bitField0_ = (bitField0_ & ~0x00001000);
                if (tensorsBuilder_ == null) {
                    tensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00002000);
                } else {
                    tensorsBuilder_.clear();
                }
                if (graphsBuilder_ == null) {
                    graphs_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00004000);
                } else {
                    graphsBuilder_.clear();
                }
                if (sparseTensorsBuilder_ == null) {
                    sparseTensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00008000);
                } else {
                    sparseTensorsBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_AttributeProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.AttributeProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.AttributeProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.AttributeProto build() {
                ai.onnx.proto.OnnxMl.AttributeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.AttributeProto buildPartial() {
                ai.onnx.proto.OnnxMl.AttributeProto result = new ai.onnx.proto.OnnxMl.AttributeProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.name_ = name_;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    to_bitField0_ |= 0x00000002;
                }
                result.refAttrName_ = refAttrName_;
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    to_bitField0_ |= 0x00000004;
                }
                result.docString_ = docString_;
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    to_bitField0_ |= 0x00000008;
                }
                result.type_ = type_;
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    result.f_ = f_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.i_ = i_;
                    to_bitField0_ |= 0x00000020;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    to_bitField0_ |= 0x00000040;
                }
                result.s_ = s_;
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    if (tBuilder_ == null) {
                        result.t_ = t_;
                    } else {
                        result.t_ = tBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000080;
                }
                if (((from_bitField0_ & 0x00000100) != 0)) {
                    if (gBuilder_ == null) {
                        result.g_ = g_;
                    } else {
                        result.g_ = gBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000100;
                }
                if (((from_bitField0_ & 0x00000200) != 0)) {
                    if (sparseTensorBuilder_ == null) {
                        result.sparseTensor_ = sparseTensor_;
                    } else {
                        result.sparseTensor_ = sparseTensorBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000200;
                }
                if (((bitField0_ & 0x00000400) != 0)) {
                    floats_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000400);
                }
                result.floats_ = floats_;
                if (((bitField0_ & 0x00000800) != 0)) {
                    ints_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000800);
                }
                result.ints_ = ints_;
                if (((bitField0_ & 0x00001000) != 0)) {
                    strings_ = java.util.Collections.unmodifiableList(strings_);
                    bitField0_ = (bitField0_ & ~0x00001000);
                }
                result.strings_ = strings_;
                if (tensorsBuilder_ == null) {
                    if (((bitField0_ & 0x00002000) != 0)) {
                        tensors_ = java.util.Collections.unmodifiableList(tensors_);
                        bitField0_ = (bitField0_ & ~0x00002000);
                    }
                    result.tensors_ = tensors_;
                } else {
                    result.tensors_ = tensorsBuilder_.build();
                }
                if (graphsBuilder_ == null) {
                    if (((bitField0_ & 0x00004000) != 0)) {
                        graphs_ = java.util.Collections.unmodifiableList(graphs_);
                        bitField0_ = (bitField0_ & ~0x00004000);
                    }
                    result.graphs_ = graphs_;
                } else {
                    result.graphs_ = graphsBuilder_.build();
                }
                if (sparseTensorsBuilder_ == null) {
                    if (((bitField0_ & 0x00008000) != 0)) {
                        sparseTensors_ = java.util.Collections.unmodifiableList(sparseTensors_);
                        bitField0_ = (bitField0_ & ~0x00008000);
                    }
                    result.sparseTensors_ = sparseTensors_;
                } else {
                    result.sparseTensors_ = sparseTensorsBuilder_.build();
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.AttributeProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.AttributeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.AttributeProto other) {
                if (other == ai.onnx.proto.OnnxMl.AttributeProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    bitField0_ |= 0x00000001;
                    name_ = other.name_;
                    onChanged();
                }
                if (other.hasRefAttrName()) {
                    bitField0_ |= 0x00000002;
                    refAttrName_ = other.refAttrName_;
                    onChanged();
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000004;
                    docString_ = other.docString_;
                    onChanged();
                }
                if (other.hasType()) {
                    setType(other.getType());
                }
                if (other.hasF()) {
                    setF(other.getF());
                }
                if (other.hasI()) {
                    setI(other.getI());
                }
                if (other.hasS()) {
                    setS(other.getS());
                }
                if (other.hasT()) {
                    mergeT(other.getT());
                }
                if (other.hasG()) {
                    mergeG(other.getG());
                }
                if (other.hasSparseTensor()) {
                    mergeSparseTensor(other.getSparseTensor());
                }
                if (!other.floats_.isEmpty()) {
                    if (floats_.isEmpty()) {
                        floats_ = other.floats_;
                        bitField0_ = (bitField0_ & ~0x00000400);
                    } else {
                        ensureFloatsIsMutable();
                        floats_.addAll(other.floats_);
                    }
                    onChanged();
                }
                if (!other.ints_.isEmpty()) {
                    if (ints_.isEmpty()) {
                        ints_ = other.ints_;
                        bitField0_ = (bitField0_ & ~0x00000800);
                    } else {
                        ensureIntsIsMutable();
                        ints_.addAll(other.ints_);
                    }
                    onChanged();
                }
                if (!other.strings_.isEmpty()) {
                    if (strings_.isEmpty()) {
                        strings_ = other.strings_;
                        bitField0_ = (bitField0_ & ~0x00001000);
                    } else {
                        ensureStringsIsMutable();
                        strings_.addAll(other.strings_);
                    }
                    onChanged();
                }
                if (tensorsBuilder_ == null) {
                    if (!other.tensors_.isEmpty()) {
                        if (tensors_.isEmpty()) {
                            tensors_ = other.tensors_;
                            bitField0_ = (bitField0_ & ~0x00002000);
                        } else {
                            ensureTensorsIsMutable();
                            tensors_.addAll(other.tensors_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.tensors_.isEmpty()) {
                        if (tensorsBuilder_.isEmpty()) {
                            tensorsBuilder_.dispose();
                            tensorsBuilder_ = null;
                            tensors_ = other.tensors_;
                            bitField0_ = (bitField0_ & ~0x00002000);
                            tensorsBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getTensorsFieldBuilder() : null;
                        } else {
                            tensorsBuilder_.addAllMessages(other.tensors_);
                        }
                    }
                }
                if (graphsBuilder_ == null) {
                    if (!other.graphs_.isEmpty()) {
                        if (graphs_.isEmpty()) {
                            graphs_ = other.graphs_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                        } else {
                            ensureGraphsIsMutable();
                            graphs_.addAll(other.graphs_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.graphs_.isEmpty()) {
                        if (graphsBuilder_.isEmpty()) {
                            graphsBuilder_.dispose();
                            graphsBuilder_ = null;
                            graphs_ = other.graphs_;
                            bitField0_ = (bitField0_ & ~0x00004000);
                            graphsBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getGraphsFieldBuilder() : null;
                        } else {
                            graphsBuilder_.addAllMessages(other.graphs_);
                        }
                    }
                }
                if (sparseTensorsBuilder_ == null) {
                    if (!other.sparseTensors_.isEmpty()) {
                        if (sparseTensors_.isEmpty()) {
                            sparseTensors_ = other.sparseTensors_;
                            bitField0_ = (bitField0_ & ~0x00008000);
                        } else {
                            ensureSparseTensorsIsMutable();
                            sparseTensors_.addAll(other.sparseTensors_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.sparseTensors_.isEmpty()) {
                        if (sparseTensorsBuilder_.isEmpty()) {
                            sparseTensorsBuilder_.dispose();
                            sparseTensorsBuilder_ = null;
                            sparseTensors_ = other.sparseTensors_;
                            bitField0_ = (bitField0_ & ~0x00008000);
                            sparseTensorsBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getSparseTensorsFieldBuilder() : null;
                        } else {
                            sparseTensorsBuilder_.addAllMessages(other.sparseTensors_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.AttributeProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.AttributeProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.lang.Object name_ = "";
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                name_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                bitField0_ = (bitField0_ & ~0x00000001);
                name_ = getDefaultInstance().getName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                name_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object refAttrName_ = "";
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return Whether the refAttrName field is set.
             */
            public boolean hasRefAttrName() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return The refAttrName.
             */
            public java.lang.String getRefAttrName() {
                java.lang.Object ref = refAttrName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        refAttrName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return The bytes for refAttrName.
             */
            public com.google.protobuf.ByteString
            getRefAttrNameBytes() {
                java.lang.Object ref = refAttrName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    refAttrName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @param value The refAttrName to set.
             * @return This builder for chaining.
             */
            public Builder setRefAttrName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                refAttrName_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @return This builder for chaining.
             */
            public Builder clearRefAttrName() {
                bitField0_ = (bitField0_ & ~0x00000002);
                refAttrName_ = getDefaultInstance().getRefAttrName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
             * In this case, this AttributeProto does not contain data, and it's a reference of attribute
             * in parent scope.
             * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
             * </pre>
             *
             * <code>optional string ref_attr_name = 21;</code>
             * @param value The bytes for refAttrName to set.
             * @return This builder for chaining.
             */
            public Builder setRefAttrNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                refAttrName_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000004);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this attribute. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 13;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                docString_ = value;
                onChanged();
                return this;
            }

            private int type_ = 0;
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
             * @return Whether the type field is set.
             */
            @java.lang.Override public boolean hasType() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
             * @return The type.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.AttributeProto.AttributeType getType() {
                @SuppressWarnings("deprecation")
                ai.onnx.proto.OnnxMl.AttributeProto.AttributeType result = ai.onnx.proto.OnnxMl.AttributeProto.AttributeType.valueOf(type_);
                return result == null ? ai.onnx.proto.OnnxMl.AttributeProto.AttributeType.UNDEFINED : result;
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
             * @param value The type to set.
             * @return This builder for chaining.
             */
            public Builder setType(ai.onnx.proto.OnnxMl.AttributeProto.AttributeType value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                type_ = value.getNumber();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The type field MUST be present for this version of the IR.
             * For 0.0.1 versions of the IR, this field was not defined, and
             * implementations needed to use has_field heuristics to determine
             * which value field was in use.  For IR_VERSION 0.0.2 or later, this
             * field MUST be set and match the f|i|s|t|... field in use.  This
             * change was made to accommodate proto3 implementations.
             * </pre>
             *
             * <code>optional .onnx.AttributeProto.AttributeType type = 20;</code>
             * @return This builder for chaining.
             */
            public Builder clearType() {
                bitField0_ = (bitField0_ & ~0x00000008);
                type_ = 0;
                onChanged();
                return this;
            }

            private float f_ ;
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return Whether the f field is set.
             */
            @java.lang.Override
            public boolean hasF() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return The f.
             */
            @java.lang.Override
            public float getF() {
                return f_;
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @param value The f to set.
             * @return This builder for chaining.
             */
            public Builder setF(float value) {
                bitField0_ |= 0x00000010;
                f_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Exactly ONE of the following fields must be present for this version of the IR
             * </pre>
             *
             * <code>optional float f = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearF() {
                bitField0_ = (bitField0_ & ~0x00000010);
                f_ = 0F;
                onChanged();
                return this;
            }

            private long i_ ;
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return Whether the i field is set.
             */
            @java.lang.Override
            public boolean hasI() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return The i.
             */
            @java.lang.Override
            public long getI() {
                return i_;
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @param value The i to set.
             * @return This builder for chaining.
             */
            public Builder setI(long value) {
                bitField0_ |= 0x00000020;
                i_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * int
             * </pre>
             *
             * <code>optional int64 i = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearI() {
                bitField0_ = (bitField0_ & ~0x00000020);
                i_ = 0L;
                onChanged();
                return this;
            }

            private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return Whether the s field is set.
             */
            @java.lang.Override
            public boolean hasS() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return The s.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString getS() {
                return s_;
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @param value The s to set.
             * @return This builder for chaining.
             */
            public Builder setS(com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000040;
                s_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * UTF-8 string
             * </pre>
             *
             * <code>optional bytes s = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearS() {
                bitField0_ = (bitField0_ & ~0x00000040);
                s_ = getDefaultInstance().getS();
                onChanged();
                return this;
            }

            private ai.onnx.proto.OnnxMl.TensorProto t_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder> tBuilder_;
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             * @return Whether the t field is set.
             */
            public boolean hasT() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             * @return The t.
             */
            public ai.onnx.proto.OnnxMl.TensorProto getT() {
                if (tBuilder_ == null) {
                    return t_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : t_;
                } else {
                    return tBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public Builder setT(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (tBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    t_ = value;
                    onChanged();
                } else {
                    tBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public Builder setT(
                    ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (tBuilder_ == null) {
                    t_ = builderForValue.build();
                    onChanged();
                } else {
                    tBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public Builder mergeT(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (tBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0) &&
                            t_ != null &&
                            t_ != ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance()) {
                        t_ =
                                ai.onnx.proto.OnnxMl.TensorProto.newBuilder(t_).mergeFrom(value).buildPartial();
                    } else {
                        t_ = value;
                    }
                    onChanged();
                } else {
                    tBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public Builder clearT() {
                if (tBuilder_ == null) {
                    t_ = null;
                    onChanged();
                } else {
                    tBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                return this;
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder getTBuilder() {
                bitField0_ |= 0x00000080;
                onChanged();
                return getTFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTOrBuilder() {
                if (tBuilder_ != null) {
                    return tBuilder_.getMessageOrBuilder();
                } else {
                    return t_ == null ?
                            ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : t_;
                }
            }
            /**
             * <pre>
             * tensor value
             * </pre>
             *
             * <code>optional .onnx.TensorProto t = 5;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getTFieldBuilder() {
                if (tBuilder_ == null) {
                    tBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>(
                            getT(),
                            getParentForChildren(),
                            isClean());
                    t_ = null;
                }
                return tBuilder_;
            }

            private ai.onnx.proto.OnnxMl.GraphProto g_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder> gBuilder_;
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             * @return Whether the g field is set.
             */
            public boolean hasG() {
                return ((bitField0_ & 0x00000100) != 0);
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             * @return The g.
             */
            public ai.onnx.proto.OnnxMl.GraphProto getG() {
                if (gBuilder_ == null) {
                    return g_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : g_;
                } else {
                    return gBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public Builder setG(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (gBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    g_ = value;
                    onChanged();
                } else {
                    gBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000100;
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public Builder setG(
                    ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (gBuilder_ == null) {
                    g_ = builderForValue.build();
                    onChanged();
                } else {
                    gBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000100;
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public Builder mergeG(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (gBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0) &&
                            g_ != null &&
                            g_ != ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance()) {
                        g_ =
                                ai.onnx.proto.OnnxMl.GraphProto.newBuilder(g_).mergeFrom(value).buildPartial();
                    } else {
                        g_ = value;
                    }
                    onChanged();
                } else {
                    gBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000100;
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public Builder clearG() {
                if (gBuilder_ == null) {
                    g_ = null;
                    onChanged();
                } else {
                    gBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000100);
                return this;
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder getGBuilder() {
                bitField0_ |= 0x00000100;
                onChanged();
                return getGFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGOrBuilder() {
                if (gBuilder_ != null) {
                    return gBuilder_.getMessageOrBuilder();
                } else {
                    return g_ == null ?
                            ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : g_;
                }
            }
            /**
             * <pre>
             * graph
             * </pre>
             *
             * <code>optional .onnx.GraphProto g = 6;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getGFieldBuilder() {
                if (gBuilder_ == null) {
                    gBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>(
                            getG(),
                            getParentForChildren(),
                            isClean());
                    g_ = null;
                }
                return gBuilder_;
            }

            private ai.onnx.proto.OnnxMl.SparseTensorProto sparseTensor_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder> sparseTensorBuilder_;
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             * @return Whether the sparseTensor field is set.
             */
            public boolean hasSparseTensor() {
                return ((bitField0_ & 0x00000200) != 0);
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             * @return The sparseTensor.
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensor() {
                if (sparseTensorBuilder_ == null) {
                    return sparseTensor_ == null ? ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;
                } else {
                    return sparseTensorBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder setSparseTensor(ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseTensorBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    sparseTensor_ = value;
                    onChanged();
                } else {
                    sparseTensorBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000200;
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder setSparseTensor(
                    ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorBuilder_ == null) {
                    sparseTensor_ = builderForValue.build();
                    onChanged();
                } else {
                    sparseTensorBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000200;
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder mergeSparseTensor(ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseTensorBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0) &&
                            sparseTensor_ != null &&
                            sparseTensor_ != ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance()) {
                        sparseTensor_ =
                                ai.onnx.proto.OnnxMl.SparseTensorProto.newBuilder(sparseTensor_).mergeFrom(value).buildPartial();
                    } else {
                        sparseTensor_ = value;
                    }
                    onChanged();
                } else {
                    sparseTensorBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000200;
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public Builder clearSparseTensor() {
                if (sparseTensorBuilder_ == null) {
                    sparseTensor_ = null;
                    onChanged();
                } else {
                    sparseTensorBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000200);
                return this;
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder getSparseTensorBuilder() {
                bitField0_ |= 0x00000200;
                onChanged();
                return getSparseTensorFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
                if (sparseTensorBuilder_ != null) {
                    return sparseTensorBuilder_.getMessageOrBuilder();
                } else {
                    return sparseTensor_ == null ?
                            ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance() : sparseTensor_;
                }
            }
            /**
             * <pre>
             * sparse tensor value
             * </pre>
             *
             * <code>optional .onnx.SparseTensorProto sparse_tensor = 22;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
            getSparseTensorFieldBuilder() {
                if (sparseTensorBuilder_ == null) {
                    sparseTensorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>(
                            getSparseTensor(),
                            getParentForChildren(),
                            isClean());
                    sparseTensor_ = null;
                }
                return sparseTensorBuilder_;
            }

            private com.google.protobuf.Internal.FloatList floats_ = emptyFloatList();
            private void ensureFloatsIsMutable() {
                if (!((bitField0_ & 0x00000400) != 0)) {
                    floats_ = mutableCopy(floats_);
                    bitField0_ |= 0x00000400;
                }
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return A list containing the floats.
             */
            public java.util.List<java.lang.Float>
            getFloatsList() {
                return ((bitField0_ & 0x00000400) != 0) ?
                        java.util.Collections.unmodifiableList(floats_) : floats_;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return The count of floats.
             */
            public int getFloatsCount() {
                return floats_.size();
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param index The index of the element to return.
             * @return The floats at the given index.
             */
            public float getFloats(int index) {
                return floats_.getFloat(index);
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param index The index to set the value at.
             * @param value The floats to set.
             * @return This builder for chaining.
             */
            public Builder setFloats(
                    int index, float value) {
                ensureFloatsIsMutable();
                floats_.setFloat(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param value The floats to add.
             * @return This builder for chaining.
             */
            public Builder addFloats(float value) {
                ensureFloatsIsMutable();
                floats_.addFloat(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @param values The floats to add.
             * @return This builder for chaining.
             */
            public Builder addAllFloats(
                    java.lang.Iterable<? extends java.lang.Float> values) {
                ensureFloatsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, floats_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of floats
             * </pre>
             *
             * <code>repeated float floats = 7;</code>
             * @return This builder for chaining.
             */
            public Builder clearFloats() {
                floats_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000400);
                onChanged();
                return this;
            }

            private com.google.protobuf.Internal.LongList ints_ = emptyLongList();
            private void ensureIntsIsMutable() {
                if (!((bitField0_ & 0x00000800) != 0)) {
                    ints_ = mutableCopy(ints_);
                    bitField0_ |= 0x00000800;
                }
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return A list containing the ints.
             */
            public java.util.List<java.lang.Long>
            getIntsList() {
                return ((bitField0_ & 0x00000800) != 0) ?
                        java.util.Collections.unmodifiableList(ints_) : ints_;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return The count of ints.
             */
            public int getIntsCount() {
                return ints_.size();
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param index The index of the element to return.
             * @return The ints at the given index.
             */
            public long getInts(int index) {
                return ints_.getLong(index);
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param index The index to set the value at.
             * @param value The ints to set.
             * @return This builder for chaining.
             */
            public Builder setInts(
                    int index, long value) {
                ensureIntsIsMutable();
                ints_.setLong(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param value The ints to add.
             * @return This builder for chaining.
             */
            public Builder addInts(long value) {
                ensureIntsIsMutable();
                ints_.addLong(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @param values The ints to add.
             * @return This builder for chaining.
             */
            public Builder addAllInts(
                    java.lang.Iterable<? extends java.lang.Long> values) {
                ensureIntsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, ints_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of ints
             * </pre>
             *
             * <code>repeated int64 ints = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearInts() {
                ints_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000800);
                onChanged();
                return this;
            }

            private java.util.List<com.google.protobuf.ByteString> strings_ = java.util.Collections.emptyList();
            private void ensureStringsIsMutable() {
                if (!((bitField0_ & 0x00001000) != 0)) {
                    strings_ = new java.util.ArrayList<com.google.protobuf.ByteString>(strings_);
                    bitField0_ |= 0x00001000;
                }
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return A list containing the strings.
             */
            public java.util.List<com.google.protobuf.ByteString>
            getStringsList() {
                return ((bitField0_ & 0x00001000) != 0) ?
                        java.util.Collections.unmodifiableList(strings_) : strings_;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return The count of strings.
             */
            public int getStringsCount() {
                return strings_.size();
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param index The index of the element to return.
             * @return The strings at the given index.
             */
            public com.google.protobuf.ByteString getStrings(int index) {
                return strings_.get(index);
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param index The index to set the value at.
             * @param value The strings to set.
             * @return This builder for chaining.
             */
            public Builder setStrings(
                    int index, com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureStringsIsMutable();
                strings_.set(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param value The strings to add.
             * @return This builder for chaining.
             */
            public Builder addStrings(com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureStringsIsMutable();
                strings_.add(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @param values The strings to add.
             * @return This builder for chaining.
             */
            public Builder addAllStrings(
                    java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
                ensureStringsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, strings_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * list of UTF-8 strings
             * </pre>
             *
             * <code>repeated bytes strings = 9;</code>
             * @return This builder for chaining.
             */
            public Builder clearStrings() {
                strings_ = java.util.Collections.emptyList();
                bitField0_ = (bitField0_ & ~0x00001000);
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.TensorProto> tensors_ =
                    java.util.Collections.emptyList();
            private void ensureTensorsIsMutable() {
                if (!((bitField0_ & 0x00002000) != 0)) {
                    tensors_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorProto>(tensors_);
                    bitField0_ |= 0x00002000;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder> tensorsBuilder_;

            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorProto> getTensorsList() {
                if (tensorsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(tensors_);
                } else {
                    return tensorsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public int getTensorsCount() {
                if (tensorsBuilder_ == null) {
                    return tensors_.size();
                } else {
                    return tensorsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto getTensors(int index) {
                if (tensorsBuilder_ == null) {
                    return tensors_.get(index);
                } else {
                    return tensorsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder setTensors(
                    int index, ai.onnx.proto.OnnxMl.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.set(index, value);
                    onChanged();
                } else {
                    tensorsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder setTensors(
                    int index, ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.add(value);
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                    int index, ai.onnx.proto.OnnxMl.TensorProto value) {
                if (tensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTensorsIsMutable();
                    tensors_.add(index, value);
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                    ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.add(builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder addTensors(
                    int index, ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    tensorsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder addAllTensors(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.TensorProto> values) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, tensors_);
                    onChanged();
                } else {
                    tensorsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder clearTensors() {
                if (tensorsBuilder_ == null) {
                    tensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00002000);
                    onChanged();
                } else {
                    tensorsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public Builder removeTensors(int index) {
                if (tensorsBuilder_ == null) {
                    ensureTensorsIsMutable();
                    tensors_.remove(index);
                    onChanged();
                } else {
                    tensorsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder getTensorsBuilder(
                    int index) {
                return getTensorsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getTensorsOrBuilder(
                    int index) {
                if (tensorsBuilder_ == null) {
                    return tensors_.get(index);  } else {
                    return tensorsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getTensorsOrBuilderList() {
                if (tensorsBuilder_ != null) {
                    return tensorsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(tensors_);
                }
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder addTensorsBuilder() {
                return getTensorsFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder addTensorsBuilder(
                    int index) {
                return getTensorsFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of tensors
             * </pre>
             *
             * <code>repeated .onnx.TensorProto tensors = 10;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorProto.Builder>
            getTensorsBuilderList() {
                return getTensorsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getTensorsFieldBuilder() {
                if (tensorsBuilder_ == null) {
                    tensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>(
                            tensors_,
                            ((bitField0_ & 0x00002000) != 0),
                            getParentForChildren(),
                            isClean());
                    tensors_ = null;
                }
                return tensorsBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.GraphProto> graphs_ =
                    java.util.Collections.emptyList();
            private void ensureGraphsIsMutable() {
                if (!((bitField0_ & 0x00004000) != 0)) {
                    graphs_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.GraphProto>(graphs_);
                    bitField0_ |= 0x00004000;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder> graphsBuilder_;

            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.GraphProto> getGraphsList() {
                if (graphsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(graphs_);
                } else {
                    return graphsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public int getGraphsCount() {
                if (graphsBuilder_ == null) {
                    return graphs_.size();
                } else {
                    return graphsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto getGraphs(int index) {
                if (graphsBuilder_ == null) {
                    return graphs_.get(index);
                } else {
                    return graphsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder setGraphs(
                    int index, ai.onnx.proto.OnnxMl.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.set(index, value);
                    onChanged();
                } else {
                    graphsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder setGraphs(
                    int index, ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.add(value);
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                    int index, ai.onnx.proto.OnnxMl.GraphProto value) {
                if (graphsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureGraphsIsMutable();
                    graphs_.add(index, value);
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                    ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.add(builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder addGraphs(
                    int index, ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    graphsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder addAllGraphs(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.GraphProto> values) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, graphs_);
                    onChanged();
                } else {
                    graphsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder clearGraphs() {
                if (graphsBuilder_ == null) {
                    graphs_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00004000);
                    onChanged();
                } else {
                    graphsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public Builder removeGraphs(int index) {
                if (graphsBuilder_ == null) {
                    ensureGraphsIsMutable();
                    graphs_.remove(index);
                    onChanged();
                } else {
                    graphsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder getGraphsBuilder(
                    int index) {
                return getGraphsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphsOrBuilder(
                    int index) {
                if (graphsBuilder_ == null) {
                    return graphs_.get(index);  } else {
                    return graphsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getGraphsOrBuilderList() {
                if (graphsBuilder_ != null) {
                    return graphsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(graphs_);
                }
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder addGraphsBuilder() {
                return getGraphsFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder addGraphsBuilder(
                    int index) {
                return getGraphsFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of graph
             * </pre>
             *
             * <code>repeated .onnx.GraphProto graphs = 11;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.GraphProto.Builder>
            getGraphsBuilderList() {
                return getGraphsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getGraphsFieldBuilder() {
                if (graphsBuilder_ == null) {
                    graphsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>(
                            graphs_,
                            ((bitField0_ & 0x00004000) != 0),
                            getParentForChildren(),
                            isClean());
                    graphs_ = null;
                }
                return graphsBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> sparseTensors_ =
                    java.util.Collections.emptyList();
            private void ensureSparseTensorsIsMutable() {
                if (!((bitField0_ & 0x00008000) != 0)) {
                    sparseTensors_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.SparseTensorProto>(sparseTensors_);
                    bitField0_ |= 0x00008000;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder> sparseTensorsBuilder_;

            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> getSparseTensorsList() {
                if (sparseTensorsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(sparseTensors_);
                } else {
                    return sparseTensorsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public int getSparseTensorsCount() {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.size();
                } else {
                    return sparseTensorsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseTensors(int index) {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.get(index);
                } else {
                    return sparseTensorsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder setSparseTensors(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.set(index, value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder setSparseTensors(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseTensorsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(index, value);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                    ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addSparseTensors(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder addAllSparseTensors(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.SparseTensorProto> values) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, sparseTensors_);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder clearSparseTensors() {
                if (sparseTensorsBuilder_ == null) {
                    sparseTensors_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00008000);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public Builder removeSparseTensors(int index) {
                if (sparseTensorsBuilder_ == null) {
                    ensureSparseTensorsIsMutable();
                    sparseTensors_.remove(index);
                    onChanged();
                } else {
                    sparseTensorsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder getSparseTensorsBuilder(
                    int index) {
                return getSparseTensorsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
                    int index) {
                if (sparseTensorsBuilder_ == null) {
                    return sparseTensors_.get(index);  } else {
                    return sparseTensorsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
            getSparseTensorsOrBuilderList() {
                if (sparseTensorsBuilder_ != null) {
                    return sparseTensorsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(sparseTensors_);
                }
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder addSparseTensorsBuilder() {
                return getSparseTensorsFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder addSparseTensorsBuilder(
                    int index) {
                return getSparseTensorsFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * list of sparse tensors
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_tensors = 23;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto.Builder>
            getSparseTensorsBuilderList() {
                return getSparseTensorsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
            getSparseTensorsFieldBuilder() {
                if (sparseTensorsBuilder_ == null) {
                    sparseTensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>(
                            sparseTensors_,
                            ((bitField0_ & 0x00008000) != 0),
                            getParentForChildren(),
                            isClean());
                    sparseTensors_ = null;
                }
                return sparseTensorsBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.AttributeProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.AttributeProto)
        private static final ai.onnx.proto.OnnxMl.AttributeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.AttributeProto();
        }

        public static ai.onnx.proto.OnnxMl.AttributeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<AttributeProto>
                PARSER = new com.google.protobuf.AbstractParser<AttributeProto>() {
            @java.lang.Override
            public AttributeProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new AttributeProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<AttributeProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<AttributeProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.AttributeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface ValueInfoProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.ValueInfoProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();

        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         * @return Whether the type field is set.
         */
        boolean hasType();
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         * @return The type.
         */
        ai.onnx.proto.OnnxMl.TypeProto getType();
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder();

        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
    }
    /**
     * <pre>
     * Defines information on value, including the name, the type, and
     * the shape of the value.
     * </pre>
     *
     * Protobuf type {@code onnx.ValueInfoProto}
     */
    public static final class ValueInfoProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.ValueInfoProto)
            ValueInfoProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use ValueInfoProto.newBuilder() to construct.
        private ValueInfoProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private ValueInfoProto() {
            name_ = "";
            docString_ = "";
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new ValueInfoProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private ValueInfoProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            name_ = bs;
                            break;
                        }
                        case 18: {
                            ai.onnx.proto.OnnxMl.TypeProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000002) != 0)) {
                                subBuilder = type_.toBuilder();
                            }
                            type_ = input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(type_);
                                type_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000002;
                            break;
                        }
                        case 26: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000004;
                            docString_ = bs;
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_ValueInfoProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.ValueInfoProto.class, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder.class);
        }

        private int bitField0_;
        public static final int NAME_FIELD_NUMBER = 1;
        private volatile java.lang.Object name_;
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional string name = 1;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int TYPE_FIELD_NUMBER = 2;
        private ai.onnx.proto.OnnxMl.TypeProto type_;
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         * @return Whether the type field is set.
         */
        @java.lang.Override
        public boolean hasType() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         * @return The type.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto getType() {
            return type_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : type_;
        }
        /**
         * <pre>
         * This field MUST be present in this version of the IR for
         * inputs and outputs of the top-level graph.
         * </pre>
         *
         * <code>optional .onnx.TypeProto type = 2;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder() {
            return type_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : type_;
        }

        public static final int DOC_STRING_FIELD_NUMBER = 3;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this value. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 3;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getType());
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 3, docString_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getType());
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, docString_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.ValueInfoProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.ValueInfoProto other = (ai.onnx.proto.OnnxMl.ValueInfoProto) obj;

            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (hasType() != other.hasType()) return false;
            if (hasType()) {
                if (!getType()
                        .equals(other.getType())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasType()) {
                hash = (37 * hash) + TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getType().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ValueInfoProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.ValueInfoProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Defines information on value, including the name, the type, and
         * the shape of the value.
         * </pre>
         *
         * Protobuf type {@code onnx.ValueInfoProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.ValueInfoProto)
                ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ValueInfoProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.ValueInfoProto.class, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.ValueInfoProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getTypeFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                name_ = "";
                bitField0_ = (bitField0_ & ~0x00000001);
                if (typeBuilder_ == null) {
                    type_ = null;
                } else {
                    typeBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000004);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ValueInfoProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ValueInfoProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ValueInfoProto build() {
                ai.onnx.proto.OnnxMl.ValueInfoProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ValueInfoProto buildPartial() {
                ai.onnx.proto.OnnxMl.ValueInfoProto result = new ai.onnx.proto.OnnxMl.ValueInfoProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.name_ = name_;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    if (typeBuilder_ == null) {
                        result.type_ = type_;
                    } else {
                        result.type_ = typeBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000002;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    to_bitField0_ |= 0x00000004;
                }
                result.docString_ = docString_;
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.ValueInfoProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.ValueInfoProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.ValueInfoProto other) {
                if (other == ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance()) return this;
                if (other.hasName()) {
                    bitField0_ |= 0x00000001;
                    name_ = other.name_;
                    onChanged();
                }
                if (other.hasType()) {
                    mergeType(other.getType());
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000004;
                    docString_ = other.docString_;
                    onChanged();
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.ValueInfoProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.ValueInfoProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.lang.Object name_ = "";
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                name_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                bitField0_ = (bitField0_ & ~0x00000001);
                name_ = getDefaultInstance().getName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional string name = 1;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                name_ = value;
                onChanged();
                return this;
            }

            private ai.onnx.proto.OnnxMl.TypeProto type_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder> typeBuilder_;
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             * @return Whether the type field is set.
             */
            public boolean hasType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             * @return The type.
             */
            public ai.onnx.proto.OnnxMl.TypeProto getType() {
                if (typeBuilder_ == null) {
                    return type_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : type_;
                } else {
                    return typeBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public Builder setType(ai.onnx.proto.OnnxMl.TypeProto value) {
                if (typeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    type_ = value;
                    onChanged();
                } else {
                    typeBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public Builder setType(
                    ai.onnx.proto.OnnxMl.TypeProto.Builder builderForValue) {
                if (typeBuilder_ == null) {
                    type_ = builderForValue.build();
                    onChanged();
                } else {
                    typeBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public Builder mergeType(ai.onnx.proto.OnnxMl.TypeProto value) {
                if (typeBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                            type_ != null &&
                            type_ != ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance()) {
                        type_ =
                                ai.onnx.proto.OnnxMl.TypeProto.newBuilder(type_).mergeFrom(value).buildPartial();
                    } else {
                        type_ = value;
                    }
                    onChanged();
                } else {
                    typeBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public Builder clearType() {
                if (typeBuilder_ == null) {
                    type_ = null;
                    onChanged();
                } else {
                    typeBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.Builder getTypeBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return getTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getTypeOrBuilder() {
                if (typeBuilder_ != null) {
                    return typeBuilder_.getMessageOrBuilder();
                } else {
                    return type_ == null ?
                            ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : type_;
                }
            }
            /**
             * <pre>
             * This field MUST be present in this version of the IR for
             * inputs and outputs of the top-level graph.
             * </pre>
             *
             * <code>optional .onnx.TypeProto type = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>
            getTypeFieldBuilder() {
                if (typeBuilder_ == null) {
                    typeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>(
                            getType(),
                            getParentForChildren(),
                            isClean());
                    type_ = null;
                }
                return typeBuilder_;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000004);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this value. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 3;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                docString_ = value;
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.ValueInfoProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.ValueInfoProto)
        private static final ai.onnx.proto.OnnxMl.ValueInfoProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.ValueInfoProto();
        }

        public static ai.onnx.proto.OnnxMl.ValueInfoProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<ValueInfoProto>
                PARSER = new com.google.protobuf.AbstractParser<ValueInfoProto>() {
            @java.lang.Override
            public ValueInfoProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new ValueInfoProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<ValueInfoProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<ValueInfoProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface NodeProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.NodeProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return A list containing the input.
         */
        java.util.List<java.lang.String>
        getInputList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return The count of input.
         */
        int getInputCount();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        java.lang.String getInput(int index);
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        com.google.protobuf.ByteString
        getInputBytes(int index);

        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return A list containing the output.
         */
        java.util.List<java.lang.String>
        getOutputList();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return The count of output.
         */
        int getOutputCount();
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        java.lang.String getOutput(int index);
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        com.google.protobuf.ByteString
        getOutputBytes(int index);

        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();

        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return Whether the opType field is set.
         */
        boolean hasOpType();
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The opType.
         */
        java.lang.String getOpType();
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The bytes for opType.
         */
        com.google.protobuf.ByteString
        getOpTypeBytes();

        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();

        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.AttributeProto>
        getAttributeList();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        ai.onnx.proto.OnnxMl.AttributeProto getAttribute(int index);
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        int getAttributeCount();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder>
        getAttributeOrBuilderList();
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(
                int index);

        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();
    }
    /**
     * <pre>
     * Nodes
     * Computation graphs are made up of a DAG of nodes, which represent what is
     * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
     * For example, it can be a node of type "Conv" that takes in an image, a filter
     * tensor and a bias tensor, and produces the convolved output.
     * </pre>
     *
     * Protobuf type {@code onnx.NodeProto}
     */
    public static final class NodeProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.NodeProto)
            NodeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use NodeProto.newBuilder() to construct.
        private NodeProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private NodeProto() {
            input_ = com.google.protobuf.LazyStringArrayList.EMPTY;
            output_ = com.google.protobuf.LazyStringArrayList.EMPTY;
            name_ = "";
            opType_ = "";
            domain_ = "";
            attribute_ = java.util.Collections.emptyList();
            docString_ = "";
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new NodeProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private NodeProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                                input_ = new com.google.protobuf.LazyStringArrayList();
                                mutable_bitField0_ |= 0x00000001;
                            }
                            input_.add(bs);
                            break;
                        }
                        case 18: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                                output_ = new com.google.protobuf.LazyStringArrayList();
                                mutable_bitField0_ |= 0x00000002;
                            }
                            output_.add(bs);
                            break;
                        }
                        case 26: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            name_ = bs;
                            break;
                        }
                        case 34: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000002;
                            opType_ = bs;
                            break;
                        }
                        case 42: {
                            if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                                attribute_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.AttributeProto>();
                                mutable_bitField0_ |= 0x00000020;
                            }
                            attribute_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.AttributeProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 50: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000008;
                            docString_ = bs;
                            break;
                        }
                        case 58: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000004;
                            domain_ = bs;
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000001) != 0)) {
                    input_ = input_.getUnmodifiableView();
                }
                if (((mutable_bitField0_ & 0x00000002) != 0)) {
                    output_ = output_.getUnmodifiableView();
                }
                if (((mutable_bitField0_ & 0x00000020) != 0)) {
                    attribute_ = java.util.Collections.unmodifiableList(attribute_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_NodeProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_NodeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.NodeProto.class, ai.onnx.proto.OnnxMl.NodeProto.Builder.class);
        }

        private int bitField0_;
        public static final int INPUT_FIELD_NUMBER = 1;
        private com.google.protobuf.LazyStringList input_;
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return A list containing the input.
         */
        public com.google.protobuf.ProtocolStringList
        getInputList() {
            return input_;
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @return The count of input.
         */
        public int getInputCount() {
            return input_.size();
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the element to return.
         * @return The input at the given index.
         */
        public java.lang.String getInput(int index) {
            return input_.get(index);
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string input = 1;</code>
         * @param index The index of the value to return.
         * @return The bytes of the input at the given index.
         */
        public com.google.protobuf.ByteString
        getInputBytes(int index) {
            return input_.getByteString(index);
        }

        public static final int OUTPUT_FIELD_NUMBER = 2;
        private com.google.protobuf.LazyStringList output_;
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return A list containing the output.
         */
        public com.google.protobuf.ProtocolStringList
        getOutputList() {
            return output_;
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @return The count of output.
         */
        public int getOutputCount() {
            return output_.size();
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the element to return.
         * @return The output at the given index.
         */
        public java.lang.String getOutput(int index) {
            return output_.get(index);
        }
        /**
         * <pre>
         * namespace Value
         * </pre>
         *
         * <code>repeated string output = 2;</code>
         * @param index The index of the value to return.
         * @return The bytes of the output at the given index.
         */
        public com.google.protobuf.ByteString
        getOutputBytes(int index) {
            return output_.getByteString(index);
        }

        public static final int NAME_FIELD_NUMBER = 3;
        private volatile java.lang.Object name_;
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * An optional identifier for this node in a graph.
         * This field MAY be absent in ths version of the IR.
         * </pre>
         *
         * <code>optional string name = 3;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int OP_TYPE_FIELD_NUMBER = 4;
        private volatile java.lang.Object opType_;
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return Whether the opType field is set.
         */
        @java.lang.Override
        public boolean hasOpType() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The opType.
         */
        @java.lang.Override
        public java.lang.String getOpType() {
            java.lang.Object ref = opType_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    opType_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The symbolic identifier of the Operator to execute.
         * </pre>
         *
         * <code>optional string op_type = 4;</code>
         * @return The bytes for opType.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getOpTypeBytes() {
            java.lang.Object ref = opType_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                opType_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int DOMAIN_FIELD_NUMBER = 7;
        private volatile java.lang.Object domain_;
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The domain of the OperatorSet that specifies the operator named by op_type.
         * </pre>
         *
         * <code>optional string domain = 7;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int ATTRIBUTE_FIELD_NUMBER = 5;
        private java.util.List<ai.onnx.proto.OnnxMl.AttributeProto> attribute_;
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.AttributeProto> getAttributeList() {
            return attribute_;
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder>
        getAttributeOrBuilderList() {
            return attribute_;
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public int getAttributeCount() {
            return attribute_.size();
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.AttributeProto getAttribute(int index) {
            return attribute_.get(index);
        }
        /**
         * <pre>
         * Additional named attributes.
         * </pre>
         *
         * <code>repeated .onnx.AttributeProto attribute = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(
                int index) {
            return attribute_.get(index);
        }

        public static final int DOC_STRING_FIELD_NUMBER = 6;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this node. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            for (int i = 0; i < input_.size(); i++) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, input_.getRaw(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, output_.getRaw(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 3, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 4, opType_);
            }
            for (int i = 0; i < attribute_.size(); i++) {
                output.writeMessage(5, attribute_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 6, docString_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 7, domain_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            {
                int dataSize = 0;
                for (int i = 0; i < input_.size(); i++) {
                    dataSize += computeStringSizeNoTag(input_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getInputList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < output_.size(); i++) {
                    dataSize += computeStringSizeNoTag(output_.getRaw(i));
                }
                size += dataSize;
                size += 1 * getOutputList().size();
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, name_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, opType_);
            }
            for (int i = 0; i < attribute_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(5, attribute_.get(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, docString_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, domain_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.NodeProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.NodeProto other = (ai.onnx.proto.OnnxMl.NodeProto) obj;

            if (!getInputList()
                    .equals(other.getInputList())) return false;
            if (!getOutputList()
                    .equals(other.getOutputList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (hasOpType() != other.hasOpType()) return false;
            if (hasOpType()) {
                if (!getOpType()
                        .equals(other.getOpType())) return false;
            }
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                        .equals(other.getDomain())) return false;
            }
            if (!getAttributeList()
                    .equals(other.getAttributeList())) return false;
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getInputCount() > 0) {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (getOutputCount() > 0) {
                hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
                hash = (53 * hash) + getOutputList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasOpType()) {
                hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getOpType().hashCode();
            }
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (getAttributeCount() > 0) {
                hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;
                hash = (53 * hash) + getAttributeList().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.NodeProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.NodeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Nodes
         * Computation graphs are made up of a DAG of nodes, which represent what is
         * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
         * For example, it can be a node of type "Conv" that takes in an image, a filter
         * tensor and a bias tensor, and produces the convolved output.
         * </pre>
         *
         * Protobuf type {@code onnx.NodeProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.NodeProto)
                ai.onnx.proto.OnnxMl.NodeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_NodeProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_NodeProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.NodeProto.class, ai.onnx.proto.OnnxMl.NodeProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.NodeProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getAttributeFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                input_ = com.google.protobuf.LazyStringArrayList.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000001);
                output_ = com.google.protobuf.LazyStringArrayList.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000002);
                name_ = "";
                bitField0_ = (bitField0_ & ~0x00000004);
                opType_ = "";
                bitField0_ = (bitField0_ & ~0x00000008);
                domain_ = "";
                bitField0_ = (bitField0_ & ~0x00000010);
                if (attributeBuilder_ == null) {
                    attribute_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                } else {
                    attributeBuilder_.clear();
                }
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000040);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_NodeProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.NodeProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.NodeProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.NodeProto build() {
                ai.onnx.proto.OnnxMl.NodeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.NodeProto buildPartial() {
                ai.onnx.proto.OnnxMl.NodeProto result = new ai.onnx.proto.OnnxMl.NodeProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    input_ = input_.getUnmodifiableView();
                    bitField0_ = (bitField0_ & ~0x00000001);
                }
                result.input_ = input_;
                if (((bitField0_ & 0x00000002) != 0)) {
                    output_ = output_.getUnmodifiableView();
                    bitField0_ = (bitField0_ & ~0x00000002);
                }
                result.output_ = output_;
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.name_ = name_;
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    to_bitField0_ |= 0x00000002;
                }
                result.opType_ = opType_;
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    to_bitField0_ |= 0x00000004;
                }
                result.domain_ = domain_;
                if (attributeBuilder_ == null) {
                    if (((bitField0_ & 0x00000020) != 0)) {
                        attribute_ = java.util.Collections.unmodifiableList(attribute_);
                        bitField0_ = (bitField0_ & ~0x00000020);
                    }
                    result.attribute_ = attribute_;
                } else {
                    result.attribute_ = attributeBuilder_.build();
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    to_bitField0_ |= 0x00000008;
                }
                result.docString_ = docString_;
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.NodeProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.NodeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.NodeProto other) {
                if (other == ai.onnx.proto.OnnxMl.NodeProto.getDefaultInstance()) return this;
                if (!other.input_.isEmpty()) {
                    if (input_.isEmpty()) {
                        input_ = other.input_;
                        bitField0_ = (bitField0_ & ~0x00000001);
                    } else {
                        ensureInputIsMutable();
                        input_.addAll(other.input_);
                    }
                    onChanged();
                }
                if (!other.output_.isEmpty()) {
                    if (output_.isEmpty()) {
                        output_ = other.output_;
                        bitField0_ = (bitField0_ & ~0x00000002);
                    } else {
                        ensureOutputIsMutable();
                        output_.addAll(other.output_);
                    }
                    onChanged();
                }
                if (other.hasName()) {
                    bitField0_ |= 0x00000004;
                    name_ = other.name_;
                    onChanged();
                }
                if (other.hasOpType()) {
                    bitField0_ |= 0x00000008;
                    opType_ = other.opType_;
                    onChanged();
                }
                if (other.hasDomain()) {
                    bitField0_ |= 0x00000010;
                    domain_ = other.domain_;
                    onChanged();
                }
                if (attributeBuilder_ == null) {
                    if (!other.attribute_.isEmpty()) {
                        if (attribute_.isEmpty()) {
                            attribute_ = other.attribute_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                        } else {
                            ensureAttributeIsMutable();
                            attribute_.addAll(other.attribute_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.attribute_.isEmpty()) {
                        if (attributeBuilder_.isEmpty()) {
                            attributeBuilder_.dispose();
                            attributeBuilder_ = null;
                            attribute_ = other.attribute_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                            attributeBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getAttributeFieldBuilder() : null;
                        } else {
                            attributeBuilder_.addAllMessages(other.attribute_);
                        }
                    }
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000040;
                    docString_ = other.docString_;
                    onChanged();
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.NodeProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.NodeProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private com.google.protobuf.LazyStringList input_ = com.google.protobuf.LazyStringArrayList.EMPTY;
            private void ensureInputIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    input_ = new com.google.protobuf.LazyStringArrayList(input_);
                    bitField0_ |= 0x00000001;
                }
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return A list containing the input.
             */
            public com.google.protobuf.ProtocolStringList
            getInputList() {
                return input_.getUnmodifiableView();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return The count of input.
             */
            public int getInputCount() {
                return input_.size();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index of the element to return.
             * @return The input at the given index.
             */
            public java.lang.String getInput(int index) {
                return input_.get(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index of the value to return.
             * @return The bytes of the input at the given index.
             */
            public com.google.protobuf.ByteString
            getInputBytes(int index) {
                return input_.getByteString(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param index The index to set the value at.
             * @param value The input to set.
             * @return This builder for chaining.
             */
            public Builder setInput(
                    int index, java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.set(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param value The input to add.
             * @return This builder for chaining.
             */
            public Builder addInput(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.add(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param values The input to add.
             * @return This builder for chaining.
             */
            public Builder addAllInput(
                    java.lang.Iterable<java.lang.String> values) {
                ensureInputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, input_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearInput() {
                input_ = com.google.protobuf.LazyStringArrayList.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string input = 1;</code>
             * @param value The bytes of the input to add.
             * @return This builder for chaining.
             */
            public Builder addInputBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureInputIsMutable();
                input_.add(value);
                onChanged();
                return this;
            }

            private com.google.protobuf.LazyStringList output_ = com.google.protobuf.LazyStringArrayList.EMPTY;
            private void ensureOutputIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    output_ = new com.google.protobuf.LazyStringArrayList(output_);
                    bitField0_ |= 0x00000002;
                }
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return A list containing the output.
             */
            public com.google.protobuf.ProtocolStringList
            getOutputList() {
                return output_.getUnmodifiableView();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return The count of output.
             */
            public int getOutputCount() {
                return output_.size();
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index of the element to return.
             * @return The output at the given index.
             */
            public java.lang.String getOutput(int index) {
                return output_.get(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index of the value to return.
             * @return The bytes of the output at the given index.
             */
            public com.google.protobuf.ByteString
            getOutputBytes(int index) {
                return output_.getByteString(index);
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param index The index to set the value at.
             * @param value The output to set.
             * @return This builder for chaining.
             */
            public Builder setOutput(
                    int index, java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureOutputIsMutable();
                output_.set(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param value The output to add.
             * @return This builder for chaining.
             */
            public Builder addOutput(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureOutputIsMutable();
                output_.add(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param values The output to add.
             * @return This builder for chaining.
             */
            public Builder addAllOutput(
                    java.lang.Iterable<java.lang.String> values) {
                ensureOutputIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, output_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearOutput() {
                output_ = com.google.protobuf.LazyStringArrayList.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000002);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * namespace Value
             * </pre>
             *
             * <code>repeated string output = 2;</code>
             * @param value The bytes of the output to add.
             * @return This builder for chaining.
             */
            public Builder addOutputBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureOutputIsMutable();
                output_.add(value);
                onChanged();
                return this;
            }

            private java.lang.Object name_ = "";
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                name_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                bitField0_ = (bitField0_ & ~0x00000004);
                name_ = getDefaultInstance().getName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional identifier for this node in a graph.
             * This field MAY be absent in ths version of the IR.
             * </pre>
             *
             * <code>optional string name = 3;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                name_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object opType_ = "";
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return Whether the opType field is set.
             */
            public boolean hasOpType() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return The opType.
             */
            public java.lang.String getOpType() {
                java.lang.Object ref = opType_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        opType_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return The bytes for opType.
             */
            public com.google.protobuf.ByteString
            getOpTypeBytes() {
                java.lang.Object ref = opType_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    opType_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @param value The opType to set.
             * @return This builder for chaining.
             */
            public Builder setOpType(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                opType_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearOpType() {
                bitField0_ = (bitField0_ & ~0x00000008);
                opType_ = getDefaultInstance().getOpType();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The symbolic identifier of the Operator to execute.
             * </pre>
             *
             * <code>optional string op_type = 4;</code>
             * @param value The bytes for opType to set.
             * @return This builder for chaining.
             */
            public Builder setOpTypeBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                opType_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                domain_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                bitField0_ = (bitField0_ & ~0x00000010);
                domain_ = getDefaultInstance().getDomain();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the OperatorSet that specifies the operator named by op_type.
             * </pre>
             *
             * <code>optional string domain = 7;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                domain_ = value;
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.AttributeProto> attribute_ =
                    java.util.Collections.emptyList();
            private void ensureAttributeIsMutable() {
                if (!((bitField0_ & 0x00000020) != 0)) {
                    attribute_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.AttributeProto>(attribute_);
                    bitField0_ |= 0x00000020;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.AttributeProto, ai.onnx.proto.OnnxMl.AttributeProto.Builder, ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder> attributeBuilder_;

            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.AttributeProto> getAttributeList() {
                if (attributeBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(attribute_);
                } else {
                    return attributeBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public int getAttributeCount() {
                if (attributeBuilder_ == null) {
                    return attribute_.size();
                } else {
                    return attributeBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.AttributeProto getAttribute(int index) {
                if (attributeBuilder_ == null) {
                    return attribute_.get(index);
                } else {
                    return attributeBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder setAttribute(
                    int index, ai.onnx.proto.OnnxMl.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.set(index, value);
                    onChanged();
                } else {
                    attributeBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder setAttribute(
                    int index, ai.onnx.proto.OnnxMl.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(ai.onnx.proto.OnnxMl.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.add(value);
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                    int index, ai.onnx.proto.OnnxMl.AttributeProto value) {
                if (attributeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureAttributeIsMutable();
                    attribute_.add(index, value);
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                    ai.onnx.proto.OnnxMl.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.add(builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAttribute(
                    int index, ai.onnx.proto.OnnxMl.AttributeProto.Builder builderForValue) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    attributeBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder addAllAttribute(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.AttributeProto> values) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, attribute_);
                    onChanged();
                } else {
                    attributeBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder clearAttribute() {
                if (attributeBuilder_ == null) {
                    attribute_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                    onChanged();
                } else {
                    attributeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public Builder removeAttribute(int index) {
                if (attributeBuilder_ == null) {
                    ensureAttributeIsMutable();
                    attribute_.remove(index);
                    onChanged();
                } else {
                    attributeBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.AttributeProto.Builder getAttributeBuilder(
                    int index) {
                return getAttributeFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder getAttributeOrBuilder(
                    int index) {
                if (attributeBuilder_ == null) {
                    return attribute_.get(index);  } else {
                    return attributeBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder>
            getAttributeOrBuilderList() {
                if (attributeBuilder_ != null) {
                    return attributeBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(attribute_);
                }
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.AttributeProto.Builder addAttributeBuilder() {
                return getAttributeFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.AttributeProto.Builder addAttributeBuilder(
                    int index) {
                return getAttributeFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.AttributeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Additional named attributes.
             * </pre>
             *
             * <code>repeated .onnx.AttributeProto attribute = 5;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.AttributeProto.Builder>
            getAttributeBuilderList() {
                return getAttributeFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.AttributeProto, ai.onnx.proto.OnnxMl.AttributeProto.Builder, ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder>
            getAttributeFieldBuilder() {
                if (attributeBuilder_ == null) {
                    attributeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.AttributeProto, ai.onnx.proto.OnnxMl.AttributeProto.Builder, ai.onnx.proto.OnnxMl.AttributeProtoOrBuilder>(
                            attribute_,
                            ((bitField0_ & 0x00000020) != 0),
                            getParentForChildren(),
                            isClean());
                    attribute_ = null;
                }
                return attributeBuilder_;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000040;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000040);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this node. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000040;
                docString_ = value;
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.NodeProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.NodeProto)
        private static final ai.onnx.proto.OnnxMl.NodeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.NodeProto();
        }

        public static ai.onnx.proto.OnnxMl.NodeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<NodeProto>
                PARSER = new com.google.protobuf.AbstractParser<NodeProto>() {
            @java.lang.Override
            public NodeProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new NodeProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<NodeProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<NodeProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.NodeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface TrainingInfoProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.TrainingInfoProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         * @return Whether the initialization field is set.
         */
        boolean hasInitialization();
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         * @return The initialization.
         */
        ai.onnx.proto.OnnxMl.GraphProto getInitialization();
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder();

        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         * @return Whether the algorithm field is set.
         */
        boolean hasAlgorithm();
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         * @return The algorithm.
         */
        ai.onnx.proto.OnnxMl.GraphProto getAlgorithm();
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder();

        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto>
        getInitializationBindingList();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProto getInitializationBinding(int index);
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        int getInitializationBindingCount();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getInitializationBindingOrBuilderList();
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
                int index);

        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto>
        getUpdateBindingList();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProto getUpdateBinding(int index);
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        int getUpdateBindingCount();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getUpdateBindingOrBuilderList();
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
                int index);
    }
    /**
     * <pre>
     * Training information
     * TrainingInfoProto stores information for training a model.
     * In particular, this defines two functionalities: an initialization-step
     * and a training-algorithm-step. Initialization resets the model
     * back to its original state as if no training has been performed.
     * Training algorithm improves the model based on input data.
     * The semantics of the initialization-step is that the initializers
     * in ModelProto.graph and in TrainingInfoProto.algorithm are first
     * initialized as specified by the initializers in the graph, and then
     * updated by the "initialization_binding" in every instance in
     * ModelProto.training_info.
     * The field "algorithm" defines a computation graph which represents a
     * training algorithm's step. After the execution of a
     * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
     * may be immediately updated. If the targeted training algorithm contains
     * consecutive update steps (such as block coordinate descent methods),
     * the user needs to create a TrainingInfoProto for each step.
     * </pre>
     *
     * Protobuf type {@code onnx.TrainingInfoProto}
     */
    public static final class TrainingInfoProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.TrainingInfoProto)
            TrainingInfoProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use TrainingInfoProto.newBuilder() to construct.
        private TrainingInfoProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private TrainingInfoProto() {
            initializationBinding_ = java.util.Collections.emptyList();
            updateBinding_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new TrainingInfoProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private TrainingInfoProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            ai.onnx.proto.OnnxMl.GraphProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000001) != 0)) {
                                subBuilder = initialization_.toBuilder();
                            }
                            initialization_ = input.readMessage(ai.onnx.proto.OnnxMl.GraphProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(initialization_);
                                initialization_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000001;
                            break;
                        }
                        case 18: {
                            ai.onnx.proto.OnnxMl.GraphProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000002) != 0)) {
                                subBuilder = algorithm_.toBuilder();
                            }
                            algorithm_ = input.readMessage(ai.onnx.proto.OnnxMl.GraphProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(algorithm_);
                                algorithm_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000002;
                            break;
                        }
                        case 26: {
                            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                                initializationBinding_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>();
                                mutable_bitField0_ |= 0x00000004;
                            }
                            initializationBinding_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.StringStringEntryProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 34: {
                            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                                updateBinding_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>();
                                mutable_bitField0_ |= 0x00000008;
                            }
                            updateBinding_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.StringStringEntryProto.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000004) != 0)) {
                    initializationBinding_ = java.util.Collections.unmodifiableList(initializationBinding_);
                }
                if (((mutable_bitField0_ & 0x00000008) != 0)) {
                    updateBinding_ = java.util.Collections.unmodifiableList(updateBinding_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.TrainingInfoProto.class, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder.class);
        }

        private int bitField0_;
        public static final int INITIALIZATION_FIELD_NUMBER = 1;
        private ai.onnx.proto.OnnxMl.GraphProto initialization_;
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         * @return Whether the initialization field is set.
         */
        @java.lang.Override
        public boolean hasInitialization() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         * @return The initialization.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getInitialization() {
            return initialization_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : initialization_;
        }
        /**
         * <pre>
         * This field describes a graph to compute the initial tensors
         * upon starting the training process. Initialization graph has no input
         * and can have multiple outputs. Usually, trainable tensors in neural
         * networks are randomly initialized. To achieve that, for each tensor,
         * the user can put a random number operator such as RandomNormal or
         * RandomUniform in TrainingInfoProto.initialization.node and assign its
         * random output to the specific tensor using "initialization_binding".
         * This graph can also set the initializers in "algorithm" in the same
         * TrainingInfoProto; a use case is resetting the number of training
         * iteration to zero.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Thus, no initializer would be changed by default.
         * </pre>
         *
         * <code>optional .onnx.GraphProto initialization = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder() {
            return initialization_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : initialization_;
        }

        public static final int ALGORITHM_FIELD_NUMBER = 2;
        private ai.onnx.proto.OnnxMl.GraphProto algorithm_;
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         * @return Whether the algorithm field is set.
         */
        @java.lang.Override
        public boolean hasAlgorithm() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         * @return The algorithm.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getAlgorithm() {
            return algorithm_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;
        }
        /**
         * <pre>
         * This field represents a training algorithm step. Given required inputs,
         * it computes outputs to update initializers in its own or inference graph's
         * initializer lists. In general, this field contains loss node, gradient node,
         * optimizer node, increment of iteration count.
         * An execution of the training algorithm step is performed by executing the
         * graph obtained by combining the inference graph (namely "ModelProto.graph")
         * and the "algorithm" graph. That is, the actual the actual
         * input/initializer/output/node/value_info/sparse_initializer list of
         * the training graph is the concatenation of
         * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
         * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
         * in that order. This combined graph must satisfy the normal ONNX conditions.
         * Now, let's provide a visualization of graph combination for clarity.
         * Let the inference graph (i.e., "ModelProto.graph") be
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
         * and the "algorithm" graph be
         *    tensor_d -&gt; Add -&gt; tensor_e
         * The combination process results
         *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
         * Notice that an input of a node in the "algorithm" graph may reference the
         * output of a node in the inference graph (but not the other way round). Also, inference
         * node cannot reference inputs of "algorithm". With these restrictions, inference graph
         * can always be run independently without training information.
         * By default, this field is an empty graph and its evaluation does not
         * produce any output. Evaluating the default training step never
         * update any initializers.
         * </pre>
         *
         * <code>optional .onnx.GraphProto algorithm = 2;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder() {
            return algorithm_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;
        }

        public static final int INITIALIZATION_BINDING_FIELD_NUMBER = 3;
        private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> initializationBinding_;
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getInitializationBindingList() {
            return initializationBinding_;
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getInitializationBindingOrBuilderList() {
            return initializationBinding_;
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public int getInitializationBindingCount() {
            return initializationBinding_.size();
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getInitializationBinding(int index) {
            return initializationBinding_.get(index);
        }
        /**
         * <pre>
         * This field specifies the bindings from the outputs of "initialization" to
         * some initializers in "ModelProto.graph.initializer" and
         * the "algorithm.initializer" in the same TrainingInfoProto.
         * See "update_binding" below for details.
         * By default, this field is empty and no initializer would be changed
         * by the execution of "initialization".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
                int index) {
            return initializationBinding_.get(index);
        }

        public static final int UPDATE_BINDING_FIELD_NUMBER = 4;
        private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> updateBinding_;
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getUpdateBindingList() {
            return updateBinding_;
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getUpdateBindingOrBuilderList() {
            return updateBinding_;
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public int getUpdateBindingCount() {
            return updateBinding_.size();
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getUpdateBinding(int index) {
            return updateBinding_.get(index);
        }
        /**
         * <pre>
         * Gradient-based training is usually an iterative procedure. In one gradient
         * descent iteration, we apply
         * x = x - r * g
         * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
         * gradient of "x" with respect to a chosen loss. To avoid adding assignments
         * into the training graph, we split the update equation into
         * y = x - r * g
         * x = y
         * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
         * tell that "y" should be assigned to "x", the field "update_binding" may
         * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
         * and "y" (value of StringStringEntryProto).
         * For a neural network with multiple trainable (mutable) tensors, there can
         * be multiple key-value pairs in "update_binding".
         * The initializers appears as keys in "update_binding" are considered
         * mutable variables. This implies some behaviors
         * as described below.
         *  1. We have only unique keys in all "update_binding"s so that two
         *     variables may not have the same name. This ensures that one
         *     variable is assigned up to once.
         *  2. The keys must appear in names of "ModelProto.graph.initializer" or
         *     "TrainingInfoProto.algorithm.initializer".
         *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
         *  4. Mutable variables are initialized to the value specified by the
         *     corresponding initializer, and then potentially updated by
         *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
         * This field usually contains names of trainable tensors
         * (in ModelProto.graph), optimizer states such as momentums in advanced
         * stochastic gradient methods (in TrainingInfoProto.graph),
         * and number of training iterations (in TrainingInfoProto.graph).
         * By default, this field is empty and no initializer would be changed
         * by the execution of "algorithm".
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
                int index) {
            return updateBinding_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeMessage(1, getInitialization());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getAlgorithm());
            }
            for (int i = 0; i < initializationBinding_.size(); i++) {
                output.writeMessage(3, initializationBinding_.get(i));
            }
            for (int i = 0; i < updateBinding_.size(); i++) {
                output.writeMessage(4, updateBinding_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, getInitialization());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getAlgorithm());
            }
            for (int i = 0; i < initializationBinding_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(3, initializationBinding_.get(i));
            }
            for (int i = 0; i < updateBinding_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(4, updateBinding_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.TrainingInfoProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.TrainingInfoProto other = (ai.onnx.proto.OnnxMl.TrainingInfoProto) obj;

            if (hasInitialization() != other.hasInitialization()) return false;
            if (hasInitialization()) {
                if (!getInitialization()
                        .equals(other.getInitialization())) return false;
            }
            if (hasAlgorithm() != other.hasAlgorithm()) return false;
            if (hasAlgorithm()) {
                if (!getAlgorithm()
                        .equals(other.getAlgorithm())) return false;
            }
            if (!getInitializationBindingList()
                    .equals(other.getInitializationBindingList())) return false;
            if (!getUpdateBindingList()
                    .equals(other.getUpdateBindingList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasInitialization()) {
                hash = (37 * hash) + INITIALIZATION_FIELD_NUMBER;
                hash = (53 * hash) + getInitialization().hashCode();
            }
            if (hasAlgorithm()) {
                hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
                hash = (53 * hash) + getAlgorithm().hashCode();
            }
            if (getInitializationBindingCount() > 0) {
                hash = (37 * hash) + INITIALIZATION_BINDING_FIELD_NUMBER;
                hash = (53 * hash) + getInitializationBindingList().hashCode();
            }
            if (getUpdateBindingCount() > 0) {
                hash = (37 * hash) + UPDATE_BINDING_FIELD_NUMBER;
                hash = (53 * hash) + getUpdateBindingList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TrainingInfoProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.TrainingInfoProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Training information
         * TrainingInfoProto stores information for training a model.
         * In particular, this defines two functionalities: an initialization-step
         * and a training-algorithm-step. Initialization resets the model
         * back to its original state as if no training has been performed.
         * Training algorithm improves the model based on input data.
         * The semantics of the initialization-step is that the initializers
         * in ModelProto.graph and in TrainingInfoProto.algorithm are first
         * initialized as specified by the initializers in the graph, and then
         * updated by the "initialization_binding" in every instance in
         * ModelProto.training_info.
         * The field "algorithm" defines a computation graph which represents a
         * training algorithm's step. After the execution of a
         * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
         * may be immediately updated. If the targeted training algorithm contains
         * consecutive update steps (such as block coordinate descent methods),
         * the user needs to create a TrainingInfoProto for each step.
         * </pre>
         *
         * Protobuf type {@code onnx.TrainingInfoProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.TrainingInfoProto)
                ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TrainingInfoProto.class, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.TrainingInfoProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getInitializationFieldBuilder();
                    getAlgorithmFieldBuilder();
                    getInitializationBindingFieldBuilder();
                    getUpdateBindingFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                if (initializationBuilder_ == null) {
                    initialization_ = null;
                } else {
                    initializationBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                if (algorithmBuilder_ == null) {
                    algorithm_ = null;
                } else {
                    algorithmBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                if (initializationBindingBuilder_ == null) {
                    initializationBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                } else {
                    initializationBindingBuilder_.clear();
                }
                if (updateBindingBuilder_ == null) {
                    updateBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                } else {
                    updateBindingBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TrainingInfoProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TrainingInfoProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.TrainingInfoProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TrainingInfoProto build() {
                ai.onnx.proto.OnnxMl.TrainingInfoProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TrainingInfoProto buildPartial() {
                ai.onnx.proto.OnnxMl.TrainingInfoProto result = new ai.onnx.proto.OnnxMl.TrainingInfoProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    if (initializationBuilder_ == null) {
                        result.initialization_ = initialization_;
                    } else {
                        result.initialization_ = initializationBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    if (algorithmBuilder_ == null) {
                        result.algorithm_ = algorithm_;
                    } else {
                        result.algorithm_ = algorithmBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000002;
                }
                if (initializationBindingBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0)) {
                        initializationBinding_ = java.util.Collections.unmodifiableList(initializationBinding_);
                        bitField0_ = (bitField0_ & ~0x00000004);
                    }
                    result.initializationBinding_ = initializationBinding_;
                } else {
                    result.initializationBinding_ = initializationBindingBuilder_.build();
                }
                if (updateBindingBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        updateBinding_ = java.util.Collections.unmodifiableList(updateBinding_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.updateBinding_ = updateBinding_;
                } else {
                    result.updateBinding_ = updateBindingBuilder_.build();
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.TrainingInfoProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.TrainingInfoProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.TrainingInfoProto other) {
                if (other == ai.onnx.proto.OnnxMl.TrainingInfoProto.getDefaultInstance()) return this;
                if (other.hasInitialization()) {
                    mergeInitialization(other.getInitialization());
                }
                if (other.hasAlgorithm()) {
                    mergeAlgorithm(other.getAlgorithm());
                }
                if (initializationBindingBuilder_ == null) {
                    if (!other.initializationBinding_.isEmpty()) {
                        if (initializationBinding_.isEmpty()) {
                            initializationBinding_ = other.initializationBinding_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                        } else {
                            ensureInitializationBindingIsMutable();
                            initializationBinding_.addAll(other.initializationBinding_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.initializationBinding_.isEmpty()) {
                        if (initializationBindingBuilder_.isEmpty()) {
                            initializationBindingBuilder_.dispose();
                            initializationBindingBuilder_ = null;
                            initializationBinding_ = other.initializationBinding_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                            initializationBindingBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getInitializationBindingFieldBuilder() : null;
                        } else {
                            initializationBindingBuilder_.addAllMessages(other.initializationBinding_);
                        }
                    }
                }
                if (updateBindingBuilder_ == null) {
                    if (!other.updateBinding_.isEmpty()) {
                        if (updateBinding_.isEmpty()) {
                            updateBinding_ = other.updateBinding_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureUpdateBindingIsMutable();
                            updateBinding_.addAll(other.updateBinding_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.updateBinding_.isEmpty()) {
                        if (updateBindingBuilder_.isEmpty()) {
                            updateBindingBuilder_.dispose();
                            updateBindingBuilder_ = null;
                            updateBinding_ = other.updateBinding_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            updateBindingBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getUpdateBindingFieldBuilder() : null;
                        } else {
                            updateBindingBuilder_.addAllMessages(other.updateBinding_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.TrainingInfoProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.TrainingInfoProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private ai.onnx.proto.OnnxMl.GraphProto initialization_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder> initializationBuilder_;
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             * @return Whether the initialization field is set.
             */
            public boolean hasInitialization() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             * @return The initialization.
             */
            public ai.onnx.proto.OnnxMl.GraphProto getInitialization() {
                if (initializationBuilder_ == null) {
                    return initialization_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : initialization_;
                } else {
                    return initializationBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public Builder setInitialization(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (initializationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    initialization_ = value;
                    onChanged();
                } else {
                    initializationBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public Builder setInitialization(
                    ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (initializationBuilder_ == null) {
                    initialization_ = builderForValue.build();
                    onChanged();
                } else {
                    initializationBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public Builder mergeInitialization(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (initializationBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0) &&
                            initialization_ != null &&
                            initialization_ != ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance()) {
                        initialization_ =
                                ai.onnx.proto.OnnxMl.GraphProto.newBuilder(initialization_).mergeFrom(value).buildPartial();
                    } else {
                        initialization_ = value;
                    }
                    onChanged();
                } else {
                    initializationBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public Builder clearInitialization() {
                if (initializationBuilder_ == null) {
                    initialization_ = null;
                    onChanged();
                } else {
                    initializationBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                return this;
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder getInitializationBuilder() {
                bitField0_ |= 0x00000001;
                onChanged();
                return getInitializationFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getInitializationOrBuilder() {
                if (initializationBuilder_ != null) {
                    return initializationBuilder_.getMessageOrBuilder();
                } else {
                    return initialization_ == null ?
                            ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : initialization_;
                }
            }
            /**
             * <pre>
             * This field describes a graph to compute the initial tensors
             * upon starting the training process. Initialization graph has no input
             * and can have multiple outputs. Usually, trainable tensors in neural
             * networks are randomly initialized. To achieve that, for each tensor,
             * the user can put a random number operator such as RandomNormal or
             * RandomUniform in TrainingInfoProto.initialization.node and assign its
             * random output to the specific tensor using "initialization_binding".
             * This graph can also set the initializers in "algorithm" in the same
             * TrainingInfoProto; a use case is resetting the number of training
             * iteration to zero.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Thus, no initializer would be changed by default.
             * </pre>
             *
             * <code>optional .onnx.GraphProto initialization = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getInitializationFieldBuilder() {
                if (initializationBuilder_ == null) {
                    initializationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>(
                            getInitialization(),
                            getParentForChildren(),
                            isClean());
                    initialization_ = null;
                }
                return initializationBuilder_;
            }

            private ai.onnx.proto.OnnxMl.GraphProto algorithm_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder> algorithmBuilder_;
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             * @return Whether the algorithm field is set.
             */
            public boolean hasAlgorithm() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             * @return The algorithm.
             */
            public ai.onnx.proto.OnnxMl.GraphProto getAlgorithm() {
                if (algorithmBuilder_ == null) {
                    return algorithm_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;
                } else {
                    return algorithmBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public Builder setAlgorithm(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (algorithmBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    algorithm_ = value;
                    onChanged();
                } else {
                    algorithmBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public Builder setAlgorithm(
                    ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (algorithmBuilder_ == null) {
                    algorithm_ = builderForValue.build();
                    onChanged();
                } else {
                    algorithmBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public Builder mergeAlgorithm(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (algorithmBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                            algorithm_ != null &&
                            algorithm_ != ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance()) {
                        algorithm_ =
                                ai.onnx.proto.OnnxMl.GraphProto.newBuilder(algorithm_).mergeFrom(value).buildPartial();
                    } else {
                        algorithm_ = value;
                    }
                    onChanged();
                } else {
                    algorithmBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public Builder clearAlgorithm() {
                if (algorithmBuilder_ == null) {
                    algorithm_ = null;
                    onChanged();
                } else {
                    algorithmBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder getAlgorithmBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return getAlgorithmFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getAlgorithmOrBuilder() {
                if (algorithmBuilder_ != null) {
                    return algorithmBuilder_.getMessageOrBuilder();
                } else {
                    return algorithm_ == null ?
                            ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : algorithm_;
                }
            }
            /**
             * <pre>
             * This field represents a training algorithm step. Given required inputs,
             * it computes outputs to update initializers in its own or inference graph's
             * initializer lists. In general, this field contains loss node, gradient node,
             * optimizer node, increment of iteration count.
             * An execution of the training algorithm step is performed by executing the
             * graph obtained by combining the inference graph (namely "ModelProto.graph")
             * and the "algorithm" graph. That is, the actual the actual
             * input/initializer/output/node/value_info/sparse_initializer list of
             * the training graph is the concatenation of
             * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
             * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
             * in that order. This combined graph must satisfy the normal ONNX conditions.
             * Now, let's provide a visualization of graph combination for clarity.
             * Let the inference graph (i.e., "ModelProto.graph") be
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
             * and the "algorithm" graph be
             *    tensor_d -&gt; Add -&gt; tensor_e
             * The combination process results
             *    tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
             * Notice that an input of a node in the "algorithm" graph may reference the
             * output of a node in the inference graph (but not the other way round). Also, inference
             * node cannot reference inputs of "algorithm". With these restrictions, inference graph
             * can always be run independently without training information.
             * By default, this field is an empty graph and its evaluation does not
             * produce any output. Evaluating the default training step never
             * update any initializers.
             * </pre>
             *
             * <code>optional .onnx.GraphProto algorithm = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getAlgorithmFieldBuilder() {
                if (algorithmBuilder_ == null) {
                    algorithmBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>(
                            getAlgorithm(),
                            getParentForChildren(),
                            isClean());
                    algorithm_ = null;
                }
                return algorithmBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> initializationBinding_ =
                    java.util.Collections.emptyList();
            private void ensureInitializationBindingIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    initializationBinding_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>(initializationBinding_);
                    bitField0_ |= 0x00000004;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder> initializationBindingBuilder_;

            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getInitializationBindingList() {
                if (initializationBindingBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(initializationBinding_);
                } else {
                    return initializationBindingBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public int getInitializationBindingCount() {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.size();
                } else {
                    return initializationBindingBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getInitializationBinding(int index) {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.get(index);
                } else {
                    return initializationBindingBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder setInitializationBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.set(index, value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder setInitializationBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (initializationBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(index, value);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                    ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addInitializationBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    initializationBindingBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder addAllInitializationBinding(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.StringStringEntryProto> values) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, initializationBinding_);
                    onChanged();
                } else {
                    initializationBindingBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder clearInitializationBinding() {
                if (initializationBindingBuilder_ == null) {
                    initializationBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                } else {
                    initializationBindingBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public Builder removeInitializationBinding(int index) {
                if (initializationBindingBuilder_ == null) {
                    ensureInitializationBindingIsMutable();
                    initializationBinding_.remove(index);
                    onChanged();
                } else {
                    initializationBindingBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder getInitializationBindingBuilder(
                    int index) {
                return getInitializationBindingFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
                    int index) {
                if (initializationBindingBuilder_ == null) {
                    return initializationBinding_.get(index);  } else {
                    return initializationBindingBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getInitializationBindingOrBuilderList() {
                if (initializationBindingBuilder_ != null) {
                    return initializationBindingBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(initializationBinding_);
                }
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addInitializationBindingBuilder() {
                return getInitializationBindingFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addInitializationBindingBuilder(
                    int index) {
                return getInitializationBindingFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * This field specifies the bindings from the outputs of "initialization" to
             * some initializers in "ModelProto.graph.initializer" and
             * the "algorithm.initializer" in the same TrainingInfoProto.
             * See "update_binding" below for details.
             * By default, this field is empty and no initializer would be changed
             * by the execution of "initialization".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto initialization_binding = 3;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder>
            getInitializationBindingBuilderList() {
                return getInitializationBindingFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getInitializationBindingFieldBuilder() {
                if (initializationBindingBuilder_ == null) {
                    initializationBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>(
                            initializationBinding_,
                            ((bitField0_ & 0x00000004) != 0),
                            getParentForChildren(),
                            isClean());
                    initializationBinding_ = null;
                }
                return initializationBindingBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> updateBinding_ =
                    java.util.Collections.emptyList();
            private void ensureUpdateBindingIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    updateBinding_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>(updateBinding_);
                    bitField0_ |= 0x00000008;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder> updateBindingBuilder_;

            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getUpdateBindingList() {
                if (updateBindingBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(updateBinding_);
                } else {
                    return updateBindingBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public int getUpdateBindingCount() {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.size();
                } else {
                    return updateBindingBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getUpdateBinding(int index) {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.get(index);
                } else {
                    return updateBindingBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder setUpdateBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.set(index, value);
                    onChanged();
                } else {
                    updateBindingBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder setUpdateBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(value);
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (updateBindingBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(index, value);
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                    ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addUpdateBinding(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    updateBindingBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder addAllUpdateBinding(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.StringStringEntryProto> values) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, updateBinding_);
                    onChanged();
                } else {
                    updateBindingBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder clearUpdateBinding() {
                if (updateBindingBuilder_ == null) {
                    updateBinding_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    updateBindingBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public Builder removeUpdateBinding(int index) {
                if (updateBindingBuilder_ == null) {
                    ensureUpdateBindingIsMutable();
                    updateBinding_.remove(index);
                    onChanged();
                } else {
                    updateBindingBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder getUpdateBindingBuilder(
                    int index) {
                return getUpdateBindingFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
                    int index) {
                if (updateBindingBuilder_ == null) {
                    return updateBinding_.get(index);  } else {
                    return updateBindingBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getUpdateBindingOrBuilderList() {
                if (updateBindingBuilder_ != null) {
                    return updateBindingBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(updateBinding_);
                }
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addUpdateBindingBuilder() {
                return getUpdateBindingFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addUpdateBindingBuilder(
                    int index) {
                return getUpdateBindingFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Gradient-based training is usually an iterative procedure. In one gradient
             * descent iteration, we apply
             * x = x - r * g
             * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
             * gradient of "x" with respect to a chosen loss. To avoid adding assignments
             * into the training graph, we split the update equation into
             * y = x - r * g
             * x = y
             * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
             * tell that "y" should be assigned to "x", the field "update_binding" may
             * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
             * and "y" (value of StringStringEntryProto).
             * For a neural network with multiple trainable (mutable) tensors, there can
             * be multiple key-value pairs in "update_binding".
             * The initializers appears as keys in "update_binding" are considered
             * mutable variables. This implies some behaviors
             * as described below.
             *  1. We have only unique keys in all "update_binding"s so that two
             *     variables may not have the same name. This ensures that one
             *     variable is assigned up to once.
             *  2. The keys must appear in names of "ModelProto.graph.initializer" or
             *     "TrainingInfoProto.algorithm.initializer".
             *  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
             *  4. Mutable variables are initialized to the value specified by the
             *     corresponding initializer, and then potentially updated by
             *     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
             * This field usually contains names of trainable tensors
             * (in ModelProto.graph), optimizer states such as momentums in advanced
             * stochastic gradient methods (in TrainingInfoProto.graph),
             * and number of training iterations (in TrainingInfoProto.graph).
             * By default, this field is empty and no initializer would be changed
             * by the execution of "algorithm".
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto update_binding = 4;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder>
            getUpdateBindingBuilderList() {
                return getUpdateBindingFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getUpdateBindingFieldBuilder() {
                if (updateBindingBuilder_ == null) {
                    updateBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>(
                            updateBinding_,
                            ((bitField0_ & 0x00000008) != 0),
                            getParentForChildren(),
                            isClean());
                    updateBinding_ = null;
                }
                return updateBindingBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.TrainingInfoProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.TrainingInfoProto)
        private static final ai.onnx.proto.OnnxMl.TrainingInfoProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TrainingInfoProto();
        }

        public static ai.onnx.proto.OnnxMl.TrainingInfoProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<TrainingInfoProto>
                PARSER = new com.google.protobuf.AbstractParser<TrainingInfoProto>() {
            @java.lang.Override
            public TrainingInfoProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new TrainingInfoProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<TrainingInfoProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<TrainingInfoProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TrainingInfoProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface ModelProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.ModelProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return Whether the irVersion field is set.
         */
        boolean hasIrVersion();
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return The irVersion.
         */
        long getIrVersion();

        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto>
        getOpsetImportList();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        ai.onnx.proto.OnnxMl.OperatorSetIdProto getOpsetImport(int index);
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        int getOpsetImportCount();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList();
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
                int index);

        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return Whether the producerName field is set.
         */
        boolean hasProducerName();
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The producerName.
         */
        java.lang.String getProducerName();
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The bytes for producerName.
         */
        com.google.protobuf.ByteString
        getProducerNameBytes();

        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return Whether the producerVersion field is set.
         */
        boolean hasProducerVersion();
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The producerVersion.
         */
        java.lang.String getProducerVersion();
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The bytes for producerVersion.
         */
        com.google.protobuf.ByteString
        getProducerVersionBytes();

        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();

        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return Whether the modelVersion field is set.
         */
        boolean hasModelVersion();
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return The modelVersion.
         */
        long getModelVersion();

        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();

        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         * @return Whether the graph field is set.
         */
        boolean hasGraph();
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         * @return The graph.
         */
        ai.onnx.proto.OnnxMl.GraphProto getGraph();
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         */
        ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder();

        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto>
        getMetadataPropsList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProto getMetadataProps(int index);
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        int getMetadataPropsCount();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList();
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index);

        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto>
        getTrainingInfoList();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        ai.onnx.proto.OnnxMl.TrainingInfoProto getTrainingInfo(int index);
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        int getTrainingInfoCount();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder>
        getTrainingInfoOrBuilderList();
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
                int index);
    }
    /**
     * <pre>
     * Models
     * ModelProto is a top-level file/container format for bundling a ML model and
     * associating its computation graph with metadata.
     * The semantics of the model are described by the associated GraphProto's.
     * </pre>
     *
     * Protobuf type {@code onnx.ModelProto}
     */
    public static final class ModelProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.ModelProto)
            ModelProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use ModelProto.newBuilder() to construct.
        private ModelProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private ModelProto() {
            opsetImport_ = java.util.Collections.emptyList();
            producerName_ = "";
            producerVersion_ = "";
            domain_ = "";
            docString_ = "";
            metadataProps_ = java.util.Collections.emptyList();
            trainingInfo_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new ModelProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private ModelProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 8: {
                            bitField0_ |= 0x00000001;
                            irVersion_ = input.readInt64();
                            break;
                        }
                        case 18: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000002;
                            producerName_ = bs;
                            break;
                        }
                        case 26: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000004;
                            producerVersion_ = bs;
                            break;
                        }
                        case 34: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000008;
                            domain_ = bs;
                            break;
                        }
                        case 40: {
                            bitField0_ |= 0x00000010;
                            modelVersion_ = input.readInt64();
                            break;
                        }
                        case 50: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000020;
                            docString_ = bs;
                            break;
                        }
                        case 58: {
                            ai.onnx.proto.OnnxMl.GraphProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000040) != 0)) {
                                subBuilder = graph_.toBuilder();
                            }
                            graph_ = input.readMessage(ai.onnx.proto.OnnxMl.GraphProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(graph_);
                                graph_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000040;
                            break;
                        }
                        case 66: {
                            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                                opsetImport_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.OperatorSetIdProto>();
                                mutable_bitField0_ |= 0x00000002;
                            }
                            opsetImport_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.OperatorSetIdProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 114: {
                            if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                                metadataProps_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>();
                                mutable_bitField0_ |= 0x00000100;
                            }
                            metadataProps_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.StringStringEntryProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 162: {
                            if (!((mutable_bitField0_ & 0x00000200) != 0)) {
                                trainingInfo_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TrainingInfoProto>();
                                mutable_bitField0_ |= 0x00000200;
                            }
                            trainingInfo_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.TrainingInfoProto.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000002) != 0)) {
                    opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
                }
                if (((mutable_bitField0_ & 0x00000100) != 0)) {
                    metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                }
                if (((mutable_bitField0_ & 0x00000200) != 0)) {
                    trainingInfo_ = java.util.Collections.unmodifiableList(trainingInfo_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_ModelProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_ModelProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.ModelProto.class, ai.onnx.proto.OnnxMl.ModelProto.Builder.class);
        }

        private int bitField0_;
        public static final int IR_VERSION_FIELD_NUMBER = 1;
        private long irVersion_;
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return Whether the irVersion field is set.
         */
        @java.lang.Override
        public boolean hasIrVersion() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The version of the IR this model targets. See Version enum above.
         * This field MUST be present.
         * </pre>
         *
         * <code>optional int64 ir_version = 1;</code>
         * @return The irVersion.
         */
        @java.lang.Override
        public long getIrVersion() {
            return irVersion_;
        }

        public static final int OPSET_IMPORT_FIELD_NUMBER = 8;
        private java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto> opsetImport_;
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto> getOpsetImportList() {
            return opsetImport_;
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder>
        getOpsetImportOrBuilderList() {
            return opsetImport_;
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public int getOpsetImportCount() {
            return opsetImport_.size();
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {
            return opsetImport_.get(index);
        }
        /**
         * <pre>
         * The OperatorSets this model relies on.
         * All ModelProtos MUST have at least one entry that
         * specifies which version of the ONNX OperatorSet is
         * being imported.
         * All nodes in the ModelProto's graph will bind against the operator
         * with the same-domain/same-op_type operator with the HIGHEST version
         * in the referenced operator sets.
         * </pre>
         *
         * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
                int index) {
            return opsetImport_.get(index);
        }

        public static final int PRODUCER_NAME_FIELD_NUMBER = 2;
        private volatile java.lang.Object producerName_;
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return Whether the producerName field is set.
         */
        @java.lang.Override
        public boolean hasProducerName() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The producerName.
         */
        @java.lang.Override
        public java.lang.String getProducerName() {
            java.lang.Object ref = producerName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    producerName_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_name = 2;</code>
         * @return The bytes for producerName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getProducerNameBytes() {
            java.lang.Object ref = producerName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                producerName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int PRODUCER_VERSION_FIELD_NUMBER = 3;
        private volatile java.lang.Object producerVersion_;
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return Whether the producerVersion field is set.
         */
        @java.lang.Override
        public boolean hasProducerVersion() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The producerVersion.
         */
        @java.lang.Override
        public java.lang.String getProducerVersion() {
            java.lang.Object ref = producerVersion_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    producerVersion_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The version of the framework or tool used to generate this model.
         * This field SHOULD be present to indicate which implementation/tool/framework
         * emitted the model.
         * </pre>
         *
         * <code>optional string producer_version = 3;</code>
         * @return The bytes for producerVersion.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getProducerVersionBytes() {
            java.lang.Object ref = producerVersion_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                producerVersion_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int DOMAIN_FIELD_NUMBER = 4;
        private volatile java.lang.Object domain_;
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * Domain name of the model.
         * We use reverse domain names as name space indicators. For example:
         * `com.facebook.fair` or `com.microsoft.cognitiveservices`
         * Together with `model_version` and GraphProto.name, this forms the unique identity of
         * the graph.
         * </pre>
         *
         * <code>optional string domain = 4;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int MODEL_VERSION_FIELD_NUMBER = 5;
        private long modelVersion_;
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return Whether the modelVersion field is set.
         */
        @java.lang.Override
        public boolean hasModelVersion() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * The version of the graph encoded. See Version enum below.
         * </pre>
         *
         * <code>optional int64 model_version = 5;</code>
         * @return The modelVersion.
         */
        @java.lang.Override
        public long getModelVersion() {
            return modelVersion_;
        }

        public static final int DOC_STRING_FIELD_NUMBER = 6;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this model. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 6;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int GRAPH_FIELD_NUMBER = 7;
        private ai.onnx.proto.OnnxMl.GraphProto graph_;
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         * @return Whether the graph field is set.
         */
        @java.lang.Override
        public boolean hasGraph() {
            return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         * @return The graph.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getGraph() {
            return graph_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : graph_;
        }
        /**
         * <pre>
         * The parameterized graph that is evaluated to execute the model.
         * </pre>
         *
         * <code>optional .onnx.GraphProto graph = 7;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder() {
            return graph_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : graph_;
        }

        public static final int METADATA_PROPS_FIELD_NUMBER = 14;
        private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> metadataProps_;
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getMetadataPropsList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getMetadataPropsOrBuilderList() {
            return metadataProps_;
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public int getMetadataPropsCount() {
            return metadataProps_.size();
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getMetadataProps(int index) {
            return metadataProps_.get(index);
        }
        /**
         * <pre>
         * Named metadata values; keys should be distinct.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                int index) {
            return metadataProps_.get(index);
        }

        public static final int TRAINING_INFO_FIELD_NUMBER = 20;
        private java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto> trainingInfo_;
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto> getTrainingInfoList() {
            return trainingInfo_;
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder>
        getTrainingInfoOrBuilderList() {
            return trainingInfo_;
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public int getTrainingInfoCount() {
            return trainingInfo_.size();
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TrainingInfoProto getTrainingInfo(int index) {
            return trainingInfo_.get(index);
        }
        /**
         * <pre>
         * Training-specific information. Sequentially executing all stored
         * `TrainingInfoProto.algorithm`s and assigning their outputs following
         * the corresponding `TrainingInfoProto.update_binding`s is one training
         * iteration. Similarly, to initialize the model
         * (as if training hasn't happened), the user should sequentially execute
         * all stored `TrainingInfoProto.initialization`s and assigns their outputs
         * using `TrainingInfoProto.initialization_binding`s.
         * If this field is empty, the training behavior of the model is undefined.
         * </pre>
         *
         * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
                int index) {
            return trainingInfo_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt64(1, irVersion_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, producerName_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 3, producerVersion_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 4, domain_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeInt64(5, modelVersion_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 6, docString_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                output.writeMessage(7, getGraph());
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                output.writeMessage(8, opsetImport_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                output.writeMessage(14, metadataProps_.get(i));
            }
            for (int i = 0; i < trainingInfo_.size(); i++) {
                output.writeMessage(20, trainingInfo_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(1, irVersion_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, producerName_);
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, producerVersion_);
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, domain_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(5, modelVersion_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, docString_);
            }
            if (((bitField0_ & 0x00000040) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(7, getGraph());
            }
            for (int i = 0; i < opsetImport_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(8, opsetImport_.get(i));
            }
            for (int i = 0; i < metadataProps_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(14, metadataProps_.get(i));
            }
            for (int i = 0; i < trainingInfo_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(20, trainingInfo_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.ModelProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.ModelProto other = (ai.onnx.proto.OnnxMl.ModelProto) obj;

            if (hasIrVersion() != other.hasIrVersion()) return false;
            if (hasIrVersion()) {
                if (getIrVersion()
                        != other.getIrVersion()) return false;
            }
            if (!getOpsetImportList()
                    .equals(other.getOpsetImportList())) return false;
            if (hasProducerName() != other.hasProducerName()) return false;
            if (hasProducerName()) {
                if (!getProducerName()
                        .equals(other.getProducerName())) return false;
            }
            if (hasProducerVersion() != other.hasProducerVersion()) return false;
            if (hasProducerVersion()) {
                if (!getProducerVersion()
                        .equals(other.getProducerVersion())) return false;
            }
            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                        .equals(other.getDomain())) return false;
            }
            if (hasModelVersion() != other.hasModelVersion()) return false;
            if (hasModelVersion()) {
                if (getModelVersion()
                        != other.getModelVersion()) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (hasGraph() != other.hasGraph()) return false;
            if (hasGraph()) {
                if (!getGraph()
                        .equals(other.getGraph())) return false;
            }
            if (!getMetadataPropsList()
                    .equals(other.getMetadataPropsList())) return false;
            if (!getTrainingInfoList()
                    .equals(other.getTrainingInfoList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasIrVersion()) {
                hash = (37 * hash) + IR_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getIrVersion());
            }
            if (getOpsetImportCount() > 0) {
                hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;
                hash = (53 * hash) + getOpsetImportList().hashCode();
            }
            if (hasProducerName()) {
                hash = (37 * hash) + PRODUCER_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getProducerName().hashCode();
            }
            if (hasProducerVersion()) {
                hash = (37 * hash) + PRODUCER_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + getProducerVersion().hashCode();
            }
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasModelVersion()) {
                hash = (37 * hash) + MODEL_VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getModelVersion());
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasGraph()) {
                hash = (37 * hash) + GRAPH_FIELD_NUMBER;
                hash = (53 * hash) + getGraph().hashCode();
            }
            if (getMetadataPropsCount() > 0) {
                hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
                hash = (53 * hash) + getMetadataPropsList().hashCode();
            }
            if (getTrainingInfoCount() > 0) {
                hash = (37 * hash) + TRAINING_INFO_FIELD_NUMBER;
                hash = (53 * hash) + getTrainingInfoList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.ModelProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.ModelProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Models
         * ModelProto is a top-level file/container format for bundling a ML model and
         * associating its computation graph with metadata.
         * The semantics of the model are described by the associated GraphProto's.
         * </pre>
         *
         * Protobuf type {@code onnx.ModelProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.ModelProto)
                ai.onnx.proto.OnnxMl.ModelProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ModelProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ModelProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.ModelProto.class, ai.onnx.proto.OnnxMl.ModelProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.ModelProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getOpsetImportFieldBuilder();
                    getGraphFieldBuilder();
                    getMetadataPropsFieldBuilder();
                    getTrainingInfoFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                irVersion_ = 0L;
                bitField0_ = (bitField0_ & ~0x00000001);
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                } else {
                    opsetImportBuilder_.clear();
                }
                producerName_ = "";
                bitField0_ = (bitField0_ & ~0x00000004);
                producerVersion_ = "";
                bitField0_ = (bitField0_ & ~0x00000008);
                domain_ = "";
                bitField0_ = (bitField0_ & ~0x00000010);
                modelVersion_ = 0L;
                bitField0_ = (bitField0_ & ~0x00000020);
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000040);
                if (graphBuilder_ == null) {
                    graph_ = null;
                } else {
                    graphBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                } else {
                    metadataPropsBuilder_.clear();
                }
                if (trainingInfoBuilder_ == null) {
                    trainingInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000200);
                } else {
                    trainingInfoBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_ModelProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ModelProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.ModelProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ModelProto build() {
                ai.onnx.proto.OnnxMl.ModelProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.ModelProto buildPartial() {
                ai.onnx.proto.OnnxMl.ModelProto result = new ai.onnx.proto.OnnxMl.ModelProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    result.irVersion_ = irVersion_;
                    to_bitField0_ |= 0x00000001;
                }
                if (opsetImportBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.opsetImport_ = opsetImport_;
                } else {
                    result.opsetImport_ = opsetImportBuilder_.build();
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    to_bitField0_ |= 0x00000002;
                }
                result.producerName_ = producerName_;
                if (((from_bitField0_ & 0x00000008) != 0)) {
                    to_bitField0_ |= 0x00000004;
                }
                result.producerVersion_ = producerVersion_;
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    to_bitField0_ |= 0x00000008;
                }
                result.domain_ = domain_;
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    result.modelVersion_ = modelVersion_;
                    to_bitField0_ |= 0x00000010;
                }
                if (((from_bitField0_ & 0x00000040) != 0)) {
                    to_bitField0_ |= 0x00000020;
                }
                result.docString_ = docString_;
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    if (graphBuilder_ == null) {
                        result.graph_ = graph_;
                    } else {
                        result.graph_ = graphBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000040;
                }
                if (metadataPropsBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0)) {
                        metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
                        bitField0_ = (bitField0_ & ~0x00000100);
                    }
                    result.metadataProps_ = metadataProps_;
                } else {
                    result.metadataProps_ = metadataPropsBuilder_.build();
                }
                if (trainingInfoBuilder_ == null) {
                    if (((bitField0_ & 0x00000200) != 0)) {
                        trainingInfo_ = java.util.Collections.unmodifiableList(trainingInfo_);
                        bitField0_ = (bitField0_ & ~0x00000200);
                    }
                    result.trainingInfo_ = trainingInfo_;
                } else {
                    result.trainingInfo_ = trainingInfoBuilder_.build();
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.ModelProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.ModelProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.ModelProto other) {
                if (other == ai.onnx.proto.OnnxMl.ModelProto.getDefaultInstance()) return this;
                if (other.hasIrVersion()) {
                    setIrVersion(other.getIrVersion());
                }
                if (opsetImportBuilder_ == null) {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImport_.isEmpty()) {
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureOpsetImportIsMutable();
                            opsetImport_.addAll(other.opsetImport_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.opsetImport_.isEmpty()) {
                        if (opsetImportBuilder_.isEmpty()) {
                            opsetImportBuilder_.dispose();
                            opsetImportBuilder_ = null;
                            opsetImport_ = other.opsetImport_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            opsetImportBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getOpsetImportFieldBuilder() : null;
                        } else {
                            opsetImportBuilder_.addAllMessages(other.opsetImport_);
                        }
                    }
                }
                if (other.hasProducerName()) {
                    bitField0_ |= 0x00000004;
                    producerName_ = other.producerName_;
                    onChanged();
                }
                if (other.hasProducerVersion()) {
                    bitField0_ |= 0x00000008;
                    producerVersion_ = other.producerVersion_;
                    onChanged();
                }
                if (other.hasDomain()) {
                    bitField0_ |= 0x00000010;
                    domain_ = other.domain_;
                    onChanged();
                }
                if (other.hasModelVersion()) {
                    setModelVersion(other.getModelVersion());
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000040;
                    docString_ = other.docString_;
                    onChanged();
                }
                if (other.hasGraph()) {
                    mergeGraph(other.getGraph());
                }
                if (metadataPropsBuilder_ == null) {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataProps_.isEmpty()) {
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                        } else {
                            ensureMetadataPropsIsMutable();
                            metadataProps_.addAll(other.metadataProps_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.metadataProps_.isEmpty()) {
                        if (metadataPropsBuilder_.isEmpty()) {
                            metadataPropsBuilder_.dispose();
                            metadataPropsBuilder_ = null;
                            metadataProps_ = other.metadataProps_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                            metadataPropsBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getMetadataPropsFieldBuilder() : null;
                        } else {
                            metadataPropsBuilder_.addAllMessages(other.metadataProps_);
                        }
                    }
                }
                if (trainingInfoBuilder_ == null) {
                    if (!other.trainingInfo_.isEmpty()) {
                        if (trainingInfo_.isEmpty()) {
                            trainingInfo_ = other.trainingInfo_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                        } else {
                            ensureTrainingInfoIsMutable();
                            trainingInfo_.addAll(other.trainingInfo_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.trainingInfo_.isEmpty()) {
                        if (trainingInfoBuilder_.isEmpty()) {
                            trainingInfoBuilder_.dispose();
                            trainingInfoBuilder_ = null;
                            trainingInfo_ = other.trainingInfo_;
                            bitField0_ = (bitField0_ & ~0x00000200);
                            trainingInfoBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getTrainingInfoFieldBuilder() : null;
                        } else {
                            trainingInfoBuilder_.addAllMessages(other.trainingInfo_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.ModelProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.ModelProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private long irVersion_ ;
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return Whether the irVersion field is set.
             */
            @java.lang.Override
            public boolean hasIrVersion() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return The irVersion.
             */
            @java.lang.Override
            public long getIrVersion() {
                return irVersion_;
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @param value The irVersion to set.
             * @return This builder for chaining.
             */
            public Builder setIrVersion(long value) {
                bitField0_ |= 0x00000001;
                irVersion_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the IR this model targets. See Version enum above.
             * This field MUST be present.
             * </pre>
             *
             * <code>optional int64 ir_version = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearIrVersion() {
                bitField0_ = (bitField0_ & ~0x00000001);
                irVersion_ = 0L;
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto> opsetImport_ =
                    java.util.Collections.emptyList();
            private void ensureOpsetImportIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    opsetImport_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.OperatorSetIdProto>(opsetImport_);
                    bitField0_ |= 0x00000002;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.OperatorSetIdProto, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder, ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;

            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto> getOpsetImportList() {
                if (opsetImportBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                } else {
                    return opsetImportBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public int getOpsetImportCount() {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.size();
                } else {
                    return opsetImportBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto getOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);
                } else {
                    return opsetImportBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder setOpsetImport(
                    int index, ai.onnx.proto.OnnxMl.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder setOpsetImport(
                    int index, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(ai.onnx.proto.OnnxMl.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                    int index, ai.onnx.proto.OnnxMl.OperatorSetIdProto value) {
                if (opsetImportBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, value);
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                    ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addOpsetImport(
                    int index, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder builderForValue) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    opsetImportBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder addAllOpsetImport(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.OperatorSetIdProto> values) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, opsetImport_);
                    onChanged();
                } else {
                    opsetImportBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder clearOpsetImport() {
                if (opsetImportBuilder_ == null) {
                    opsetImport_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    opsetImportBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public Builder removeOpsetImport(int index) {
                if (opsetImportBuilder_ == null) {
                    ensureOpsetImportIsMutable();
                    opsetImport_.remove(index);
                    onChanged();
                } else {
                    opsetImportBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder getOpsetImportBuilder(
                    int index) {
                return getOpsetImportFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
                    int index) {
                if (opsetImportBuilder_ == null) {
                    return opsetImport_.get(index);  } else {
                    return opsetImportBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder>
            getOpsetImportOrBuilderList() {
                if (opsetImportBuilder_ != null) {
                    return opsetImportBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(opsetImport_);
                }
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder() {
                return getOpsetImportFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder addOpsetImportBuilder(
                    int index) {
                return getOpsetImportFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.OperatorSetIdProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The OperatorSets this model relies on.
             * All ModelProtos MUST have at least one entry that
             * specifies which version of the ONNX OperatorSet is
             * being imported.
             * All nodes in the ModelProto's graph will bind against the operator
             * with the same-domain/same-op_type operator with the HIGHEST version
             * in the referenced operator sets.
             * </pre>
             *
             * <code>repeated .onnx.OperatorSetIdProto opset_import = 8;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder>
            getOpsetImportBuilderList() {
                return getOpsetImportFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.OperatorSetIdProto, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder, ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder>
            getOpsetImportFieldBuilder() {
                if (opsetImportBuilder_ == null) {
                    opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.OperatorSetIdProto, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder, ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder>(
                            opsetImport_,
                            ((bitField0_ & 0x00000002) != 0),
                            getParentForChildren(),
                            isClean());
                    opsetImport_ = null;
                }
                return opsetImportBuilder_;
            }

            private java.lang.Object producerName_ = "";
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return Whether the producerName field is set.
             */
            public boolean hasProducerName() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return The producerName.
             */
            public java.lang.String getProducerName() {
                java.lang.Object ref = producerName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        producerName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return The bytes for producerName.
             */
            public com.google.protobuf.ByteString
            getProducerNameBytes() {
                java.lang.Object ref = producerName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    producerName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @param value The producerName to set.
             * @return This builder for chaining.
             */
            public Builder setProducerName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                producerName_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearProducerName() {
                bitField0_ = (bitField0_ & ~0x00000004);
                producerName_ = getDefaultInstance().getProducerName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_name = 2;</code>
             * @param value The bytes for producerName to set.
             * @return This builder for chaining.
             */
            public Builder setProducerNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000004;
                producerName_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object producerVersion_ = "";
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return Whether the producerVersion field is set.
             */
            public boolean hasProducerVersion() {
                return ((bitField0_ & 0x00000008) != 0);
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return The producerVersion.
             */
            public java.lang.String getProducerVersion() {
                java.lang.Object ref = producerVersion_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        producerVersion_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return The bytes for producerVersion.
             */
            public com.google.protobuf.ByteString
            getProducerVersionBytes() {
                java.lang.Object ref = producerVersion_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    producerVersion_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @param value The producerVersion to set.
             * @return This builder for chaining.
             */
            public Builder setProducerVersion(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                producerVersion_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearProducerVersion() {
                bitField0_ = (bitField0_ & ~0x00000008);
                producerVersion_ = getDefaultInstance().getProducerVersion();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the framework or tool used to generate this model.
             * This field SHOULD be present to indicate which implementation/tool/framework
             * emitted the model.
             * </pre>
             *
             * <code>optional string producer_version = 3;</code>
             * @param value The bytes for producerVersion to set.
             * @return This builder for chaining.
             */
            public Builder setProducerVersionBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000008;
                producerVersion_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                domain_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                bitField0_ = (bitField0_ & ~0x00000010);
                domain_ = getDefaultInstance().getDomain();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Domain name of the model.
             * We use reverse domain names as name space indicators. For example:
             * `com.facebook.fair` or `com.microsoft.cognitiveservices`
             * Together with `model_version` and GraphProto.name, this forms the unique identity of
             * the graph.
             * </pre>
             *
             * <code>optional string domain = 4;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                domain_ = value;
                onChanged();
                return this;
            }

            private long modelVersion_ ;
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return Whether the modelVersion field is set.
             */
            @java.lang.Override
            public boolean hasModelVersion() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return The modelVersion.
             */
            @java.lang.Override
            public long getModelVersion() {
                return modelVersion_;
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @param value The modelVersion to set.
             * @return This builder for chaining.
             */
            public Builder setModelVersion(long value) {
                bitField0_ |= 0x00000020;
                modelVersion_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the graph encoded. See Version enum below.
             * </pre>
             *
             * <code>optional int64 model_version = 5;</code>
             * @return This builder for chaining.
             */
            public Builder clearModelVersion() {
                bitField0_ = (bitField0_ & ~0x00000020);
                modelVersion_ = 0L;
                onChanged();
                return this;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000040) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000040;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000040);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this model. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 6;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000040;
                docString_ = value;
                onChanged();
                return this;
            }

            private ai.onnx.proto.OnnxMl.GraphProto graph_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder> graphBuilder_;
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             * @return Whether the graph field is set.
             */
            public boolean hasGraph() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             * @return The graph.
             */
            public ai.onnx.proto.OnnxMl.GraphProto getGraph() {
                if (graphBuilder_ == null) {
                    return graph_ == null ? ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : graph_;
                } else {
                    return graphBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public Builder setGraph(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (graphBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    graph_ = value;
                    onChanged();
                } else {
                    graphBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public Builder setGraph(
                    ai.onnx.proto.OnnxMl.GraphProto.Builder builderForValue) {
                if (graphBuilder_ == null) {
                    graph_ = builderForValue.build();
                    onChanged();
                } else {
                    graphBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public Builder mergeGraph(ai.onnx.proto.OnnxMl.GraphProto value) {
                if (graphBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0) &&
                            graph_ != null &&
                            graph_ != ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance()) {
                        graph_ =
                                ai.onnx.proto.OnnxMl.GraphProto.newBuilder(graph_).mergeFrom(value).buildPartial();
                    } else {
                        graph_ = value;
                    }
                    onChanged();
                } else {
                    graphBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000080;
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public Builder clearGraph() {
                if (graphBuilder_ == null) {
                    graph_ = null;
                    onChanged();
                } else {
                    graphBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000080);
                return this;
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProto.Builder getGraphBuilder() {
                bitField0_ |= 0x00000080;
                onChanged();
                return getGraphFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            public ai.onnx.proto.OnnxMl.GraphProtoOrBuilder getGraphOrBuilder() {
                if (graphBuilder_ != null) {
                    return graphBuilder_.getMessageOrBuilder();
                } else {
                    return graph_ == null ?
                            ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance() : graph_;
                }
            }
            /**
             * <pre>
             * The parameterized graph that is evaluated to execute the model.
             * </pre>
             *
             * <code>optional .onnx.GraphProto graph = 7;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>
            getGraphFieldBuilder() {
                if (graphBuilder_ == null) {
                    graphBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.GraphProto, ai.onnx.proto.OnnxMl.GraphProto.Builder, ai.onnx.proto.OnnxMl.GraphProtoOrBuilder>(
                            getGraph(),
                            getParentForChildren(),
                            isClean());
                    graph_ = null;
                }
                return graphBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> metadataProps_ =
                    java.util.Collections.emptyList();
            private void ensureMetadataPropsIsMutable() {
                if (!((bitField0_ & 0x00000100) != 0)) {
                    metadataProps_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>(metadataProps_);
                    bitField0_ |= 0x00000100;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getMetadataPropsList() {
                if (metadataPropsBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                } else {
                    return metadataPropsBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public int getMetadataPropsCount() {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.size();
                } else {
                    return metadataPropsBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);
                } else {
                    return metadataPropsBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder setMetadataProps(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (metadataPropsBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, value);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                    ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addMetadataProps(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    metadataPropsBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder addAllMetadataProps(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.StringStringEntryProto> values) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, metadataProps_);
                    onChanged();
                } else {
                    metadataPropsBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder clearMetadataProps() {
                if (metadataPropsBuilder_ == null) {
                    metadataProps_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                    onChanged();
                } else {
                    metadataPropsBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public Builder removeMetadataProps(int index) {
                if (metadataPropsBuilder_ == null) {
                    ensureMetadataPropsIsMutable();
                    metadataProps_.remove(index);
                    onChanged();
                } else {
                    metadataPropsBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder getMetadataPropsBuilder(
                    int index) {
                return getMetadataPropsFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
                    int index) {
                if (metadataPropsBuilder_ == null) {
                    return metadataProps_.get(index);  } else {
                    return metadataPropsBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getMetadataPropsOrBuilderList() {
                if (metadataPropsBuilder_ != null) {
                    return metadataPropsBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(metadataProps_);
                }
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder() {
                return getMetadataPropsFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addMetadataPropsBuilder(
                    int index) {
                return getMetadataPropsFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Named metadata values; keys should be distinct.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto metadata_props = 14;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder>
            getMetadataPropsBuilderList() {
                return getMetadataPropsFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getMetadataPropsFieldBuilder() {
                if (metadataPropsBuilder_ == null) {
                    metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>(
                            metadataProps_,
                            ((bitField0_ & 0x00000100) != 0),
                            getParentForChildren(),
                            isClean());
                    metadataProps_ = null;
                }
                return metadataPropsBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto> trainingInfo_ =
                    java.util.Collections.emptyList();
            private void ensureTrainingInfoIsMutable() {
                if (!((bitField0_ & 0x00000200) != 0)) {
                    trainingInfo_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TrainingInfoProto>(trainingInfo_);
                    bitField0_ |= 0x00000200;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TrainingInfoProto, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder, ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder> trainingInfoBuilder_;

            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto> getTrainingInfoList() {
                if (trainingInfoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(trainingInfo_);
                } else {
                    return trainingInfoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public int getTrainingInfoCount() {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.size();
                } else {
                    return trainingInfoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public ai.onnx.proto.OnnxMl.TrainingInfoProto getTrainingInfo(int index) {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.get(index);
                } else {
                    return trainingInfoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder setTrainingInfo(
                    int index, ai.onnx.proto.OnnxMl.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.set(index, value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder setTrainingInfo(
                    int index, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(ai.onnx.proto.OnnxMl.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                    int index, ai.onnx.proto.OnnxMl.TrainingInfoProto value) {
                if (trainingInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(index, value);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                    ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addTrainingInfo(
                    int index, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder builderForValue) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    trainingInfoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder addAllTrainingInfo(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.TrainingInfoProto> values) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, trainingInfo_);
                    onChanged();
                } else {
                    trainingInfoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder clearTrainingInfo() {
                if (trainingInfoBuilder_ == null) {
                    trainingInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000200);
                    onChanged();
                } else {
                    trainingInfoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public Builder removeTrainingInfo(int index) {
                if (trainingInfoBuilder_ == null) {
                    ensureTrainingInfoIsMutable();
                    trainingInfo_.remove(index);
                    onChanged();
                } else {
                    trainingInfoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder getTrainingInfoBuilder(
                    int index) {
                return getTrainingInfoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
                    int index) {
                if (trainingInfoBuilder_ == null) {
                    return trainingInfo_.get(index);  } else {
                    return trainingInfoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder>
            getTrainingInfoOrBuilderList() {
                if (trainingInfoBuilder_ != null) {
                    return trainingInfoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(trainingInfo_);
                }
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder addTrainingInfoBuilder() {
                return getTrainingInfoFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.TrainingInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder addTrainingInfoBuilder(
                    int index) {
                return getTrainingInfoFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.TrainingInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Training-specific information. Sequentially executing all stored
             * `TrainingInfoProto.algorithm`s and assigning their outputs following
             * the corresponding `TrainingInfoProto.update_binding`s is one training
             * iteration. Similarly, to initialize the model
             * (as if training hasn't happened), the user should sequentially execute
             * all stored `TrainingInfoProto.initialization`s and assigns their outputs
             * using `TrainingInfoProto.initialization_binding`s.
             * If this field is empty, the training behavior of the model is undefined.
             * </pre>
             *
             * <code>repeated .onnx.TrainingInfoProto training_info = 20;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder>
            getTrainingInfoBuilderList() {
                return getTrainingInfoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TrainingInfoProto, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder, ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder>
            getTrainingInfoFieldBuilder() {
                if (trainingInfoBuilder_ == null) {
                    trainingInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TrainingInfoProto, ai.onnx.proto.OnnxMl.TrainingInfoProto.Builder, ai.onnx.proto.OnnxMl.TrainingInfoProtoOrBuilder>(
                            trainingInfo_,
                            ((bitField0_ & 0x00000200) != 0),
                            getParentForChildren(),
                            isClean());
                    trainingInfo_ = null;
                }
                return trainingInfoBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.ModelProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.ModelProto)
        private static final ai.onnx.proto.OnnxMl.ModelProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.ModelProto();
        }

        public static ai.onnx.proto.OnnxMl.ModelProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<ModelProto>
                PARSER = new com.google.protobuf.AbstractParser<ModelProto>() {
            @java.lang.Override
            public ModelProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new ModelProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<ModelProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<ModelProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ModelProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface StringStringEntryProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.StringStringEntryProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <code>optional string key = 1;</code>
         * @return Whether the key field is set.
         */
        boolean hasKey();
        /**
         * <code>optional string key = 1;</code>
         * @return The key.
         */
        java.lang.String getKey();
        /**
         * <code>optional string key = 1;</code>
         * @return The bytes for key.
         */
        com.google.protobuf.ByteString
        getKeyBytes();

        /**
         * <code>optional string value = 2;</code>
         * @return Whether the value field is set.
         */
        boolean hasValue();
        /**
         * <code>optional string value = 2;</code>
         * @return The value.
         */
        java.lang.String getValue();
        /**
         * <code>optional string value = 2;</code>
         * @return The bytes for value.
         */
        com.google.protobuf.ByteString
        getValueBytes();
    }
    /**
     * <pre>
     * StringStringEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code onnx.StringStringEntryProto}
     */
    public static final class StringStringEntryProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.StringStringEntryProto)
            StringStringEntryProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use StringStringEntryProto.newBuilder() to construct.
        private StringStringEntryProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private StringStringEntryProto() {
            key_ = "";
            value_ = "";
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new StringStringEntryProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private StringStringEntryProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            key_ = bs;
                            break;
                        }
                        case 18: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000002;
                            value_ = bs;
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.StringStringEntryProto.class, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder.class);
        }

        private int bitField0_;
        public static final int KEY_FIELD_NUMBER = 1;
        private volatile java.lang.Object key_;
        /**
         * <code>optional string key = 1;</code>
         * @return Whether the key field is set.
         */
        @java.lang.Override
        public boolean hasKey() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string key = 1;</code>
         * @return The key.
         */
        @java.lang.Override
        public java.lang.String getKey() {
            java.lang.Object ref = key_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    key_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string key = 1;</code>
         * @return The bytes for key.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getKeyBytes() {
            java.lang.Object ref = key_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                key_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int VALUE_FIELD_NUMBER = 2;
        private volatile java.lang.Object value_;
        /**
         * <code>optional string value = 2;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional string value = 2;</code>
         * @return The value.
         */
        @java.lang.Override
        public java.lang.String getValue() {
            java.lang.Object ref = value_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    value_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string value = 2;</code>
         * @return The bytes for value.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getValueBytes() {
            java.lang.Object ref = value_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                value_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.StringStringEntryProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.StringStringEntryProto other = (ai.onnx.proto.OnnxMl.StringStringEntryProto) obj;

            if (hasKey() != other.hasKey()) return false;
            if (hasKey()) {
                if (!getKey()
                        .equals(other.getKey())) return false;
            }
            if (hasValue() != other.hasValue()) return false;
            if (hasValue()) {
                if (!getValue()
                        .equals(other.getValue())) return false;
            }
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasKey()) {
                hash = (37 * hash) + KEY_FIELD_NUMBER;
                hash = (53 * hash) + getKey().hashCode();
            }
            if (hasValue()) {
                hash = (37 * hash) + VALUE_FIELD_NUMBER;
                hash = (53 * hash) + getValue().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.StringStringEntryProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.StringStringEntryProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * StringStringEntryProto follows the pattern for cross-proto-version maps.
         * See https://developers.google.com/protocol-buffers/docs/proto3#maps
         * </pre>
         *
         * Protobuf type {@code onnx.StringStringEntryProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.StringStringEntryProto)
                ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.StringStringEntryProto.class, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.StringStringEntryProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                key_ = "";
                bitField0_ = (bitField0_ & ~0x00000001);
                value_ = "";
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_StringStringEntryProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.StringStringEntryProto build() {
                ai.onnx.proto.OnnxMl.StringStringEntryProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.StringStringEntryProto buildPartial() {
                ai.onnx.proto.OnnxMl.StringStringEntryProto result = new ai.onnx.proto.OnnxMl.StringStringEntryProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.key_ = key_;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    to_bitField0_ |= 0x00000002;
                }
                result.value_ = value_;
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.StringStringEntryProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.StringStringEntryProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.StringStringEntryProto other) {
                if (other == ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance()) return this;
                if (other.hasKey()) {
                    bitField0_ |= 0x00000001;
                    key_ = other.key_;
                    onChanged();
                }
                if (other.hasValue()) {
                    bitField0_ |= 0x00000002;
                    value_ = other.value_;
                    onChanged();
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.StringStringEntryProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.StringStringEntryProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.lang.Object key_ = "";
            /**
             * <code>optional string key = 1;</code>
             * @return Whether the key field is set.
             */
            public boolean hasKey() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional string key = 1;</code>
             * @return The key.
             */
            public java.lang.String getKey() {
                java.lang.Object ref = key_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        key_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string key = 1;</code>
             * @return The bytes for key.
             */
            public com.google.protobuf.ByteString
            getKeyBytes() {
                java.lang.Object ref = key_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    key_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string key = 1;</code>
             * @param value The key to set.
             * @return This builder for chaining.
             */
            public Builder setKey(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                key_ = value;
                onChanged();
                return this;
            }
            /**
             * <code>optional string key = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearKey() {
                bitField0_ = (bitField0_ & ~0x00000001);
                key_ = getDefaultInstance().getKey();
                onChanged();
                return this;
            }
            /**
             * <code>optional string key = 1;</code>
             * @param value The bytes for key to set.
             * @return This builder for chaining.
             */
            public Builder setKeyBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                key_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object value_ = "";
            /**
             * <code>optional string value = 2;</code>
             * @return Whether the value field is set.
             */
            public boolean hasValue() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional string value = 2;</code>
             * @return The value.
             */
            public java.lang.String getValue() {
                java.lang.Object ref = value_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        value_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string value = 2;</code>
             * @return The bytes for value.
             */
            public com.google.protobuf.ByteString
            getValueBytes() {
                java.lang.Object ref = value_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    value_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string value = 2;</code>
             * @param value The value to set.
             * @return This builder for chaining.
             */
            public Builder setValue(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                value_ = value;
                onChanged();
                return this;
            }
            /**
             * <code>optional string value = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearValue() {
                bitField0_ = (bitField0_ & ~0x00000002);
                value_ = getDefaultInstance().getValue();
                onChanged();
                return this;
            }
            /**
             * <code>optional string value = 2;</code>
             * @param value The bytes for value to set.
             * @return This builder for chaining.
             */
            public Builder setValueBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                value_ = value;
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.StringStringEntryProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.StringStringEntryProto)
        private static final ai.onnx.proto.OnnxMl.StringStringEntryProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.StringStringEntryProto();
        }

        public static ai.onnx.proto.OnnxMl.StringStringEntryProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<StringStringEntryProto>
                PARSER = new com.google.protobuf.AbstractParser<StringStringEntryProto>() {
            @java.lang.Override
            public StringStringEntryProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new StringStringEntryProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<StringStringEntryProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<StringStringEntryProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface TensorAnnotationOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.TensorAnnotation)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        boolean hasTensorName();
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        java.lang.String getTensorName();
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        com.google.protobuf.ByteString
        getTensorNameBytes();

        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto>
        getQuantParameterTensorNamesList();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index);
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        int getQuantParameterTensorNamesCount();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getQuantParameterTensorNamesOrBuilderList();
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
                int index);
    }
    /**
     * Protobuf type {@code onnx.TensorAnnotation}
     */
    public static final class TensorAnnotation extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.TensorAnnotation)
            TensorAnnotationOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use TensorAnnotation.newBuilder() to construct.
        private TensorAnnotation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private TensorAnnotation() {
            tensorName_ = "";
            quantParameterTensorNames_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new TensorAnnotation();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private TensorAnnotation(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            tensorName_ = bs;
                            break;
                        }
                        case 18: {
                            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                                quantParameterTensorNames_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>();
                                mutable_bitField0_ |= 0x00000002;
                            }
                            quantParameterTensorNames_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.StringStringEntryProto.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000002) != 0)) {
                    quantParameterTensorNames_ = java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorAnnotation_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.TensorAnnotation.class, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder.class);
        }

        private int bitField0_;
        public static final int TENSOR_NAME_FIELD_NUMBER = 1;
        private volatile java.lang.Object tensorName_;
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return Whether the tensorName field is set.
         */
        @java.lang.Override
        public boolean hasTensorName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The tensorName.
         */
        @java.lang.Override
        public java.lang.String getTensorName() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    tensorName_ = s;
                }
                return s;
            }
        }
        /**
         * <code>optional string tensor_name = 1;</code>
         * @return The bytes for tensorName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getTensorNameBytes() {
            java.lang.Object ref = tensorName_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                tensorName_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER = 2;
        private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> quantParameterTensorNames_;
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getQuantParameterTensorNamesList() {
            return quantParameterTensorNames_;
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getQuantParameterTensorNamesOrBuilderList() {
            return quantParameterTensorNames_;
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public int getQuantParameterTensorNamesCount() {
            return quantParameterTensorNames_.size();
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index) {
            return quantParameterTensorNames_.get(index);
        }
        /**
         * <pre>
         * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
         * The keys used in the mapping below must be pre-defined in ONNX spec.
         * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
         * quantization parameter keys.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
                int index) {
            return quantParameterTensorNames_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, tensorName_);
            }
            for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
                output.writeMessage(2, quantParameterTensorNames_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, tensorName_);
            }
            for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, quantParameterTensorNames_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.TensorAnnotation)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.TensorAnnotation other = (ai.onnx.proto.OnnxMl.TensorAnnotation) obj;

            if (hasTensorName() != other.hasTensorName()) return false;
            if (hasTensorName()) {
                if (!getTensorName()
                        .equals(other.getTensorName())) return false;
            }
            if (!getQuantParameterTensorNamesList()
                    .equals(other.getQuantParameterTensorNamesList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasTensorName()) {
                hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;
                hash = (53 * hash) + getTensorName().hashCode();
            }
            if (getQuantParameterTensorNamesCount() > 0) {
                hash = (37 * hash) + QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER;
                hash = (53 * hash) + getQuantParameterTensorNamesList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorAnnotation parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.TensorAnnotation prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * Protobuf type {@code onnx.TensorAnnotation}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.TensorAnnotation)
                ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorAnnotation_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TensorAnnotation.class, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.TensorAnnotation.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getQuantParameterTensorNamesFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                tensorName_ = "";
                bitField0_ = (bitField0_ & ~0x00000001);
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNames_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                } else {
                    quantParameterTensorNamesBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorAnnotation_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorAnnotation getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.TensorAnnotation.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorAnnotation build() {
                ai.onnx.proto.OnnxMl.TensorAnnotation result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorAnnotation buildPartial() {
                ai.onnx.proto.OnnxMl.TensorAnnotation result = new ai.onnx.proto.OnnxMl.TensorAnnotation(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.tensorName_ = tensorName_;
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0)) {
                        quantParameterTensorNames_ = java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                        bitField0_ = (bitField0_ & ~0x00000002);
                    }
                    result.quantParameterTensorNames_ = quantParameterTensorNames_;
                } else {
                    result.quantParameterTensorNames_ = quantParameterTensorNamesBuilder_.build();
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.TensorAnnotation) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.TensorAnnotation)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.TensorAnnotation other) {
                if (other == ai.onnx.proto.OnnxMl.TensorAnnotation.getDefaultInstance()) return this;
                if (other.hasTensorName()) {
                    bitField0_ |= 0x00000001;
                    tensorName_ = other.tensorName_;
                    onChanged();
                }
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (!other.quantParameterTensorNames_.isEmpty()) {
                        if (quantParameterTensorNames_.isEmpty()) {
                            quantParameterTensorNames_ = other.quantParameterTensorNames_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                        } else {
                            ensureQuantParameterTensorNamesIsMutable();
                            quantParameterTensorNames_.addAll(other.quantParameterTensorNames_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.quantParameterTensorNames_.isEmpty()) {
                        if (quantParameterTensorNamesBuilder_.isEmpty()) {
                            quantParameterTensorNamesBuilder_.dispose();
                            quantParameterTensorNamesBuilder_ = null;
                            quantParameterTensorNames_ = other.quantParameterTensorNames_;
                            bitField0_ = (bitField0_ & ~0x00000002);
                            quantParameterTensorNamesBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getQuantParameterTensorNamesFieldBuilder() : null;
                        } else {
                            quantParameterTensorNamesBuilder_.addAllMessages(other.quantParameterTensorNames_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.TensorAnnotation parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.TensorAnnotation) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.lang.Object tensorName_ = "";
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return Whether the tensorName field is set.
             */
            public boolean hasTensorName() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return The tensorName.
             */
            public java.lang.String getTensorName() {
                java.lang.Object ref = tensorName_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        tensorName_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return The bytes for tensorName.
             */
            public com.google.protobuf.ByteString
            getTensorNameBytes() {
                java.lang.Object ref = tensorName_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    tensorName_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @param value The tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                tensorName_ = value;
                onChanged();
                return this;
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearTensorName() {
                bitField0_ = (bitField0_ & ~0x00000001);
                tensorName_ = getDefaultInstance().getTensorName();
                onChanged();
                return this;
            }
            /**
             * <code>optional string tensor_name = 1;</code>
             * @param value The bytes for tensorName to set.
             * @return This builder for chaining.
             */
            public Builder setTensorNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                tensorName_ = value;
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> quantParameterTensorNames_ =
                    java.util.Collections.emptyList();
            private void ensureQuantParameterTensorNamesIsMutable() {
                if (!((bitField0_ & 0x00000002) != 0)) {
                    quantParameterTensorNames_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>(quantParameterTensorNames_);
                    bitField0_ |= 0x00000002;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder> quantParameterTensorNamesBuilder_;

            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getQuantParameterTensorNamesList() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                } else {
                    return quantParameterTensorNamesBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public int getQuantParameterTensorNamesCount() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.size();
                } else {
                    return quantParameterTensorNamesBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getQuantParameterTensorNames(int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.get(index);
                } else {
                    return quantParameterTensorNamesBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder setQuantParameterTensorNames(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.set(index, value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder setQuantParameterTensorNames(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(index, value);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                    ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addQuantParameterTensorNames(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder addAllQuantParameterTensorNames(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.StringStringEntryProto> values) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, quantParameterTensorNames_);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder clearQuantParameterTensorNames() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNames_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000002);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public Builder removeQuantParameterTensorNames(int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    ensureQuantParameterTensorNamesIsMutable();
                    quantParameterTensorNames_.remove(index);
                    onChanged();
                } else {
                    quantParameterTensorNamesBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder getQuantParameterTensorNamesBuilder(
                    int index) {
                return getQuantParameterTensorNamesFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
                    int index) {
                if (quantParameterTensorNamesBuilder_ == null) {
                    return quantParameterTensorNames_.get(index);  } else {
                    return quantParameterTensorNamesBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getQuantParameterTensorNamesOrBuilderList() {
                if (quantParameterTensorNamesBuilder_ != null) {
                    return quantParameterTensorNamesBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
                }
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder() {
                return getQuantParameterTensorNamesFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder(
                    int index) {
                return getQuantParameterTensorNamesFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
             * The keys used in the mapping below must be pre-defined in ONNX spec.
             * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
             * quantization parameter keys.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder>
            getQuantParameterTensorNamesBuilderList() {
                return getQuantParameterTensorNamesFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getQuantParameterTensorNamesFieldBuilder() {
                if (quantParameterTensorNamesBuilder_ == null) {
                    quantParameterTensorNamesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>(
                            quantParameterTensorNames_,
                            ((bitField0_ & 0x00000002) != 0),
                            getParentForChildren(),
                            isClean());
                    quantParameterTensorNames_ = null;
                }
                return quantParameterTensorNamesBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.TensorAnnotation)
        }

        // @@protoc_insertion_point(class_scope:onnx.TensorAnnotation)
        private static final ai.onnx.proto.OnnxMl.TensorAnnotation DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TensorAnnotation();
        }

        public static ai.onnx.proto.OnnxMl.TensorAnnotation getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<TensorAnnotation>
                PARSER = new com.google.protobuf.AbstractParser<TensorAnnotation>() {
            @java.lang.Override
            public TensorAnnotation parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new TensorAnnotation(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<TensorAnnotation> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<TensorAnnotation> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorAnnotation getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface GraphProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.GraphProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.NodeProto>
        getNodeList();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        ai.onnx.proto.OnnxMl.NodeProto getNode(int index);
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        int getNodeCount();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.NodeProtoOrBuilder>
        getNodeOrBuilderList();
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        ai.onnx.proto.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(
                int index);

        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();

        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.TensorProto>
        getInitializerList();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProto getInitializer(int index);
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        int getInitializerCount();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
        getInitializerOrBuilderList();
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(
                int index);

        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto>
        getSparseInitializerList();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        ai.onnx.proto.OnnxMl.SparseTensorProto getSparseInitializer(int index);
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        int getSparseInitializerCount();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
        getSparseInitializerOrBuilderList();
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
                int index);

        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();

        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto>
        getInputList();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProto getInput(int index);
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        int getInputCount();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getInputOrBuilderList();
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(
                int index);

        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto>
        getOutputList();
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProto getOutput(int index);
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        int getOutputCount();
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getOutputOrBuilderList();
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(
                int index);

        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto>
        getValueInfoList();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProto getValueInfo(int index);
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        int getValueInfoCount();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList();
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
                int index);

        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation>
        getQuantizationAnnotationList();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        ai.onnx.proto.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index);
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        int getQuantizationAnnotationCount();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder>
        getQuantizationAnnotationOrBuilderList();
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
                int index);
    }
    /**
     * <pre>
     * Graphs
     * A graph defines the computational logic of a model and is comprised of a parameterized
     * list of nodes that form a directed acyclic graph based on their inputs and outputs.
     * This is the equivalent of the "network" or "graph" in many deep learning
     * frameworks.
     * </pre>
     *
     * Protobuf type {@code onnx.GraphProto}
     */
    public static final class GraphProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.GraphProto)
            GraphProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use GraphProto.newBuilder() to construct.
        private GraphProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private GraphProto() {
            node_ = java.util.Collections.emptyList();
            name_ = "";
            initializer_ = java.util.Collections.emptyList();
            sparseInitializer_ = java.util.Collections.emptyList();
            docString_ = "";
            input_ = java.util.Collections.emptyList();
            output_ = java.util.Collections.emptyList();
            valueInfo_ = java.util.Collections.emptyList();
            quantizationAnnotation_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new GraphProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private GraphProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                                node_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.NodeProto>();
                                mutable_bitField0_ |= 0x00000001;
                            }
                            node_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.NodeProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 18: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            name_ = bs;
                            break;
                        }
                        case 42: {
                            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                                initializer_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorProto>();
                                mutable_bitField0_ |= 0x00000004;
                            }
                            initializer_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 82: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000002;
                            docString_ = bs;
                            break;
                        }
                        case 90: {
                            if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                                input_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>();
                                mutable_bitField0_ |= 0x00000020;
                            }
                            input_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.ValueInfoProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 98: {
                            if (!((mutable_bitField0_ & 0x00000040) != 0)) {
                                output_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>();
                                mutable_bitField0_ |= 0x00000040;
                            }
                            output_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.ValueInfoProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 106: {
                            if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                                valueInfo_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>();
                                mutable_bitField0_ |= 0x00000080;
                            }
                            valueInfo_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.ValueInfoProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 114: {
                            if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                                quantizationAnnotation_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorAnnotation>();
                                mutable_bitField0_ |= 0x00000100;
                            }
                            quantizationAnnotation_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.TensorAnnotation.PARSER, extensionRegistry));
                            break;
                        }
                        case 122: {
                            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                                sparseInitializer_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.SparseTensorProto>();
                                mutable_bitField0_ |= 0x00000008;
                            }
                            sparseInitializer_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.SparseTensorProto.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000001) != 0)) {
                    node_ = java.util.Collections.unmodifiableList(node_);
                }
                if (((mutable_bitField0_ & 0x00000004) != 0)) {
                    initializer_ = java.util.Collections.unmodifiableList(initializer_);
                }
                if (((mutable_bitField0_ & 0x00000020) != 0)) {
                    input_ = java.util.Collections.unmodifiableList(input_);
                }
                if (((mutable_bitField0_ & 0x00000040) != 0)) {
                    output_ = java.util.Collections.unmodifiableList(output_);
                }
                if (((mutable_bitField0_ & 0x00000080) != 0)) {
                    valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
                }
                if (((mutable_bitField0_ & 0x00000100) != 0)) {
                    quantizationAnnotation_ = java.util.Collections.unmodifiableList(quantizationAnnotation_);
                }
                if (((mutable_bitField0_ & 0x00000008) != 0)) {
                    sparseInitializer_ = java.util.Collections.unmodifiableList(sparseInitializer_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_GraphProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_GraphProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.GraphProto.class, ai.onnx.proto.OnnxMl.GraphProto.Builder.class);
        }

        private int bitField0_;
        public static final int NODE_FIELD_NUMBER = 1;
        private java.util.List<ai.onnx.proto.OnnxMl.NodeProto> node_;
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.NodeProto> getNodeList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.NodeProtoOrBuilder>
        getNodeOrBuilderList() {
            return node_;
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public int getNodeCount() {
            return node_.size();
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.NodeProto getNode(int index) {
            return node_.get(index);
        }
        /**
         * <pre>
         * The nodes in the graph, sorted topologically.
         * </pre>
         *
         * <code>repeated .onnx.NodeProto node = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(
                int index) {
            return node_.get(index);
        }

        public static final int NAME_FIELD_NUMBER = 2;
        private volatile java.lang.Object name_;
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The name of the graph.
         * </pre>
         *
         * <code>optional string name = 2;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int INITIALIZER_FIELD_NUMBER = 5;
        private java.util.List<ai.onnx.proto.OnnxMl.TensorProto> initializer_;
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.TensorProto> getInitializerList() {
            return initializer_;
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
        getInitializerOrBuilderList() {
            return initializer_;
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public int getInitializerCount() {
            return initializer_.size();
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getInitializer(int index) {
            return initializer_.get(index);
        }
        /**
         * <pre>
         * A list of named tensor values, used to specify constant inputs of the graph.
         * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
         * The name MUST be unique across both initializer and sparse_initializer,
         * but the name MAY also appear in the input list.
         * </pre>
         *
         * <code>repeated .onnx.TensorProto initializer = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(
                int index) {
            return initializer_.get(index);
        }

        public static final int SPARSE_INITIALIZER_FIELD_NUMBER = 15;
        private java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> sparseInitializer_;
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> getSparseInitializerList() {
            return sparseInitializer_;
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
        getSparseInitializerOrBuilderList() {
            return sparseInitializer_;
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public int getSparseInitializerCount() {
            return sparseInitializer_.size();
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseInitializer(int index) {
            return sparseInitializer_.get(index);
        }
        /**
         * <pre>
         * Initializers (see above) stored in sparse format.
         * </pre>
         *
         * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
                int index) {
            return sparseInitializer_.get(index);
        }

        public static final int DOC_STRING_FIELD_NUMBER = 10;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this graph. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 10;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int INPUT_FIELD_NUMBER = 11;
        private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> input_;
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getInputList() {
            return input_;
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getInputOrBuilderList() {
            return input_;
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public int getInputCount() {
            return input_.size();
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProto getInput(int index) {
            return input_.get(index);
        }
        /**
         * <pre>
         * The inputs and outputs of the graph.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto input = 11;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(
                int index) {
            return input_.get(index);
        }

        public static final int OUTPUT_FIELD_NUMBER = 12;
        private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> output_;
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getOutputList() {
            return output_;
        }
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getOutputOrBuilderList() {
            return output_;
        }
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public int getOutputCount() {
            return output_.size();
        }
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProto getOutput(int index) {
            return output_.get(index);
        }
        /**
         * <code>repeated .onnx.ValueInfoProto output = 12;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(
                int index) {
            return output_.get(index);
        }

        public static final int VALUE_INFO_FIELD_NUMBER = 13;
        private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> valueInfo_;
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getValueInfoList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
        getValueInfoOrBuilderList() {
            return valueInfo_;
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public int getValueInfoCount() {
            return valueInfo_.size();
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProto getValueInfo(int index) {
            return valueInfo_.get(index);
        }
        /**
         * <pre>
         * Information for the values in the graph. The ValueInfoProto.name's
         * must be distinct. It is optional for a value to appear in value_info list.
         * </pre>
         *
         * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
                int index) {
            return valueInfo_.get(index);
        }

        public static final int QUANTIZATION_ANNOTATION_FIELD_NUMBER = 14;
        private java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation> quantizationAnnotation_;
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation> getQuantizationAnnotationList() {
            return quantizationAnnotation_;
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder>
        getQuantizationAnnotationOrBuilderList() {
            return quantizationAnnotation_;
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public int getQuantizationAnnotationCount() {
            return quantizationAnnotation_.size();
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index) {
            return quantizationAnnotation_.get(index);
        }
        /**
         * <pre>
         * This field carries information to indicate the mapping among a tensor and its
         * quantization parameter tensors. For example:
         * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
         * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
         * </pre>
         *
         * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
                int index) {
            return quantizationAnnotation_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            for (int i = 0; i < node_.size(); i++) {
                output.writeMessage(1, node_.get(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
            }
            for (int i = 0; i < initializer_.size(); i++) {
                output.writeMessage(5, initializer_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 10, docString_);
            }
            for (int i = 0; i < input_.size(); i++) {
                output.writeMessage(11, input_.get(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                output.writeMessage(12, output_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                output.writeMessage(13, valueInfo_.get(i));
            }
            for (int i = 0; i < quantizationAnnotation_.size(); i++) {
                output.writeMessage(14, quantizationAnnotation_.get(i));
            }
            for (int i = 0; i < sparseInitializer_.size(); i++) {
                output.writeMessage(15, sparseInitializer_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            for (int i = 0; i < node_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, node_.get(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
            }
            for (int i = 0; i < initializer_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(5, initializer_.get(i));
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, docString_);
            }
            for (int i = 0; i < input_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(11, input_.get(i));
            }
            for (int i = 0; i < output_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(12, output_.get(i));
            }
            for (int i = 0; i < valueInfo_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(13, valueInfo_.get(i));
            }
            for (int i = 0; i < quantizationAnnotation_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(14, quantizationAnnotation_.get(i));
            }
            for (int i = 0; i < sparseInitializer_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(15, sparseInitializer_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.GraphProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.GraphProto other = (ai.onnx.proto.OnnxMl.GraphProto) obj;

            if (!getNodeList()
                    .equals(other.getNodeList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (!getInitializerList()
                    .equals(other.getInitializerList())) return false;
            if (!getSparseInitializerList()
                    .equals(other.getSparseInitializerList())) return false;
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (!getInputList()
                    .equals(other.getInputList())) return false;
            if (!getOutputList()
                    .equals(other.getOutputList())) return false;
            if (!getValueInfoList()
                    .equals(other.getValueInfoList())) return false;
            if (!getQuantizationAnnotationList()
                    .equals(other.getQuantizationAnnotationList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getNodeCount() > 0) {
                hash = (37 * hash) + NODE_FIELD_NUMBER;
                hash = (53 * hash) + getNodeList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (getInitializerCount() > 0) {
                hash = (37 * hash) + INITIALIZER_FIELD_NUMBER;
                hash = (53 * hash) + getInitializerList().hashCode();
            }
            if (getSparseInitializerCount() > 0) {
                hash = (37 * hash) + SPARSE_INITIALIZER_FIELD_NUMBER;
                hash = (53 * hash) + getSparseInitializerList().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (getInputCount() > 0) {
                hash = (37 * hash) + INPUT_FIELD_NUMBER;
                hash = (53 * hash) + getInputList().hashCode();
            }
            if (getOutputCount() > 0) {
                hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
                hash = (53 * hash) + getOutputList().hashCode();
            }
            if (getValueInfoCount() > 0) {
                hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;
                hash = (53 * hash) + getValueInfoList().hashCode();
            }
            if (getQuantizationAnnotationCount() > 0) {
                hash = (37 * hash) + QUANTIZATION_ANNOTATION_FIELD_NUMBER;
                hash = (53 * hash) + getQuantizationAnnotationList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.GraphProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.GraphProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Graphs
         * A graph defines the computational logic of a model and is comprised of a parameterized
         * list of nodes that form a directed acyclic graph based on their inputs and outputs.
         * This is the equivalent of the "network" or "graph" in many deep learning
         * frameworks.
         * </pre>
         *
         * Protobuf type {@code onnx.GraphProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.GraphProto)
                ai.onnx.proto.OnnxMl.GraphProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_GraphProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_GraphProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.GraphProto.class, ai.onnx.proto.OnnxMl.GraphProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.GraphProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getNodeFieldBuilder();
                    getInitializerFieldBuilder();
                    getSparseInitializerFieldBuilder();
                    getInputFieldBuilder();
                    getOutputFieldBuilder();
                    getValueInfoFieldBuilder();
                    getQuantizationAnnotationFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                } else {
                    nodeBuilder_.clear();
                }
                name_ = "";
                bitField0_ = (bitField0_ & ~0x00000002);
                if (initializerBuilder_ == null) {
                    initializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                } else {
                    initializerBuilder_.clear();
                }
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                } else {
                    sparseInitializerBuilder_.clear();
                }
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000010);
                if (inputBuilder_ == null) {
                    input_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                } else {
                    inputBuilder_.clear();
                }
                if (outputBuilder_ == null) {
                    output_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000040);
                } else {
                    outputBuilder_.clear();
                }
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000080);
                } else {
                    valueInfoBuilder_.clear();
                }
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotation_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                } else {
                    quantizationAnnotationBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_GraphProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.GraphProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.GraphProto build() {
                ai.onnx.proto.OnnxMl.GraphProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.GraphProto buildPartial() {
                ai.onnx.proto.OnnxMl.GraphProto result = new ai.onnx.proto.OnnxMl.GraphProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (nodeBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0)) {
                        node_ = java.util.Collections.unmodifiableList(node_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.node_ = node_;
                } else {
                    result.node_ = nodeBuilder_.build();
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.name_ = name_;
                if (initializerBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0)) {
                        initializer_ = java.util.Collections.unmodifiableList(initializer_);
                        bitField0_ = (bitField0_ & ~0x00000004);
                    }
                    result.initializer_ = initializer_;
                } else {
                    result.initializer_ = initializerBuilder_.build();
                }
                if (sparseInitializerBuilder_ == null) {
                    if (((bitField0_ & 0x00000008) != 0)) {
                        sparseInitializer_ = java.util.Collections.unmodifiableList(sparseInitializer_);
                        bitField0_ = (bitField0_ & ~0x00000008);
                    }
                    result.sparseInitializer_ = sparseInitializer_;
                } else {
                    result.sparseInitializer_ = sparseInitializerBuilder_.build();
                }
                if (((from_bitField0_ & 0x00000010) != 0)) {
                    to_bitField0_ |= 0x00000002;
                }
                result.docString_ = docString_;
                if (inputBuilder_ == null) {
                    if (((bitField0_ & 0x00000020) != 0)) {
                        input_ = java.util.Collections.unmodifiableList(input_);
                        bitField0_ = (bitField0_ & ~0x00000020);
                    }
                    result.input_ = input_;
                } else {
                    result.input_ = inputBuilder_.build();
                }
                if (outputBuilder_ == null) {
                    if (((bitField0_ & 0x00000040) != 0)) {
                        output_ = java.util.Collections.unmodifiableList(output_);
                        bitField0_ = (bitField0_ & ~0x00000040);
                    }
                    result.output_ = output_;
                } else {
                    result.output_ = outputBuilder_.build();
                }
                if (valueInfoBuilder_ == null) {
                    if (((bitField0_ & 0x00000080) != 0)) {
                        valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
                        bitField0_ = (bitField0_ & ~0x00000080);
                    }
                    result.valueInfo_ = valueInfo_;
                } else {
                    result.valueInfo_ = valueInfoBuilder_.build();
                }
                if (quantizationAnnotationBuilder_ == null) {
                    if (((bitField0_ & 0x00000100) != 0)) {
                        quantizationAnnotation_ = java.util.Collections.unmodifiableList(quantizationAnnotation_);
                        bitField0_ = (bitField0_ & ~0x00000100);
                    }
                    result.quantizationAnnotation_ = quantizationAnnotation_;
                } else {
                    result.quantizationAnnotation_ = quantizationAnnotationBuilder_.build();
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.GraphProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.GraphProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.GraphProto other) {
                if (other == ai.onnx.proto.OnnxMl.GraphProto.getDefaultInstance()) return this;
                if (nodeBuilder_ == null) {
                    if (!other.node_.isEmpty()) {
                        if (node_.isEmpty()) {
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        } else {
                            ensureNodeIsMutable();
                            node_.addAll(other.node_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.node_.isEmpty()) {
                        if (nodeBuilder_.isEmpty()) {
                            nodeBuilder_.dispose();
                            nodeBuilder_ = null;
                            node_ = other.node_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            nodeBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getNodeFieldBuilder() : null;
                        } else {
                            nodeBuilder_.addAllMessages(other.node_);
                        }
                    }
                }
                if (other.hasName()) {
                    bitField0_ |= 0x00000002;
                    name_ = other.name_;
                    onChanged();
                }
                if (initializerBuilder_ == null) {
                    if (!other.initializer_.isEmpty()) {
                        if (initializer_.isEmpty()) {
                            initializer_ = other.initializer_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                        } else {
                            ensureInitializerIsMutable();
                            initializer_.addAll(other.initializer_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.initializer_.isEmpty()) {
                        if (initializerBuilder_.isEmpty()) {
                            initializerBuilder_.dispose();
                            initializerBuilder_ = null;
                            initializer_ = other.initializer_;
                            bitField0_ = (bitField0_ & ~0x00000004);
                            initializerBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getInitializerFieldBuilder() : null;
                        } else {
                            initializerBuilder_.addAllMessages(other.initializer_);
                        }
                    }
                }
                if (sparseInitializerBuilder_ == null) {
                    if (!other.sparseInitializer_.isEmpty()) {
                        if (sparseInitializer_.isEmpty()) {
                            sparseInitializer_ = other.sparseInitializer_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                        } else {
                            ensureSparseInitializerIsMutable();
                            sparseInitializer_.addAll(other.sparseInitializer_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.sparseInitializer_.isEmpty()) {
                        if (sparseInitializerBuilder_.isEmpty()) {
                            sparseInitializerBuilder_.dispose();
                            sparseInitializerBuilder_ = null;
                            sparseInitializer_ = other.sparseInitializer_;
                            bitField0_ = (bitField0_ & ~0x00000008);
                            sparseInitializerBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getSparseInitializerFieldBuilder() : null;
                        } else {
                            sparseInitializerBuilder_.addAllMessages(other.sparseInitializer_);
                        }
                    }
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000010;
                    docString_ = other.docString_;
                    onChanged();
                }
                if (inputBuilder_ == null) {
                    if (!other.input_.isEmpty()) {
                        if (input_.isEmpty()) {
                            input_ = other.input_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                        } else {
                            ensureInputIsMutable();
                            input_.addAll(other.input_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.input_.isEmpty()) {
                        if (inputBuilder_.isEmpty()) {
                            inputBuilder_.dispose();
                            inputBuilder_ = null;
                            input_ = other.input_;
                            bitField0_ = (bitField0_ & ~0x00000020);
                            inputBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getInputFieldBuilder() : null;
                        } else {
                            inputBuilder_.addAllMessages(other.input_);
                        }
                    }
                }
                if (outputBuilder_ == null) {
                    if (!other.output_.isEmpty()) {
                        if (output_.isEmpty()) {
                            output_ = other.output_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                        } else {
                            ensureOutputIsMutable();
                            output_.addAll(other.output_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.output_.isEmpty()) {
                        if (outputBuilder_.isEmpty()) {
                            outputBuilder_.dispose();
                            outputBuilder_ = null;
                            output_ = other.output_;
                            bitField0_ = (bitField0_ & ~0x00000040);
                            outputBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getOutputFieldBuilder() : null;
                        } else {
                            outputBuilder_.addAllMessages(other.output_);
                        }
                    }
                }
                if (valueInfoBuilder_ == null) {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfo_.isEmpty()) {
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                        } else {
                            ensureValueInfoIsMutable();
                            valueInfo_.addAll(other.valueInfo_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.valueInfo_.isEmpty()) {
                        if (valueInfoBuilder_.isEmpty()) {
                            valueInfoBuilder_.dispose();
                            valueInfoBuilder_ = null;
                            valueInfo_ = other.valueInfo_;
                            bitField0_ = (bitField0_ & ~0x00000080);
                            valueInfoBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getValueInfoFieldBuilder() : null;
                        } else {
                            valueInfoBuilder_.addAllMessages(other.valueInfo_);
                        }
                    }
                }
                if (quantizationAnnotationBuilder_ == null) {
                    if (!other.quantizationAnnotation_.isEmpty()) {
                        if (quantizationAnnotation_.isEmpty()) {
                            quantizationAnnotation_ = other.quantizationAnnotation_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                        } else {
                            ensureQuantizationAnnotationIsMutable();
                            quantizationAnnotation_.addAll(other.quantizationAnnotation_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.quantizationAnnotation_.isEmpty()) {
                        if (quantizationAnnotationBuilder_.isEmpty()) {
                            quantizationAnnotationBuilder_.dispose();
                            quantizationAnnotationBuilder_ = null;
                            quantizationAnnotation_ = other.quantizationAnnotation_;
                            bitField0_ = (bitField0_ & ~0x00000100);
                            quantizationAnnotationBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getQuantizationAnnotationFieldBuilder() : null;
                        } else {
                            quantizationAnnotationBuilder_.addAllMessages(other.quantizationAnnotation_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.GraphProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.GraphProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.util.List<ai.onnx.proto.OnnxMl.NodeProto> node_ =
                    java.util.Collections.emptyList();
            private void ensureNodeIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    node_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.NodeProto>(node_);
                    bitField0_ |= 0x00000001;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.NodeProto, ai.onnx.proto.OnnxMl.NodeProto.Builder, ai.onnx.proto.OnnxMl.NodeProtoOrBuilder> nodeBuilder_;

            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.NodeProto> getNodeList() {
                if (nodeBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(node_);
                } else {
                    return nodeBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public int getNodeCount() {
                if (nodeBuilder_ == null) {
                    return node_.size();
                } else {
                    return nodeBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.NodeProto getNode(int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);
                } else {
                    return nodeBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder setNode(
                    int index, ai.onnx.proto.OnnxMl.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.set(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder setNode(
                    int index, ai.onnx.proto.OnnxMl.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(ai.onnx.proto.OnnxMl.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                    int index, ai.onnx.proto.OnnxMl.NodeProto value) {
                if (nodeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureNodeIsMutable();
                    node_.add(index, value);
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                    ai.onnx.proto.OnnxMl.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder addNode(
                    int index, ai.onnx.proto.OnnxMl.NodeProto.Builder builderForValue) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    nodeBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder addAllNode(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.NodeProto> values) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, node_);
                    onChanged();
                } else {
                    nodeBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder clearNode() {
                if (nodeBuilder_ == null) {
                    node_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                } else {
                    nodeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public Builder removeNode(int index) {
                if (nodeBuilder_ == null) {
                    ensureNodeIsMutable();
                    node_.remove(index);
                    onChanged();
                } else {
                    nodeBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.NodeProto.Builder getNodeBuilder(
                    int index) {
                return getNodeFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.NodeProtoOrBuilder getNodeOrBuilder(
                    int index) {
                if (nodeBuilder_ == null) {
                    return node_.get(index);  } else {
                    return nodeBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.NodeProtoOrBuilder>
            getNodeOrBuilderList() {
                if (nodeBuilder_ != null) {
                    return nodeBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(node_);
                }
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.NodeProto.Builder addNodeBuilder() {
                return getNodeFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.NodeProto.Builder addNodeBuilder(
                    int index) {
                return getNodeFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.NodeProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The nodes in the graph, sorted topologically.
             * </pre>
             *
             * <code>repeated .onnx.NodeProto node = 1;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.NodeProto.Builder>
            getNodeBuilderList() {
                return getNodeFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.NodeProto, ai.onnx.proto.OnnxMl.NodeProto.Builder, ai.onnx.proto.OnnxMl.NodeProtoOrBuilder>
            getNodeFieldBuilder() {
                if (nodeBuilder_ == null) {
                    nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.NodeProto, ai.onnx.proto.OnnxMl.NodeProto.Builder, ai.onnx.proto.OnnxMl.NodeProtoOrBuilder>(
                            node_,
                            ((bitField0_ & 0x00000001) != 0),
                            getParentForChildren(),
                            isClean());
                    node_ = null;
                }
                return nodeBuilder_;
            }

            private java.lang.Object name_ = "";
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                name_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                bitField0_ = (bitField0_ & ~0x00000002);
                name_ = getDefaultInstance().getName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The name of the graph.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000002;
                name_ = value;
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.TensorProto> initializer_ =
                    java.util.Collections.emptyList();
            private void ensureInitializerIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    initializer_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorProto>(initializer_);
                    bitField0_ |= 0x00000004;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder> initializerBuilder_;

            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorProto> getInitializerList() {
                if (initializerBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(initializer_);
                } else {
                    return initializerBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public int getInitializerCount() {
                if (initializerBuilder_ == null) {
                    return initializer_.size();
                } else {
                    return initializerBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto getInitializer(int index) {
                if (initializerBuilder_ == null) {
                    return initializer_.get(index);
                } else {
                    return initializerBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder setInitializer(
                    int index, ai.onnx.proto.OnnxMl.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.set(index, value);
                    onChanged();
                } else {
                    initializerBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder setInitializer(
                    int index, ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.add(value);
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                    int index, ai.onnx.proto.OnnxMl.TensorProto value) {
                if (initializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInitializerIsMutable();
                    initializer_.add(index, value);
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                    ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.add(builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder addInitializer(
                    int index, ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    initializerBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder addAllInitializer(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.TensorProto> values) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, initializer_);
                    onChanged();
                } else {
                    initializerBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder clearInitializer() {
                if (initializerBuilder_ == null) {
                    initializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000004);
                    onChanged();
                } else {
                    initializerBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public Builder removeInitializer(int index) {
                if (initializerBuilder_ == null) {
                    ensureInitializerIsMutable();
                    initializer_.remove(index);
                    onChanged();
                } else {
                    initializerBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder getInitializerBuilder(
                    int index) {
                return getInitializerFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getInitializerOrBuilder(
                    int index) {
                if (initializerBuilder_ == null) {
                    return initializer_.get(index);  } else {
                    return initializerBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getInitializerOrBuilderList() {
                if (initializerBuilder_ != null) {
                    return initializerBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(initializer_);
                }
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder addInitializerBuilder() {
                return getInitializerFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder addInitializerBuilder(
                    int index) {
                return getInitializerFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * A list of named tensor values, used to specify constant inputs of the graph.
             * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
             * The name MUST be unique across both initializer and sparse_initializer,
             * but the name MAY also appear in the input list.
             * </pre>
             *
             * <code>repeated .onnx.TensorProto initializer = 5;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorProto.Builder>
            getInitializerBuilderList() {
                return getInitializerFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getInitializerFieldBuilder() {
                if (initializerBuilder_ == null) {
                    initializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>(
                            initializer_,
                            ((bitField0_ & 0x00000004) != 0),
                            getParentForChildren(),
                            isClean());
                    initializer_ = null;
                }
                return initializerBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> sparseInitializer_ =
                    java.util.Collections.emptyList();
            private void ensureSparseInitializerIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    sparseInitializer_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.SparseTensorProto>(sparseInitializer_);
                    bitField0_ |= 0x00000008;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder> sparseInitializerBuilder_;

            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto> getSparseInitializerList() {
                if (sparseInitializerBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(sparseInitializer_);
                } else {
                    return sparseInitializerBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public int getSparseInitializerCount() {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.size();
                } else {
                    return sparseInitializerBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto getSparseInitializer(int index) {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.get(index);
                } else {
                    return sparseInitializerBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder setSparseInitializer(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.set(index, value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder setSparseInitializer(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto value) {
                if (sparseInitializerBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(index, value);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                    ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addSparseInitializer(
                    int index, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder builderForValue) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder addAllSparseInitializer(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.SparseTensorProto> values) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, sparseInitializer_);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder clearSparseInitializer() {
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializer_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000008);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public Builder removeSparseInitializer(int index) {
                if (sparseInitializerBuilder_ == null) {
                    ensureSparseInitializerIsMutable();
                    sparseInitializer_.remove(index);
                    onChanged();
                } else {
                    sparseInitializerBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder getSparseInitializerBuilder(
                    int index) {
                return getSparseInitializerFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
                    int index) {
                if (sparseInitializerBuilder_ == null) {
                    return sparseInitializer_.get(index);  } else {
                    return sparseInitializerBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
            getSparseInitializerOrBuilderList() {
                if (sparseInitializerBuilder_ != null) {
                    return sparseInitializerBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(sparseInitializer_);
                }
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder addSparseInitializerBuilder() {
                return getSparseInitializerFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public ai.onnx.proto.OnnxMl.SparseTensorProto.Builder addSparseInitializerBuilder(
                    int index) {
                return getSparseInitializerFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Initializers (see above) stored in sparse format.
             * </pre>
             *
             * <code>repeated .onnx.SparseTensorProto sparse_initializer = 15;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.SparseTensorProto.Builder>
            getSparseInitializerBuilderList() {
                return getSparseInitializerFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>
            getSparseInitializerFieldBuilder() {
                if (sparseInitializerBuilder_ == null) {
                    sparseInitializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.SparseTensorProto, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder, ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder>(
                            sparseInitializer_,
                            ((bitField0_ & 0x00000008) != 0),
                            getParentForChildren(),
                            isClean());
                    sparseInitializer_ = null;
                }
                return sparseInitializerBuilder_;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000010) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000010);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this graph. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 10;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000010;
                docString_ = value;
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> input_ =
                    java.util.Collections.emptyList();
            private void ensureInputIsMutable() {
                if (!((bitField0_ & 0x00000020) != 0)) {
                    input_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>(input_);
                    bitField0_ |= 0x00000020;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder> inputBuilder_;

            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getInputList() {
                if (inputBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(input_);
                } else {
                    return inputBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public int getInputCount() {
                if (inputBuilder_ == null) {
                    return input_.size();
                } else {
                    return inputBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto getInput(int index) {
                if (inputBuilder_ == null) {
                    return input_.get(index);
                } else {
                    return inputBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder setInput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.set(index, value);
                    onChanged();
                } else {
                    inputBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder setInput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.add(value);
                    onChanged();
                } else {
                    inputBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (inputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureInputIsMutable();
                    input_.add(index, value);
                    onChanged();
                } else {
                    inputBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                    ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.add(builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addInput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    inputBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder addAllInput(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.ValueInfoProto> values) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, input_);
                    onChanged();
                } else {
                    inputBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder clearInput() {
                if (inputBuilder_ == null) {
                    input_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000020);
                    onChanged();
                } else {
                    inputBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public Builder removeInput(int index) {
                if (inputBuilder_ == null) {
                    ensureInputIsMutable();
                    input_.remove(index);
                    onChanged();
                } else {
                    inputBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder getInputBuilder(
                    int index) {
                return getInputFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getInputOrBuilder(
                    int index) {
                if (inputBuilder_ == null) {
                    return input_.get(index);  } else {
                    return inputBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getInputOrBuilderList() {
                if (inputBuilder_ != null) {
                    return inputBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(input_);
                }
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addInputBuilder() {
                return getInputFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addInputBuilder(
                    int index) {
                return getInputFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * The inputs and outputs of the graph.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto input = 11;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto.Builder>
            getInputBuilderList() {
                return getInputFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getInputFieldBuilder() {
                if (inputBuilder_ == null) {
                    inputBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>(
                            input_,
                            ((bitField0_ & 0x00000020) != 0),
                            getParentForChildren(),
                            isClean());
                    input_ = null;
                }
                return inputBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> output_ =
                    java.util.Collections.emptyList();
            private void ensureOutputIsMutable() {
                if (!((bitField0_ & 0x00000040) != 0)) {
                    output_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>(output_);
                    bitField0_ |= 0x00000040;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder> outputBuilder_;

            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getOutputList() {
                if (outputBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(output_);
                } else {
                    return outputBuilder_.getMessageList();
                }
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public int getOutputCount() {
                if (outputBuilder_ == null) {
                    return output_.size();
                } else {
                    return outputBuilder_.getCount();
                }
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto getOutput(int index) {
                if (outputBuilder_ == null) {
                    return output_.get(index);
                } else {
                    return outputBuilder_.getMessage(index);
                }
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder setOutput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.set(index, value);
                    onChanged();
                } else {
                    outputBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder setOutput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.add(value);
                    onChanged();
                } else {
                    outputBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (outputBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureOutputIsMutable();
                    output_.add(index, value);
                    onChanged();
                } else {
                    outputBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                    ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.add(builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addOutput(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    outputBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder addAllOutput(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.ValueInfoProto> values) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, output_);
                    onChanged();
                } else {
                    outputBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder clearOutput() {
                if (outputBuilder_ == null) {
                    output_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000040);
                    onChanged();
                } else {
                    outputBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public Builder removeOutput(int index) {
                if (outputBuilder_ == null) {
                    ensureOutputIsMutable();
                    output_.remove(index);
                    onChanged();
                } else {
                    outputBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder getOutputBuilder(
                    int index) {
                return getOutputFieldBuilder().getBuilder(index);
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getOutputOrBuilder(
                    int index) {
                if (outputBuilder_ == null) {
                    return output_.get(index);  } else {
                    return outputBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getOutputOrBuilderList() {
                if (outputBuilder_ != null) {
                    return outputBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(output_);
                }
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addOutputBuilder() {
                return getOutputFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addOutputBuilder(
                    int index) {
                return getOutputFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <code>repeated .onnx.ValueInfoProto output = 12;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto.Builder>
            getOutputBuilderList() {
                return getOutputFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getOutputFieldBuilder() {
                if (outputBuilder_ == null) {
                    outputBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>(
                            output_,
                            ((bitField0_ & 0x00000040) != 0),
                            getParentForChildren(),
                            isClean());
                    output_ = null;
                }
                return outputBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> valueInfo_ =
                    java.util.Collections.emptyList();
            private void ensureValueInfoIsMutable() {
                if (!((bitField0_ & 0x00000080) != 0)) {
                    valueInfo_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.ValueInfoProto>(valueInfo_);
                    bitField0_ |= 0x00000080;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder> valueInfoBuilder_;

            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto> getValueInfoList() {
                if (valueInfoBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                } else {
                    return valueInfoBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public int getValueInfoCount() {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.size();
                } else {
                    return valueInfoBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto getValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);
                } else {
                    return valueInfoBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder setValueInfo(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder setValueInfo(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto value) {
                if (valueInfoBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, value);
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                    ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addValueInfo(
                    int index, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder builderForValue) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    valueInfoBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder addAllValueInfo(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.ValueInfoProto> values) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, valueInfo_);
                    onChanged();
                } else {
                    valueInfoBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder clearValueInfo() {
                if (valueInfoBuilder_ == null) {
                    valueInfo_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000080);
                    onChanged();
                } else {
                    valueInfoBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public Builder removeValueInfo(int index) {
                if (valueInfoBuilder_ == null) {
                    ensureValueInfoIsMutable();
                    valueInfo_.remove(index);
                    onChanged();
                } else {
                    valueInfoBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder getValueInfoBuilder(
                    int index) {
                return getValueInfoFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
                    int index) {
                if (valueInfoBuilder_ == null) {
                    return valueInfo_.get(index);  } else {
                    return valueInfoBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getValueInfoOrBuilderList() {
                if (valueInfoBuilder_ != null) {
                    return valueInfoBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(valueInfo_);
                }
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder() {
                return getValueInfoFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.ValueInfoProto.Builder addValueInfoBuilder(
                    int index) {
                return getValueInfoFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.ValueInfoProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Information for the values in the graph. The ValueInfoProto.name's
             * must be distinct. It is optional for a value to appear in value_info list.
             * </pre>
             *
             * <code>repeated .onnx.ValueInfoProto value_info = 13;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.ValueInfoProto.Builder>
            getValueInfoBuilderList() {
                return getValueInfoFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>
            getValueInfoFieldBuilder() {
                if (valueInfoBuilder_ == null) {
                    valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.ValueInfoProto, ai.onnx.proto.OnnxMl.ValueInfoProto.Builder, ai.onnx.proto.OnnxMl.ValueInfoProtoOrBuilder>(
                            valueInfo_,
                            ((bitField0_ & 0x00000080) != 0),
                            getParentForChildren(),
                            isClean());
                    valueInfo_ = null;
                }
                return valueInfoBuilder_;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation> quantizationAnnotation_ =
                    java.util.Collections.emptyList();
            private void ensureQuantizationAnnotationIsMutable() {
                if (!((bitField0_ & 0x00000100) != 0)) {
                    quantizationAnnotation_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorAnnotation>(quantizationAnnotation_);
                    bitField0_ |= 0x00000100;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorAnnotation, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder, ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder> quantizationAnnotationBuilder_;

            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation> getQuantizationAnnotationList() {
                if (quantizationAnnotationBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(quantizationAnnotation_);
                } else {
                    return quantizationAnnotationBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public int getQuantizationAnnotationCount() {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.size();
                } else {
                    return quantizationAnnotationBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorAnnotation getQuantizationAnnotation(int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.get(index);
                } else {
                    return quantizationAnnotationBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder setQuantizationAnnotation(
                    int index, ai.onnx.proto.OnnxMl.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.set(index, value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder setQuantizationAnnotation(
                    int index, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(ai.onnx.proto.OnnxMl.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                    int index, ai.onnx.proto.OnnxMl.TensorAnnotation value) {
                if (quantizationAnnotationBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(index, value);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                    ai.onnx.proto.OnnxMl.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addQuantizationAnnotation(
                    int index, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder builderForValue) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder addAllQuantizationAnnotation(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.TensorAnnotation> values) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, quantizationAnnotation_);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder clearQuantizationAnnotation() {
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotation_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000100);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public Builder removeQuantizationAnnotation(int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    ensureQuantizationAnnotationIsMutable();
                    quantizationAnnotation_.remove(index);
                    onChanged();
                } else {
                    quantizationAnnotationBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorAnnotation.Builder getQuantizationAnnotationBuilder(
                    int index) {
                return getQuantizationAnnotationFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
                    int index) {
                if (quantizationAnnotationBuilder_ == null) {
                    return quantizationAnnotation_.get(index);  } else {
                    return quantizationAnnotationBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder>
            getQuantizationAnnotationOrBuilderList() {
                if (quantizationAnnotationBuilder_ != null) {
                    return quantizationAnnotationBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(quantizationAnnotation_);
                }
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorAnnotation.Builder addQuantizationAnnotationBuilder() {
                return getQuantizationAnnotationFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.TensorAnnotation.getDefaultInstance());
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorAnnotation.Builder addQuantizationAnnotationBuilder(
                    int index) {
                return getQuantizationAnnotationFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.TensorAnnotation.getDefaultInstance());
            }
            /**
             * <pre>
             * This field carries information to indicate the mapping among a tensor and its
             * quantization parameter tensors. For example:
             * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
             * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
             * </pre>
             *
             * <code>repeated .onnx.TensorAnnotation quantization_annotation = 14;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorAnnotation.Builder>
            getQuantizationAnnotationBuilderList() {
                return getQuantizationAnnotationFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorAnnotation, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder, ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder>
            getQuantizationAnnotationFieldBuilder() {
                if (quantizationAnnotationBuilder_ == null) {
                    quantizationAnnotationBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorAnnotation, ai.onnx.proto.OnnxMl.TensorAnnotation.Builder, ai.onnx.proto.OnnxMl.TensorAnnotationOrBuilder>(
                            quantizationAnnotation_,
                            ((bitField0_ & 0x00000100) != 0),
                            getParentForChildren(),
                            isClean());
                    quantizationAnnotation_ = null;
                }
                return quantizationAnnotationBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.GraphProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.GraphProto)
        private static final ai.onnx.proto.OnnxMl.GraphProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.GraphProto();
        }

        public static ai.onnx.proto.OnnxMl.GraphProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<GraphProto>
                PARSER = new com.google.protobuf.AbstractParser<GraphProto>() {
            @java.lang.Override
            public GraphProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new GraphProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<GraphProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<GraphProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.GraphProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface TensorProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.TensorProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return A list containing the dims.
         */
        java.util.List<java.lang.Long> getDimsList();
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return The count of dims.
         */
        int getDimsCount();
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        long getDims(int index);

        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return Whether the dataType field is set.
         */
        boolean hasDataType();
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return The dataType.
         */
        int getDataType();

        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         * @return Whether the segment field is set.
         */
        boolean hasSegment();
        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         * @return The segment.
         */
        ai.onnx.proto.OnnxMl.TensorProto.Segment getSegment();
        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder();

        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return A list containing the floatData.
         */
        java.util.List<java.lang.Float> getFloatDataList();
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return The count of floatData.
         */
        int getFloatDataCount();
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The floatData at the given index.
         */
        float getFloatData(int index);

        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return A list containing the int32Data.
         */
        java.util.List<java.lang.Integer> getInt32DataList();
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return The count of int32Data.
         */
        int getInt32DataCount();
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int32Data at the given index.
         */
        int getInt32Data(int index);

        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return A list containing the stringData.
         */
        java.util.List<com.google.protobuf.ByteString> getStringDataList();
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return The count of stringData.
         */
        int getStringDataCount();
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @param index The index of the element to return.
         * @return The stringData at the given index.
         */
        com.google.protobuf.ByteString getStringData(int index);

        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return A list containing the int64Data.
         */
        java.util.List<java.lang.Long> getInt64DataList();
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return The count of int64Data.
         */
        int getInt64DataCount();
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int64Data at the given index.
         */
        long getInt64Data(int index);

        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return Whether the name field is set.
         */
        boolean hasName();
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The name.
         */
        java.lang.String getName();
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The bytes for name.
         */
        com.google.protobuf.ByteString
        getNameBytes();

        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return Whether the docString field is set.
         */
        boolean hasDocString();
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The docString.
         */
        java.lang.String getDocString();
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The bytes for docString.
         */
        com.google.protobuf.ByteString
        getDocStringBytes();

        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return Whether the rawData field is set.
         */
        boolean hasRawData();
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return The rawData.
         */
        com.google.protobuf.ByteString getRawData();

        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto>
        getExternalDataList();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProto getExternalData(int index);
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        int getExternalDataCount();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getExternalDataOrBuilderList();
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
                int index);

        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return Whether the dataLocation field is set.
         */
        boolean hasDataLocation();
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return The dataLocation.
         */
        ai.onnx.proto.OnnxMl.TensorProto.DataLocation getDataLocation();

        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return A list containing the doubleData.
         */
        java.util.List<java.lang.Double> getDoubleDataList();
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return The count of doubleData.
         */
        int getDoubleDataCount();
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The doubleData at the given index.
         */
        double getDoubleData(int index);

        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return A list containing the uint64Data.
         */
        java.util.List<java.lang.Long> getUint64DataList();
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return The count of uint64Data.
         */
        int getUint64DataCount();
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The uint64Data at the given index.
         */
        long getUint64Data(int index);
    }
    /**
     * <pre>
     * Tensors
     * A serialized tensor value.
     * </pre>
     *
     * Protobuf type {@code onnx.TensorProto}
     */
    public static final class TensorProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.TensorProto)
            TensorProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use TensorProto.newBuilder() to construct.
        private TensorProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private TensorProto() {
            dims_ = emptyLongList();
            floatData_ = emptyFloatList();
            int32Data_ = emptyIntList();
            stringData_ = java.util.Collections.emptyList();
            int64Data_ = emptyLongList();
            name_ = "";
            docString_ = "";
            rawData_ = com.google.protobuf.ByteString.EMPTY;
            externalData_ = java.util.Collections.emptyList();
            dataLocation_ = 0;
            doubleData_ = emptyDoubleList();
            uint64Data_ = emptyLongList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new TensorProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private TensorProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 8: {
                            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                                dims_ = newLongList();
                                mutable_bitField0_ |= 0x00000001;
                            }
                            dims_.addLong(input.readInt64());
                            break;
                        }
                        case 10: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000001) != 0) && input.getBytesUntilLimit() > 0) {
                                dims_ = newLongList();
                                mutable_bitField0_ |= 0x00000001;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                dims_.addLong(input.readInt64());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 16: {
                            bitField0_ |= 0x00000001;
                            dataType_ = input.readInt32();
                            break;
                        }
                        case 26: {
                            ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000002) != 0)) {
                                subBuilder = segment_.toBuilder();
                            }
                            segment_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.Segment.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(segment_);
                                segment_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000002;
                            break;
                        }
                        case 37: {
                            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                                floatData_ = newFloatList();
                                mutable_bitField0_ |= 0x00000008;
                            }
                            floatData_.addFloat(input.readFloat());
                            break;
                        }
                        case 34: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000008) != 0) && input.getBytesUntilLimit() > 0) {
                                floatData_ = newFloatList();
                                mutable_bitField0_ |= 0x00000008;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                floatData_.addFloat(input.readFloat());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 40: {
                            if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                                int32Data_ = newIntList();
                                mutable_bitField0_ |= 0x00000010;
                            }
                            int32Data_.addInt(input.readInt32());
                            break;
                        }
                        case 42: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000010) != 0) && input.getBytesUntilLimit() > 0) {
                                int32Data_ = newIntList();
                                mutable_bitField0_ |= 0x00000010;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                int32Data_.addInt(input.readInt32());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 50: {
                            if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                                stringData_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
                                mutable_bitField0_ |= 0x00000020;
                            }
                            stringData_.add(input.readBytes());
                            break;
                        }
                        case 56: {
                            if (!((mutable_bitField0_ & 0x00000040) != 0)) {
                                int64Data_ = newLongList();
                                mutable_bitField0_ |= 0x00000040;
                            }
                            int64Data_.addLong(input.readInt64());
                            break;
                        }
                        case 58: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000040) != 0) && input.getBytesUntilLimit() > 0) {
                                int64Data_ = newLongList();
                                mutable_bitField0_ |= 0x00000040;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                int64Data_.addLong(input.readInt64());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 66: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000004;
                            name_ = bs;
                            break;
                        }
                        case 74: {
                            bitField0_ |= 0x00000010;
                            rawData_ = input.readBytes();
                            break;
                        }
                        case 81: {
                            if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                                doubleData_ = newDoubleList();
                                mutable_bitField0_ |= 0x00001000;
                            }
                            doubleData_.addDouble(input.readDouble());
                            break;
                        }
                        case 82: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00001000) != 0) && input.getBytesUntilLimit() > 0) {
                                doubleData_ = newDoubleList();
                                mutable_bitField0_ |= 0x00001000;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                doubleData_.addDouble(input.readDouble());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 88: {
                            if (!((mutable_bitField0_ & 0x00002000) != 0)) {
                                uint64Data_ = newLongList();
                                mutable_bitField0_ |= 0x00002000;
                            }
                            uint64Data_.addLong(input.readUInt64());
                            break;
                        }
                        case 90: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00002000) != 0) && input.getBytesUntilLimit() > 0) {
                                uint64Data_ = newLongList();
                                mutable_bitField0_ |= 0x00002000;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                uint64Data_.addLong(input.readUInt64());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        case 98: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000008;
                            docString_ = bs;
                            break;
                        }
                        case 106: {
                            if (!((mutable_bitField0_ & 0x00000400) != 0)) {
                                externalData_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>();
                                mutable_bitField0_ |= 0x00000400;
                            }
                            externalData_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.StringStringEntryProto.PARSER, extensionRegistry));
                            break;
                        }
                        case 112: {
                            int rawValue = input.readEnum();
                            @SuppressWarnings("deprecation")
                            ai.onnx.proto.OnnxMl.TensorProto.DataLocation value = ai.onnx.proto.OnnxMl.TensorProto.DataLocation.valueOf(rawValue);
                            if (value == null) {
                                unknownFields.mergeVarintField(14, rawValue);
                            } else {
                                bitField0_ |= 0x00000020;
                                dataLocation_ = rawValue;
                            }
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000001) != 0)) {
                    dims_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00000008) != 0)) {
                    floatData_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00000010) != 0)) {
                    int32Data_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00000020) != 0)) {
                    stringData_ = java.util.Collections.unmodifiableList(stringData_); // C
                }
                if (((mutable_bitField0_ & 0x00000040) != 0)) {
                    int64Data_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00001000) != 0)) {
                    doubleData_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00002000) != 0)) {
                    uint64Data_.makeImmutable(); // C
                }
                if (((mutable_bitField0_ & 0x00000400) != 0)) {
                    externalData_ = java.util.Collections.unmodifiableList(externalData_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.TensorProto.class, ai.onnx.proto.OnnxMl.TensorProto.Builder.class);
        }

        /**
         * Protobuf enum {@code onnx.TensorProto.DataType}
         */
        public enum DataType
                implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>UNDEFINED = 0;</code>
             */
            UNDEFINED(0),
            /**
             * <pre>
             * Basic types.
             * </pre>
             *
             * <code>FLOAT = 1;</code>
             */
            FLOAT(1),
            /**
             * <pre>
             * uint8_t
             * </pre>
             *
             * <code>UINT8 = 2;</code>
             */
            UINT8(2),
            /**
             * <pre>
             * int8_t
             * </pre>
             *
             * <code>INT8 = 3;</code>
             */
            INT8(3),
            /**
             * <pre>
             * uint16_t
             * </pre>
             *
             * <code>UINT16 = 4;</code>
             */
            UINT16(4),
            /**
             * <pre>
             * int16_t
             * </pre>
             *
             * <code>INT16 = 5;</code>
             */
            INT16(5),
            /**
             * <pre>
             * int32_t
             * </pre>
             *
             * <code>INT32 = 6;</code>
             */
            INT32(6),
            /**
             * <pre>
             * int64_t
             * </pre>
             *
             * <code>INT64 = 7;</code>
             */
            INT64(7),
            /**
             * <pre>
             * string
             * </pre>
             *
             * <code>STRING = 8;</code>
             */
            STRING(8),
            /**
             * <pre>
             * bool
             * </pre>
             *
             * <code>BOOL = 9;</code>
             */
            BOOL(9),
            /**
             * <pre>
             * IEEE754 half-precision floating-point format (16 bits wide).
             * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
             * </pre>
             *
             * <code>FLOAT16 = 10;</code>
             */
            FLOAT16(10),
            /**
             * <code>DOUBLE = 11;</code>
             */
            DOUBLE(11),
            /**
             * <code>UINT32 = 12;</code>
             */
            UINT32(12),
            /**
             * <code>UINT64 = 13;</code>
             */
            UINT64(13),
            /**
             * <pre>
             * complex with float32 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX64 = 14;</code>
             */
            COMPLEX64(14),
            /**
             * <pre>
             * complex with float64 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX128 = 15;</code>
             */
            COMPLEX128(15),
            /**
             * <pre>
             * Non-IEEE floating-point format based on IEEE754 single-precision
             * floating-point number truncated to 16 bits.
             * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
             * </pre>
             *
             * <code>BFLOAT16 = 16;</code>
             */
            BFLOAT16(16),
            ;

            /**
             * <code>UNDEFINED = 0;</code>
             */
            public static final int UNDEFINED_VALUE = 0;
            /**
             * <pre>
             * Basic types.
             * </pre>
             *
             * <code>FLOAT = 1;</code>
             */
            public static final int FLOAT_VALUE = 1;
            /**
             * <pre>
             * uint8_t
             * </pre>
             *
             * <code>UINT8 = 2;</code>
             */
            public static final int UINT8_VALUE = 2;
            /**
             * <pre>
             * int8_t
             * </pre>
             *
             * <code>INT8 = 3;</code>
             */
            public static final int INT8_VALUE = 3;
            /**
             * <pre>
             * uint16_t
             * </pre>
             *
             * <code>UINT16 = 4;</code>
             */
            public static final int UINT16_VALUE = 4;
            /**
             * <pre>
             * int16_t
             * </pre>
             *
             * <code>INT16 = 5;</code>
             */
            public static final int INT16_VALUE = 5;
            /**
             * <pre>
             * int32_t
             * </pre>
             *
             * <code>INT32 = 6;</code>
             */
            public static final int INT32_VALUE = 6;
            /**
             * <pre>
             * int64_t
             * </pre>
             *
             * <code>INT64 = 7;</code>
             */
            public static final int INT64_VALUE = 7;
            /**
             * <pre>
             * string
             * </pre>
             *
             * <code>STRING = 8;</code>
             */
            public static final int STRING_VALUE = 8;
            /**
             * <pre>
             * bool
             * </pre>
             *
             * <code>BOOL = 9;</code>
             */
            public static final int BOOL_VALUE = 9;
            /**
             * <pre>
             * IEEE754 half-precision floating-point format (16 bits wide).
             * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
             * </pre>
             *
             * <code>FLOAT16 = 10;</code>
             */
            public static final int FLOAT16_VALUE = 10;
            /**
             * <code>DOUBLE = 11;</code>
             */
            public static final int DOUBLE_VALUE = 11;
            /**
             * <code>UINT32 = 12;</code>
             */
            public static final int UINT32_VALUE = 12;
            /**
             * <code>UINT64 = 13;</code>
             */
            public static final int UINT64_VALUE = 13;
            /**
             * <pre>
             * complex with float32 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX64 = 14;</code>
             */
            public static final int COMPLEX64_VALUE = 14;
            /**
             * <pre>
             * complex with float64 real and imaginary components
             * </pre>
             *
             * <code>COMPLEX128 = 15;</code>
             */
            public static final int COMPLEX128_VALUE = 15;
            /**
             * <pre>
             * Non-IEEE floating-point format based on IEEE754 single-precision
             * floating-point number truncated to 16 bits.
             * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
             * </pre>
             *
             * <code>BFLOAT16 = 16;</code>
             */
            public static final int BFLOAT16_VALUE = 16;


            public final int getNumber() {
                return value;
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static DataType valueOf(int value) {
                return forNumber(value);
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static DataType forNumber(int value) {
                switch (value) {
                    case 0: return UNDEFINED;
                    case 1: return FLOAT;
                    case 2: return UINT8;
                    case 3: return INT8;
                    case 4: return UINT16;
                    case 5: return INT16;
                    case 6: return INT32;
                    case 7: return INT64;
                    case 8: return STRING;
                    case 9: return BOOL;
                    case 10: return FLOAT16;
                    case 11: return DOUBLE;
                    case 12: return UINT32;
                    case 13: return UINT64;
                    case 14: return COMPLEX64;
                    case 15: return COMPLEX128;
                    case 16: return BFLOAT16;
                    default: return null;
                }
            }

            public static com.google.protobuf.Internal.EnumLiteMap<DataType>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                    DataType> internalValueMap =
                    new com.google.protobuf.Internal.EnumLiteMap<DataType>() {
                        public DataType findValueByNumber(int number) {
                            return DataType.forNumber(number);
                        }
                    };

            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.TensorProto.getDescriptor().getEnumTypes().get(0);
            }

            private static final DataType[] VALUES = values();

            public static DataType valueOf(
                    com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                            "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }

            private final int value;

            private DataType(int value) {
                this.value = value;
            }

            // @@protoc_insertion_point(enum_scope:onnx.TensorProto.DataType)
        }

        /**
         * <pre>
         * Location of the data for this tensor. MUST be one of:
         * - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
         * - EXTERNAL - data stored in an external location as described by external_data field.
         * </pre>
         *
         * Protobuf enum {@code onnx.TensorProto.DataLocation}
         */
        public enum DataLocation
                implements com.google.protobuf.ProtocolMessageEnum {
            /**
             * <code>DEFAULT = 0;</code>
             */
            DEFAULT(0),
            /**
             * <code>EXTERNAL = 1;</code>
             */
            EXTERNAL(1),
            ;

            /**
             * <code>DEFAULT = 0;</code>
             */
            public static final int DEFAULT_VALUE = 0;
            /**
             * <code>EXTERNAL = 1;</code>
             */
            public static final int EXTERNAL_VALUE = 1;


            public final int getNumber() {
                return value;
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static DataLocation valueOf(int value) {
                return forNumber(value);
            }

            /**
             * @param value The numeric wire value of the corresponding enum entry.
             * @return The enum associated with the given numeric wire value.
             */
            public static DataLocation forNumber(int value) {
                switch (value) {
                    case 0: return DEFAULT;
                    case 1: return EXTERNAL;
                    default: return null;
                }
            }

            public static com.google.protobuf.Internal.EnumLiteMap<DataLocation>
            internalGetValueMap() {
                return internalValueMap;
            }
            private static final com.google.protobuf.Internal.EnumLiteMap<
                    DataLocation> internalValueMap =
                    new com.google.protobuf.Internal.EnumLiteMap<DataLocation>() {
                        public DataLocation findValueByNumber(int number) {
                            return DataLocation.forNumber(number);
                        }
                    };

            public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
                return getDescriptor().getValues().get(ordinal());
            }
            public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
                return getDescriptor();
            }
            public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.TensorProto.getDescriptor().getEnumTypes().get(1);
            }

            private static final DataLocation[] VALUES = values();

            public static DataLocation valueOf(
                    com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
                if (desc.getType() != getDescriptor()) {
                    throw new java.lang.IllegalArgumentException(
                            "EnumValueDescriptor is not for this type.");
                }
                return VALUES[desc.getIndex()];
            }

            private final int value;

            private DataLocation(int value) {
                this.value = value;
            }

            // @@protoc_insertion_point(enum_scope:onnx.TensorProto.DataLocation)
        }

        public interface SegmentOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TensorProto.Segment)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <code>optional int64 begin = 1;</code>
             * @return Whether the begin field is set.
             */
            boolean hasBegin();
            /**
             * <code>optional int64 begin = 1;</code>
             * @return The begin.
             */
            long getBegin();

            /**
             * <code>optional int64 end = 2;</code>
             * @return Whether the end field is set.
             */
            boolean hasEnd();
            /**
             * <code>optional int64 end = 2;</code>
             * @return The end.
             */
            long getEnd();
        }
        /**
         * <pre>
         * For very large tensors, we may want to store them in chunks, in which
         * case the following fields will specify the segment that is stored in
         * the current TensorProto.
         * </pre>
         *
         * Protobuf type {@code onnx.TensorProto.Segment}
         */
        public static final class Segment extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TensorProto.Segment)
                SegmentOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Segment.newBuilder() to construct.
            private Segment(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Segment() {
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Segment();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Segment(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                bitField0_ |= 0x00000001;
                                begin_ = input.readInt64();
                                break;
                            }
                            case 16: {
                                bitField0_ |= 0x00000002;
                                end_ = input.readInt64();
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TensorProto.Segment.class, ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder.class);
            }

            private int bitField0_;
            public static final int BEGIN_FIELD_NUMBER = 1;
            private long begin_;
            /**
             * <code>optional int64 begin = 1;</code>
             * @return Whether the begin field is set.
             */
            @java.lang.Override
            public boolean hasBegin() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional int64 begin = 1;</code>
             * @return The begin.
             */
            @java.lang.Override
            public long getBegin() {
                return begin_;
            }

            public static final int END_FIELD_NUMBER = 2;
            private long end_;
            /**
             * <code>optional int64 end = 2;</code>
             * @return Whether the end field is set.
             */
            @java.lang.Override
            public boolean hasEnd() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional int64 end = 2;</code>
             * @return The end.
             */
            @java.lang.Override
            public long getEnd() {
                return end_;
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt64(1, begin_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeInt64(2, end_);
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt64Size(1, begin_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt64Size(2, end_);
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TensorProto.Segment)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TensorProto.Segment other = (ai.onnx.proto.OnnxMl.TensorProto.Segment) obj;

                if (hasBegin() != other.hasBegin()) return false;
                if (hasBegin()) {
                    if (getBegin()
                            != other.getBegin()) return false;
                }
                if (hasEnd() != other.hasEnd()) return false;
                if (hasEnd()) {
                    if (getEnd()
                            != other.getEnd()) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasBegin()) {
                    hash = (37 * hash) + BEGIN_FIELD_NUMBER;
                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                            getBegin());
                }
                if (hasEnd()) {
                    hash = (37 * hash) + END_FIELD_NUMBER;
                    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                            getEnd());
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorProto.Segment parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TensorProto.Segment prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * For very large tensors, we may want to store them in chunks, in which
             * case the following fields will specify the segment that is stored in
             * the current TensorProto.
             * </pre>
             *
             * Protobuf type {@code onnx.TensorProto.Segment}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TensorProto.Segment)
                    ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TensorProto.Segment.class, ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TensorProto.Segment.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    begin_ = 0L;
                    bitField0_ = (bitField0_ & ~0x00000001);
                    end_ = 0L;
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_Segment_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorProto.Segment getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorProto.Segment build() {
                    ai.onnx.proto.OnnxMl.TensorProto.Segment result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorProto.Segment buildPartial() {
                    ai.onnx.proto.OnnxMl.TensorProto.Segment result = new ai.onnx.proto.OnnxMl.TensorProto.Segment(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.begin_ = begin_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        result.end_ = end_;
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TensorProto.Segment) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TensorProto.Segment)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TensorProto.Segment other) {
                    if (other == ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance()) return this;
                    if (other.hasBegin()) {
                        setBegin(other.getBegin());
                    }
                    if (other.hasEnd()) {
                        setEnd(other.getEnd());
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TensorProto.Segment parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TensorProto.Segment) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private long begin_ ;
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return Whether the begin field is set.
                 */
                @java.lang.Override
                public boolean hasBegin() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return The begin.
                 */
                @java.lang.Override
                public long getBegin() {
                    return begin_;
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @param value The begin to set.
                 * @return This builder for chaining.
                 */
                public Builder setBegin(long value) {
                    bitField0_ |= 0x00000001;
                    begin_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional int64 begin = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearBegin() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    begin_ = 0L;
                    onChanged();
                    return this;
                }

                private long end_ ;
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return Whether the end field is set.
                 */
                @java.lang.Override
                public boolean hasEnd() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return The end.
                 */
                @java.lang.Override
                public long getEnd() {
                    return end_;
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @param value The end to set.
                 * @return This builder for chaining.
                 */
                public Builder setEnd(long value) {
                    bitField0_ |= 0x00000002;
                    end_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <code>optional int64 end = 2;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearEnd() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    end_ = 0L;
                    onChanged();
                    return this;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TensorProto.Segment)
            }

            // @@protoc_insertion_point(class_scope:onnx.TensorProto.Segment)
            private static final ai.onnx.proto.OnnxMl.TensorProto.Segment DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TensorProto.Segment();
            }

            public static ai.onnx.proto.OnnxMl.TensorProto.Segment getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Segment>
                    PARSER = new com.google.protobuf.AbstractParser<Segment>() {
                @java.lang.Override
                public Segment parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Segment(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Segment> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Segment> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorProto.Segment getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        private int bitField0_;
        public static final int DIMS_FIELD_NUMBER = 1;
        private com.google.protobuf.Internal.LongList dims_;
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return A list containing the dims.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getDimsList() {
            return dims_;
        }
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @return The count of dims.
         */
        public int getDimsCount() {
            return dims_.size();
        }
        /**
         * <pre>
         * The shape of the tensor.
         * </pre>
         *
         * <code>repeated int64 dims = 1;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        public long getDims(int index) {
            return dims_.getLong(index);
        }

        public static final int DATA_TYPE_FIELD_NUMBER = 2;
        private int dataType_;
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return Whether the dataType field is set.
         */
        @java.lang.Override
        public boolean hasDataType() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The data type of the tensor.
         * This field MUST have a valid TensorProto.DataType value
         * </pre>
         *
         * <code>optional int32 data_type = 2;</code>
         * @return The dataType.
         */
        @java.lang.Override
        public int getDataType() {
            return dataType_;
        }

        public static final int SEGMENT_FIELD_NUMBER = 3;
        private ai.onnx.proto.OnnxMl.TensorProto.Segment segment_;
        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         * @return Whether the segment field is set.
         */
        @java.lang.Override
        public boolean hasSegment() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         * @return The segment.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto.Segment getSegment() {
            return segment_ == null ? ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;
        }
        /**
         * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
            return segment_ == null ? ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;
        }

        public static final int FLOAT_DATA_FIELD_NUMBER = 4;
        private com.google.protobuf.Internal.FloatList floatData_;
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return A list containing the floatData.
         */
        @java.lang.Override
        public java.util.List<java.lang.Float>
        getFloatDataList() {
            return floatData_;
        }
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @return The count of floatData.
         */
        public int getFloatDataCount() {
            return floatData_.size();
        }
        /**
         * <pre>
         * For float and complex64 values
         * Complex64 tensors are encoded as a single array of floats,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
         * </pre>
         *
         * <code>repeated float float_data = 4 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The floatData at the given index.
         */
        public float getFloatData(int index) {
            return floatData_.getFloat(index);
        }
        private int floatDataMemoizedSerializedSize = -1;

        public static final int INT32_DATA_FIELD_NUMBER = 5;
        private com.google.protobuf.Internal.IntList int32Data_;
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return A list containing the int32Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
        getInt32DataList() {
            return int32Data_;
        }
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @return The count of int32Data.
         */
        public int getInt32DataCount() {
            return int32Data_.size();
        }
        /**
         * <pre>
         * For int32, uint8, int8, uint16, int16, bool, and float16 values
         * float16 values must be bit-wise converted to an uint16_t prior
         * to writing to the buffer.
         * When this field is present, the data_type field MUST be
         * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
         * </pre>
         *
         * <code>repeated int32 int32_data = 5 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int32Data at the given index.
         */
        public int getInt32Data(int index) {
            return int32Data_.getInt(index);
        }
        private int int32DataMemoizedSerializedSize = -1;

        public static final int STRING_DATA_FIELD_NUMBER = 6;
        private java.util.List<com.google.protobuf.ByteString> stringData_;
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return A list containing the stringData.
         */
        @java.lang.Override
        public java.util.List<com.google.protobuf.ByteString>
        getStringDataList() {
            return stringData_;
        }
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @return The count of stringData.
         */
        public int getStringDataCount() {
            return stringData_.size();
        }
        /**
         * <pre>
         * For strings.
         * Each element of string_data is a UTF-8 encoded Unicode
         * string. No trailing null, no leading BOM. The protobuf "string"
         * scalar type is not used to match ML community conventions.
         * When this field is present, the data_type field MUST be STRING
         * </pre>
         *
         * <code>repeated bytes string_data = 6;</code>
         * @param index The index of the element to return.
         * @return The stringData at the given index.
         */
        public com.google.protobuf.ByteString getStringData(int index) {
            return stringData_.get(index);
        }

        public static final int INT64_DATA_FIELD_NUMBER = 7;
        private com.google.protobuf.Internal.LongList int64Data_;
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return A list containing the int64Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getInt64DataList() {
            return int64Data_;
        }
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @return The count of int64Data.
         */
        public int getInt64DataCount() {
            return int64Data_.size();
        }
        /**
         * <pre>
         * For int64.
         * When this field is present, the data_type field MUST be INT64
         * </pre>
         *
         * <code>repeated int64 int64_data = 7 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The int64Data at the given index.
         */
        public long getInt64Data(int index) {
            return int64Data_.getLong(index);
        }
        private int int64DataMemoizedSerializedSize = -1;

        public static final int NAME_FIELD_NUMBER = 8;
        private volatile java.lang.Object name_;
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return Whether the name field is set.
         */
        @java.lang.Override
        public boolean hasName() {
            return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The name.
         */
        @java.lang.Override
        public java.lang.String getName() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    name_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * Optionally, a name for the tensor.
         * </pre>
         *
         * <code>optional string name = 8;</code>
         * @return The bytes for name.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getNameBytes() {
            java.lang.Object ref = name_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                name_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int DOC_STRING_FIELD_NUMBER = 12;
        private volatile java.lang.Object docString_;
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return Whether the docString field is set.
         */
        @java.lang.Override
        public boolean hasDocString() {
            return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The docString.
         */
        @java.lang.Override
        public java.lang.String getDocString() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    docString_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * A human-readable documentation for this tensor. Markdown is allowed.
         * </pre>
         *
         * <code>optional string doc_string = 12;</code>
         * @return The bytes for docString.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDocStringBytes() {
            java.lang.Object ref = docString_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                docString_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int RAW_DATA_FIELD_NUMBER = 9;
        private com.google.protobuf.ByteString rawData_;
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return Whether the rawData field is set.
         */
        @java.lang.Override
        public boolean hasRawData() {
            return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Serializations can either use one of the fields above, or use this
         * raw bytes field. The only exception is the string case, where one is
         * required to store the content in the repeated bytes string_data field.
         * When this raw_data field is used to store tensor value, elements MUST
         * be stored in as fixed-width, little-endian order.
         * Floating-point data types MUST be stored in IEEE 754 format.
         * Complex64 elements must be written as two consecutive FLOAT values, real component first.
         * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
         * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
         * Note: the advantage of specific field rather than the raw_data field is
         * that in some cases (e.g. int data), protobuf does a better packing via
         * variable length storage, and may lead to smaller binary footprint.
         * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
         * </pre>
         *
         * <code>optional bytes raw_data = 9;</code>
         * @return The rawData.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getRawData() {
            return rawData_;
        }

        public static final int EXTERNAL_DATA_FIELD_NUMBER = 13;
        private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> externalData_;
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getExternalDataList() {
            return externalData_;
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
        getExternalDataOrBuilderList() {
            return externalData_;
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public int getExternalDataCount() {
            return externalData_.size();
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProto getExternalData(int index) {
            return externalData_.get(index);
        }
        /**
         * <pre>
         * Data can be stored inside the protobuf file using type-specific fields or raw_data.
         * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
         * external_data stores key-value pairs describing data location. Recognized keys are:
         * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
         *                           protobuf model was stored
         * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
         *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
         * - "length" (optional) - number of bytes containing data. Integer stored as string.
         * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
         * </pre>
         *
         * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
                int index) {
            return externalData_.get(index);
        }

        public static final int DATA_LOCATION_FIELD_NUMBER = 14;
        private int dataLocation_;
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return Whether the dataLocation field is set.
         */
        @java.lang.Override public boolean hasDataLocation() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
         * </pre>
         *
         * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
         * @return The dataLocation.
         */
        @java.lang.Override public ai.onnx.proto.OnnxMl.TensorProto.DataLocation getDataLocation() {
            @SuppressWarnings("deprecation")
            ai.onnx.proto.OnnxMl.TensorProto.DataLocation result = ai.onnx.proto.OnnxMl.TensorProto.DataLocation.valueOf(dataLocation_);
            return result == null ? ai.onnx.proto.OnnxMl.TensorProto.DataLocation.DEFAULT : result;
        }

        public static final int DOUBLE_DATA_FIELD_NUMBER = 10;
        private com.google.protobuf.Internal.DoubleList doubleData_;
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return A list containing the doubleData.
         */
        @java.lang.Override
        public java.util.List<java.lang.Double>
        getDoubleDataList() {
            return doubleData_;
        }
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @return The count of doubleData.
         */
        public int getDoubleDataCount() {
            return doubleData_.size();
        }
        /**
         * <pre>
         * For double
         * Complex128 tensors are encoded as a single array of doubles,
         * with the real components appearing in odd numbered positions,
         * and the corresponding imaginary component appearing in the
         * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
         * is encoded as [1.0, 2.0 ,3.0 ,4.0]
         * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
         * </pre>
         *
         * <code>repeated double double_data = 10 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The doubleData at the given index.
         */
        public double getDoubleData(int index) {
            return doubleData_.getDouble(index);
        }
        private int doubleDataMemoizedSerializedSize = -1;

        public static final int UINT64_DATA_FIELD_NUMBER = 11;
        private com.google.protobuf.Internal.LongList uint64Data_;
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return A list containing the uint64Data.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getUint64DataList() {
            return uint64Data_;
        }
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @return The count of uint64Data.
         */
        public int getUint64DataCount() {
            return uint64Data_.size();
        }
        /**
         * <pre>
         * For uint64 and uint32 values
         * When this field is present, the data_type field MUST be
         * UINT32 or UINT64
         * </pre>
         *
         * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The uint64Data at the given index.
         */
        public long getUint64Data(int index) {
            return uint64Data_.getLong(index);
        }
        private int uint64DataMemoizedSerializedSize = -1;

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            getSerializedSize();
            for (int i = 0; i < dims_.size(); i++) {
                output.writeInt64(1, dims_.getLong(i));
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeInt32(2, dataType_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(3, getSegment());
            }
            if (getFloatDataList().size() > 0) {
                output.writeUInt32NoTag(34);
                output.writeUInt32NoTag(floatDataMemoizedSerializedSize);
            }
            for (int i = 0; i < floatData_.size(); i++) {
                output.writeFloatNoTag(floatData_.getFloat(i));
            }
            if (getInt32DataList().size() > 0) {
                output.writeUInt32NoTag(42);
                output.writeUInt32NoTag(int32DataMemoizedSerializedSize);
            }
            for (int i = 0; i < int32Data_.size(); i++) {
                output.writeInt32NoTag(int32Data_.getInt(i));
            }
            for (int i = 0; i < stringData_.size(); i++) {
                output.writeBytes(6, stringData_.get(i));
            }
            if (getInt64DataList().size() > 0) {
                output.writeUInt32NoTag(58);
                output.writeUInt32NoTag(int64DataMemoizedSerializedSize);
            }
            for (int i = 0; i < int64Data_.size(); i++) {
                output.writeInt64NoTag(int64Data_.getLong(i));
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 8, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                output.writeBytes(9, rawData_);
            }
            if (getDoubleDataList().size() > 0) {
                output.writeUInt32NoTag(82);
                output.writeUInt32NoTag(doubleDataMemoizedSerializedSize);
            }
            for (int i = 0; i < doubleData_.size(); i++) {
                output.writeDoubleNoTag(doubleData_.getDouble(i));
            }
            if (getUint64DataList().size() > 0) {
                output.writeUInt32NoTag(90);
                output.writeUInt32NoTag(uint64DataMemoizedSerializedSize);
            }
            for (int i = 0; i < uint64Data_.size(); i++) {
                output.writeUInt64NoTag(uint64Data_.getLong(i));
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 12, docString_);
            }
            for (int i = 0; i < externalData_.size(); i++) {
                output.writeMessage(13, externalData_.get(i));
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                output.writeEnum(14, dataLocation_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            {
                int dataSize = 0;
                for (int i = 0; i < dims_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeInt64SizeNoTag(dims_.getLong(i));
                }
                size += dataSize;
                size += 1 * getDimsList().size();
            }
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeInt32Size(2, dataType_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(3, getSegment());
            }
            {
                int dataSize = 0;
                dataSize = 4 * getFloatDataList().size();
                size += dataSize;
                if (!getFloatDataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(dataSize);
                }
                floatDataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < int32Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(int32Data_.getInt(i));
                }
                size += dataSize;
                if (!getInt32DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(dataSize);
                }
                int32DataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < stringData_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeBytesSizeNoTag(stringData_.get(i));
                }
                size += dataSize;
                size += 1 * getStringDataList().size();
            }
            {
                int dataSize = 0;
                for (int i = 0; i < int64Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeInt64SizeNoTag(int64Data_.getLong(i));
                }
                size += dataSize;
                if (!getInt64DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(dataSize);
                }
                int64DataMemoizedSerializedSize = dataSize;
            }
            if (((bitField0_ & 0x00000004) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, name_);
            }
            if (((bitField0_ & 0x00000010) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeBytesSize(9, rawData_);
            }
            {
                int dataSize = 0;
                dataSize = 8 * getDoubleDataList().size();
                size += dataSize;
                if (!getDoubleDataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(dataSize);
                }
                doubleDataMemoizedSerializedSize = dataSize;
            }
            {
                int dataSize = 0;
                for (int i = 0; i < uint64Data_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeUInt64SizeNoTag(uint64Data_.getLong(i));
                }
                size += dataSize;
                if (!getUint64DataList().isEmpty()) {
                    size += 1;
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32SizeNoTag(dataSize);
                }
                uint64DataMemoizedSerializedSize = dataSize;
            }
            if (((bitField0_ & 0x00000008) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, docString_);
            }
            for (int i = 0; i < externalData_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(13, externalData_.get(i));
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeEnumSize(14, dataLocation_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.TensorProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.TensorProto other = (ai.onnx.proto.OnnxMl.TensorProto) obj;

            if (!getDimsList()
                    .equals(other.getDimsList())) return false;
            if (hasDataType() != other.hasDataType()) return false;
            if (hasDataType()) {
                if (getDataType()
                        != other.getDataType()) return false;
            }
            if (hasSegment() != other.hasSegment()) return false;
            if (hasSegment()) {
                if (!getSegment()
                        .equals(other.getSegment())) return false;
            }
            if (!getFloatDataList()
                    .equals(other.getFloatDataList())) return false;
            if (!getInt32DataList()
                    .equals(other.getInt32DataList())) return false;
            if (!getStringDataList()
                    .equals(other.getStringDataList())) return false;
            if (!getInt64DataList()
                    .equals(other.getInt64DataList())) return false;
            if (hasName() != other.hasName()) return false;
            if (hasName()) {
                if (!getName()
                        .equals(other.getName())) return false;
            }
            if (hasDocString() != other.hasDocString()) return false;
            if (hasDocString()) {
                if (!getDocString()
                        .equals(other.getDocString())) return false;
            }
            if (hasRawData() != other.hasRawData()) return false;
            if (hasRawData()) {
                if (!getRawData()
                        .equals(other.getRawData())) return false;
            }
            if (!getExternalDataList()
                    .equals(other.getExternalDataList())) return false;
            if (hasDataLocation() != other.hasDataLocation()) return false;
            if (hasDataLocation()) {
                if (dataLocation_ != other.dataLocation_) return false;
            }
            if (!getDoubleDataList()
                    .equals(other.getDoubleDataList())) return false;
            if (!getUint64DataList()
                    .equals(other.getUint64DataList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getDimsCount() > 0) {
                hash = (37 * hash) + DIMS_FIELD_NUMBER;
                hash = (53 * hash) + getDimsList().hashCode();
            }
            if (hasDataType()) {
                hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER;
                hash = (53 * hash) + getDataType();
            }
            if (hasSegment()) {
                hash = (37 * hash) + SEGMENT_FIELD_NUMBER;
                hash = (53 * hash) + getSegment().hashCode();
            }
            if (getFloatDataCount() > 0) {
                hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getFloatDataList().hashCode();
            }
            if (getInt32DataCount() > 0) {
                hash = (37 * hash) + INT32_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getInt32DataList().hashCode();
            }
            if (getStringDataCount() > 0) {
                hash = (37 * hash) + STRING_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getStringDataList().hashCode();
            }
            if (getInt64DataCount() > 0) {
                hash = (37 * hash) + INT64_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getInt64DataList().hashCode();
            }
            if (hasName()) {
                hash = (37 * hash) + NAME_FIELD_NUMBER;
                hash = (53 * hash) + getName().hashCode();
            }
            if (hasDocString()) {
                hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
                hash = (53 * hash) + getDocString().hashCode();
            }
            if (hasRawData()) {
                hash = (37 * hash) + RAW_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getRawData().hashCode();
            }
            if (getExternalDataCount() > 0) {
                hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getExternalDataList().hashCode();
            }
            if (hasDataLocation()) {
                hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER;
                hash = (53 * hash) + dataLocation_;
            }
            if (getDoubleDataCount() > 0) {
                hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getDoubleDataList().hashCode();
            }
            if (getUint64DataCount() > 0) {
                hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER;
                hash = (53 * hash) + getUint64DataList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.TensorProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Tensors
         * A serialized tensor value.
         * </pre>
         *
         * Protobuf type {@code onnx.TensorProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.TensorProto)
                ai.onnx.proto.OnnxMl.TensorProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TensorProto.class, ai.onnx.proto.OnnxMl.TensorProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.TensorProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getSegmentFieldBuilder();
                    getExternalDataFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000001);
                dataType_ = 0;
                bitField0_ = (bitField0_ & ~0x00000002);
                if (segmentBuilder_ == null) {
                    segment_ = null;
                } else {
                    segmentBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000004);
                floatData_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000008);
                int32Data_ = emptyIntList();
                bitField0_ = (bitField0_ & ~0x00000010);
                stringData_ = java.util.Collections.emptyList();
                bitField0_ = (bitField0_ & ~0x00000020);
                int64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000040);
                name_ = "";
                bitField0_ = (bitField0_ & ~0x00000080);
                docString_ = "";
                bitField0_ = (bitField0_ & ~0x00000100);
                rawData_ = com.google.protobuf.ByteString.EMPTY;
                bitField0_ = (bitField0_ & ~0x00000200);
                if (externalDataBuilder_ == null) {
                    externalData_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000400);
                } else {
                    externalDataBuilder_.clear();
                }
                dataLocation_ = 0;
                bitField0_ = (bitField0_ & ~0x00000800);
                doubleData_ = emptyDoubleList();
                bitField0_ = (bitField0_ & ~0x00001000);
                uint64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00002000);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorProto build() {
                ai.onnx.proto.OnnxMl.TensorProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorProto buildPartial() {
                ai.onnx.proto.OnnxMl.TensorProto result = new ai.onnx.proto.OnnxMl.TensorProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    dims_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000001);
                }
                result.dims_ = dims_;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.dataType_ = dataType_;
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000004) != 0)) {
                    if (segmentBuilder_ == null) {
                        result.segment_ = segment_;
                    } else {
                        result.segment_ = segmentBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000002;
                }
                if (((bitField0_ & 0x00000008) != 0)) {
                    floatData_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000008);
                }
                result.floatData_ = floatData_;
                if (((bitField0_ & 0x00000010) != 0)) {
                    int32Data_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000010);
                }
                result.int32Data_ = int32Data_;
                if (((bitField0_ & 0x00000020) != 0)) {
                    stringData_ = java.util.Collections.unmodifiableList(stringData_);
                    bitField0_ = (bitField0_ & ~0x00000020);
                }
                result.stringData_ = stringData_;
                if (((bitField0_ & 0x00000040) != 0)) {
                    int64Data_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000040);
                }
                result.int64Data_ = int64Data_;
                if (((from_bitField0_ & 0x00000080) != 0)) {
                    to_bitField0_ |= 0x00000004;
                }
                result.name_ = name_;
                if (((from_bitField0_ & 0x00000100) != 0)) {
                    to_bitField0_ |= 0x00000008;
                }
                result.docString_ = docString_;
                if (((from_bitField0_ & 0x00000200) != 0)) {
                    to_bitField0_ |= 0x00000010;
                }
                result.rawData_ = rawData_;
                if (externalDataBuilder_ == null) {
                    if (((bitField0_ & 0x00000400) != 0)) {
                        externalData_ = java.util.Collections.unmodifiableList(externalData_);
                        bitField0_ = (bitField0_ & ~0x00000400);
                    }
                    result.externalData_ = externalData_;
                } else {
                    result.externalData_ = externalDataBuilder_.build();
                }
                if (((from_bitField0_ & 0x00000800) != 0)) {
                    to_bitField0_ |= 0x00000020;
                }
                result.dataLocation_ = dataLocation_;
                if (((bitField0_ & 0x00001000) != 0)) {
                    doubleData_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00001000);
                }
                result.doubleData_ = doubleData_;
                if (((bitField0_ & 0x00002000) != 0)) {
                    uint64Data_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00002000);
                }
                result.uint64Data_ = uint64Data_;
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.TensorProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.TensorProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.TensorProto other) {
                if (other == ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance()) return this;
                if (!other.dims_.isEmpty()) {
                    if (dims_.isEmpty()) {
                        dims_ = other.dims_;
                        bitField0_ = (bitField0_ & ~0x00000001);
                    } else {
                        ensureDimsIsMutable();
                        dims_.addAll(other.dims_);
                    }
                    onChanged();
                }
                if (other.hasDataType()) {
                    setDataType(other.getDataType());
                }
                if (other.hasSegment()) {
                    mergeSegment(other.getSegment());
                }
                if (!other.floatData_.isEmpty()) {
                    if (floatData_.isEmpty()) {
                        floatData_ = other.floatData_;
                        bitField0_ = (bitField0_ & ~0x00000008);
                    } else {
                        ensureFloatDataIsMutable();
                        floatData_.addAll(other.floatData_);
                    }
                    onChanged();
                }
                if (!other.int32Data_.isEmpty()) {
                    if (int32Data_.isEmpty()) {
                        int32Data_ = other.int32Data_;
                        bitField0_ = (bitField0_ & ~0x00000010);
                    } else {
                        ensureInt32DataIsMutable();
                        int32Data_.addAll(other.int32Data_);
                    }
                    onChanged();
                }
                if (!other.stringData_.isEmpty()) {
                    if (stringData_.isEmpty()) {
                        stringData_ = other.stringData_;
                        bitField0_ = (bitField0_ & ~0x00000020);
                    } else {
                        ensureStringDataIsMutable();
                        stringData_.addAll(other.stringData_);
                    }
                    onChanged();
                }
                if (!other.int64Data_.isEmpty()) {
                    if (int64Data_.isEmpty()) {
                        int64Data_ = other.int64Data_;
                        bitField0_ = (bitField0_ & ~0x00000040);
                    } else {
                        ensureInt64DataIsMutable();
                        int64Data_.addAll(other.int64Data_);
                    }
                    onChanged();
                }
                if (other.hasName()) {
                    bitField0_ |= 0x00000080;
                    name_ = other.name_;
                    onChanged();
                }
                if (other.hasDocString()) {
                    bitField0_ |= 0x00000100;
                    docString_ = other.docString_;
                    onChanged();
                }
                if (other.hasRawData()) {
                    setRawData(other.getRawData());
                }
                if (externalDataBuilder_ == null) {
                    if (!other.externalData_.isEmpty()) {
                        if (externalData_.isEmpty()) {
                            externalData_ = other.externalData_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                        } else {
                            ensureExternalDataIsMutable();
                            externalData_.addAll(other.externalData_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.externalData_.isEmpty()) {
                        if (externalDataBuilder_.isEmpty()) {
                            externalDataBuilder_.dispose();
                            externalDataBuilder_ = null;
                            externalData_ = other.externalData_;
                            bitField0_ = (bitField0_ & ~0x00000400);
                            externalDataBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getExternalDataFieldBuilder() : null;
                        } else {
                            externalDataBuilder_.addAllMessages(other.externalData_);
                        }
                    }
                }
                if (other.hasDataLocation()) {
                    setDataLocation(other.getDataLocation());
                }
                if (!other.doubleData_.isEmpty()) {
                    if (doubleData_.isEmpty()) {
                        doubleData_ = other.doubleData_;
                        bitField0_ = (bitField0_ & ~0x00001000);
                    } else {
                        ensureDoubleDataIsMutable();
                        doubleData_.addAll(other.doubleData_);
                    }
                    onChanged();
                }
                if (!other.uint64Data_.isEmpty()) {
                    if (uint64Data_.isEmpty()) {
                        uint64Data_ = other.uint64Data_;
                        bitField0_ = (bitField0_ & ~0x00002000);
                    } else {
                        ensureUint64DataIsMutable();
                        uint64Data_.addAll(other.uint64Data_);
                    }
                    onChanged();
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.TensorProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.TensorProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
            private void ensureDimsIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    dims_ = mutableCopy(dims_);
                    bitField0_ |= 0x00000001;
                }
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return A list containing the dims.
             */
            public java.util.List<java.lang.Long>
            getDimsList() {
                return ((bitField0_ & 0x00000001) != 0) ?
                        java.util.Collections.unmodifiableList(dims_) : dims_;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return The count of dims.
             */
            public int getDimsCount() {
                return dims_.size();
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param index The index of the element to return.
             * @return The dims at the given index.
             */
            public long getDims(int index) {
                return dims_.getLong(index);
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param index The index to set the value at.
             * @param value The dims to set.
             * @return This builder for chaining.
             */
            public Builder setDims(
                    int index, long value) {
                ensureDimsIsMutable();
                dims_.setLong(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param value The dims to add.
             * @return This builder for chaining.
             */
            public Builder addDims(long value) {
                ensureDimsIsMutable();
                dims_.addLong(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @param values The dims to add.
             * @return This builder for chaining.
             */
            public Builder addAllDims(
                    java.lang.Iterable<? extends java.lang.Long> values) {
                ensureDimsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, dims_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the tensor.
             * </pre>
             *
             * <code>repeated int64 dims = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearDims() {
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
                return this;
            }

            private int dataType_ ;
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return Whether the dataType field is set.
             */
            @java.lang.Override
            public boolean hasDataType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return The dataType.
             */
            @java.lang.Override
            public int getDataType() {
                return dataType_;
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @param value The dataType to set.
             * @return This builder for chaining.
             */
            public Builder setDataType(int value) {
                bitField0_ |= 0x00000002;
                dataType_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The data type of the tensor.
             * This field MUST have a valid TensorProto.DataType value
             * </pre>
             *
             * <code>optional int32 data_type = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearDataType() {
                bitField0_ = (bitField0_ & ~0x00000002);
                dataType_ = 0;
                onChanged();
                return this;
            }

            private ai.onnx.proto.OnnxMl.TensorProto.Segment segment_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto.Segment, ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder, ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder> segmentBuilder_;
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             * @return Whether the segment field is set.
             */
            public boolean hasSegment() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             * @return The segment.
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Segment getSegment() {
                if (segmentBuilder_ == null) {
                    return segment_ == null ? ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;
                } else {
                    return segmentBuilder_.getMessage();
                }
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder setSegment(ai.onnx.proto.OnnxMl.TensorProto.Segment value) {
                if (segmentBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    segment_ = value;
                    onChanged();
                } else {
                    segmentBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000004;
                return this;
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder setSegment(
                    ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder builderForValue) {
                if (segmentBuilder_ == null) {
                    segment_ = builderForValue.build();
                    onChanged();
                } else {
                    segmentBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000004;
                return this;
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder mergeSegment(ai.onnx.proto.OnnxMl.TensorProto.Segment value) {
                if (segmentBuilder_ == null) {
                    if (((bitField0_ & 0x00000004) != 0) &&
                            segment_ != null &&
                            segment_ != ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance()) {
                        segment_ =
                                ai.onnx.proto.OnnxMl.TensorProto.Segment.newBuilder(segment_).mergeFrom(value).buildPartial();
                    } else {
                        segment_ = value;
                    }
                    onChanged();
                } else {
                    segmentBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000004;
                return this;
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public Builder clearSegment() {
                if (segmentBuilder_ == null) {
                    segment_ = null;
                    onChanged();
                } else {
                    segmentBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000004);
                return this;
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder getSegmentBuilder() {
                bitField0_ |= 0x00000004;
                onChanged();
                return getSegmentFieldBuilder().getBuilder();
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
                if (segmentBuilder_ != null) {
                    return segmentBuilder_.getMessageOrBuilder();
                } else {
                    return segment_ == null ?
                            ai.onnx.proto.OnnxMl.TensorProto.Segment.getDefaultInstance() : segment_;
                }
            }
            /**
             * <code>optional .onnx.TensorProto.Segment segment = 3;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto.Segment, ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder, ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder>
            getSegmentFieldBuilder() {
                if (segmentBuilder_ == null) {
                    segmentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto.Segment, ai.onnx.proto.OnnxMl.TensorProto.Segment.Builder, ai.onnx.proto.OnnxMl.TensorProto.SegmentOrBuilder>(
                            getSegment(),
                            getParentForChildren(),
                            isClean());
                    segment_ = null;
                }
                return segmentBuilder_;
            }

            private com.google.protobuf.Internal.FloatList floatData_ = emptyFloatList();
            private void ensureFloatDataIsMutable() {
                if (!((bitField0_ & 0x00000008) != 0)) {
                    floatData_ = mutableCopy(floatData_);
                    bitField0_ |= 0x00000008;
                }
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return A list containing the floatData.
             */
            public java.util.List<java.lang.Float>
            getFloatDataList() {
                return ((bitField0_ & 0x00000008) != 0) ?
                        java.util.Collections.unmodifiableList(floatData_) : floatData_;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return The count of floatData.
             */
            public int getFloatDataCount() {
                return floatData_.size();
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The floatData at the given index.
             */
            public float getFloatData(int index) {
                return floatData_.getFloat(index);
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The floatData to set.
             * @return This builder for chaining.
             */
            public Builder setFloatData(
                    int index, float value) {
                ensureFloatDataIsMutable();
                floatData_.setFloat(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param value The floatData to add.
             * @return This builder for chaining.
             */
            public Builder addFloatData(float value) {
                ensureFloatDataIsMutable();
                floatData_.addFloat(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @param values The floatData to add.
             * @return This builder for chaining.
             */
            public Builder addAllFloatData(
                    java.lang.Iterable<? extends java.lang.Float> values) {
                ensureFloatDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, floatData_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For float and complex64 values
             * Complex64 tensors are encoded as a single array of floats,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
             * </pre>
             *
             * <code>repeated float float_data = 4 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearFloatData() {
                floatData_ = emptyFloatList();
                bitField0_ = (bitField0_ & ~0x00000008);
                onChanged();
                return this;
            }

            private com.google.protobuf.Internal.IntList int32Data_ = emptyIntList();
            private void ensureInt32DataIsMutable() {
                if (!((bitField0_ & 0x00000010) != 0)) {
                    int32Data_ = mutableCopy(int32Data_);
                    bitField0_ |= 0x00000010;
                }
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return A list containing the int32Data.
             */
            public java.util.List<java.lang.Integer>
            getInt32DataList() {
                return ((bitField0_ & 0x00000010) != 0) ?
                        java.util.Collections.unmodifiableList(int32Data_) : int32Data_;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return The count of int32Data.
             */
            public int getInt32DataCount() {
                return int32Data_.size();
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The int32Data at the given index.
             */
            public int getInt32Data(int index) {
                return int32Data_.getInt(index);
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The int32Data to set.
             * @return This builder for chaining.
             */
            public Builder setInt32Data(
                    int index, int value) {
                ensureInt32DataIsMutable();
                int32Data_.setInt(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param value The int32Data to add.
             * @return This builder for chaining.
             */
            public Builder addInt32Data(int value) {
                ensureInt32DataIsMutable();
                int32Data_.addInt(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @param values The int32Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllInt32Data(
                    java.lang.Iterable<? extends java.lang.Integer> values) {
                ensureInt32DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, int32Data_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int32, uint8, int8, uint16, int16, bool, and float16 values
             * float16 values must be bit-wise converted to an uint16_t prior
             * to writing to the buffer.
             * When this field is present, the data_type field MUST be
             * INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
             * </pre>
             *
             * <code>repeated int32 int32_data = 5 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearInt32Data() {
                int32Data_ = emptyIntList();
                bitField0_ = (bitField0_ & ~0x00000010);
                onChanged();
                return this;
            }

            private java.util.List<com.google.protobuf.ByteString> stringData_ = java.util.Collections.emptyList();
            private void ensureStringDataIsMutable() {
                if (!((bitField0_ & 0x00000020) != 0)) {
                    stringData_ = new java.util.ArrayList<com.google.protobuf.ByteString>(stringData_);
                    bitField0_ |= 0x00000020;
                }
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return A list containing the stringData.
             */
            public java.util.List<com.google.protobuf.ByteString>
            getStringDataList() {
                return ((bitField0_ & 0x00000020) != 0) ?
                        java.util.Collections.unmodifiableList(stringData_) : stringData_;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return The count of stringData.
             */
            public int getStringDataCount() {
                return stringData_.size();
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param index The index of the element to return.
             * @return The stringData at the given index.
             */
            public com.google.protobuf.ByteString getStringData(int index) {
                return stringData_.get(index);
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param index The index to set the value at.
             * @param value The stringData to set.
             * @return This builder for chaining.
             */
            public Builder setStringData(
                    int index, com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureStringDataIsMutable();
                stringData_.set(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param value The stringData to add.
             * @return This builder for chaining.
             */
            public Builder addStringData(com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureStringDataIsMutable();
                stringData_.add(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @param values The stringData to add.
             * @return This builder for chaining.
             */
            public Builder addAllStringData(
                    java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
                ensureStringDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, stringData_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For strings.
             * Each element of string_data is a UTF-8 encoded Unicode
             * string. No trailing null, no leading BOM. The protobuf "string"
             * scalar type is not used to match ML community conventions.
             * When this field is present, the data_type field MUST be STRING
             * </pre>
             *
             * <code>repeated bytes string_data = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearStringData() {
                stringData_ = java.util.Collections.emptyList();
                bitField0_ = (bitField0_ & ~0x00000020);
                onChanged();
                return this;
            }

            private com.google.protobuf.Internal.LongList int64Data_ = emptyLongList();
            private void ensureInt64DataIsMutable() {
                if (!((bitField0_ & 0x00000040) != 0)) {
                    int64Data_ = mutableCopy(int64Data_);
                    bitField0_ |= 0x00000040;
                }
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return A list containing the int64Data.
             */
            public java.util.List<java.lang.Long>
            getInt64DataList() {
                return ((bitField0_ & 0x00000040) != 0) ?
                        java.util.Collections.unmodifiableList(int64Data_) : int64Data_;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return The count of int64Data.
             */
            public int getInt64DataCount() {
                return int64Data_.size();
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The int64Data at the given index.
             */
            public long getInt64Data(int index) {
                return int64Data_.getLong(index);
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The int64Data to set.
             * @return This builder for chaining.
             */
            public Builder setInt64Data(
                    int index, long value) {
                ensureInt64DataIsMutable();
                int64Data_.setLong(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param value The int64Data to add.
             * @return This builder for chaining.
             */
            public Builder addInt64Data(long value) {
                ensureInt64DataIsMutable();
                int64Data_.addLong(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @param values The int64Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllInt64Data(
                    java.lang.Iterable<? extends java.lang.Long> values) {
                ensureInt64DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, int64Data_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For int64.
             * When this field is present, the data_type field MUST be INT64
             * </pre>
             *
             * <code>repeated int64 int64_data = 7 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearInt64Data() {
                int64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000040);
                onChanged();
                return this;
            }

            private java.lang.Object name_ = "";
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return Whether the name field is set.
             */
            public boolean hasName() {
                return ((bitField0_ & 0x00000080) != 0);
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return The name.
             */
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return The bytes for name.
             */
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @param value The name to set.
             * @return This builder for chaining.
             */
            public Builder setName(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000080;
                name_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @return This builder for chaining.
             */
            public Builder clearName() {
                bitField0_ = (bitField0_ & ~0x00000080);
                name_ = getDefaultInstance().getName();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Optionally, a name for the tensor.
             * </pre>
             *
             * <code>optional string name = 8;</code>
             * @param value The bytes for name to set.
             * @return This builder for chaining.
             */
            public Builder setNameBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000080;
                name_ = value;
                onChanged();
                return this;
            }

            private java.lang.Object docString_ = "";
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return Whether the docString field is set.
             */
            public boolean hasDocString() {
                return ((bitField0_ & 0x00000100) != 0);
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return The docString.
             */
            public java.lang.String getDocString() {
                java.lang.Object ref = docString_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        docString_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return The bytes for docString.
             */
            public com.google.protobuf.ByteString
            getDocStringBytes() {
                java.lang.Object ref = docString_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    docString_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @param value The docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocString(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000100;
                docString_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @return This builder for chaining.
             */
            public Builder clearDocString() {
                bitField0_ = (bitField0_ & ~0x00000100);
                docString_ = getDefaultInstance().getDocString();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * A human-readable documentation for this tensor. Markdown is allowed.
             * </pre>
             *
             * <code>optional string doc_string = 12;</code>
             * @param value The bytes for docString to set.
             * @return This builder for chaining.
             */
            public Builder setDocStringBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000100;
                docString_ = value;
                onChanged();
                return this;
            }

            private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return Whether the rawData field is set.
             */
            @java.lang.Override
            public boolean hasRawData() {
                return ((bitField0_ & 0x00000200) != 0);
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return The rawData.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString getRawData() {
                return rawData_;
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @param value The rawData to set.
             * @return This builder for chaining.
             */
            public Builder setRawData(com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000200;
                rawData_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * Serializations can either use one of the fields above, or use this
             * raw bytes field. The only exception is the string case, where one is
             * required to store the content in the repeated bytes string_data field.
             * When this raw_data field is used to store tensor value, elements MUST
             * be stored in as fixed-width, little-endian order.
             * Floating-point data types MUST be stored in IEEE 754 format.
             * Complex64 elements must be written as two consecutive FLOAT values, real component first.
             * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
             * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
             * Note: the advantage of specific field rather than the raw_data field is
             * that in some cases (e.g. int data), protobuf does a better packing via
             * variable length storage, and may lead to smaller binary footprint.
             * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
             * </pre>
             *
             * <code>optional bytes raw_data = 9;</code>
             * @return This builder for chaining.
             */
            public Builder clearRawData() {
                bitField0_ = (bitField0_ & ~0x00000200);
                rawData_ = getDefaultInstance().getRawData();
                onChanged();
                return this;
            }

            private java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> externalData_ =
                    java.util.Collections.emptyList();
            private void ensureExternalDataIsMutable() {
                if (!((bitField0_ & 0x00000400) != 0)) {
                    externalData_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.StringStringEntryProto>(externalData_);
                    bitField0_ |= 0x00000400;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder> externalDataBuilder_;

            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto> getExternalDataList() {
                if (externalDataBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(externalData_);
                } else {
                    return externalDataBuilder_.getMessageList();
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public int getExternalDataCount() {
                if (externalDataBuilder_ == null) {
                    return externalData_.size();
                } else {
                    return externalDataBuilder_.getCount();
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto getExternalData(int index) {
                if (externalDataBuilder_ == null) {
                    return externalData_.get(index);
                } else {
                    return externalDataBuilder_.getMessage(index);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder setExternalData(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.set(index, value);
                    onChanged();
                } else {
                    externalDataBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder setExternalData(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.add(value);
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto value) {
                if (externalDataBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureExternalDataIsMutable();
                    externalData_.add(index, value);
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                    ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.add(builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addExternalData(
                    int index, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder builderForValue) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    externalDataBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder addAllExternalData(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.StringStringEntryProto> values) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, externalData_);
                    onChanged();
                } else {
                    externalDataBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder clearExternalData() {
                if (externalDataBuilder_ == null) {
                    externalData_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000400);
                    onChanged();
                } else {
                    externalDataBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public Builder removeExternalData(int index) {
                if (externalDataBuilder_ == null) {
                    ensureExternalDataIsMutable();
                    externalData_.remove(index);
                    onChanged();
                } else {
                    externalDataBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder getExternalDataBuilder(
                    int index) {
                return getExternalDataFieldBuilder().getBuilder(index);
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
                    int index) {
                if (externalDataBuilder_ == null) {
                    return externalData_.get(index);  } else {
                    return externalDataBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getExternalDataOrBuilderList() {
                if (externalDataBuilder_ != null) {
                    return externalDataBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(externalData_);
                }
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addExternalDataBuilder() {
                return getExternalDataFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder addExternalDataBuilder(
                    int index) {
                return getExternalDataFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.StringStringEntryProto.getDefaultInstance());
            }
            /**
             * <pre>
             * Data can be stored inside the protobuf file using type-specific fields or raw_data.
             * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
             * external_data stores key-value pairs describing data location. Recognized keys are:
             * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
             *                           protobuf model was stored
             * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
             *                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
             * - "length" (optional) - number of bytes containing data. Integer stored as string.
             * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
             * </pre>
             *
             * <code>repeated .onnx.StringStringEntryProto external_data = 13;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder>
            getExternalDataBuilderList() {
                return getExternalDataFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>
            getExternalDataFieldBuilder() {
                if (externalDataBuilder_ == null) {
                    externalDataBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.StringStringEntryProto, ai.onnx.proto.OnnxMl.StringStringEntryProto.Builder, ai.onnx.proto.OnnxMl.StringStringEntryProtoOrBuilder>(
                            externalData_,
                            ((bitField0_ & 0x00000400) != 0),
                            getParentForChildren(),
                            isClean());
                    externalData_ = null;
                }
                return externalDataBuilder_;
            }

            private int dataLocation_ = 0;
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return Whether the dataLocation field is set.
             */
            @java.lang.Override public boolean hasDataLocation() {
                return ((bitField0_ & 0x00000800) != 0);
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return The dataLocation.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorProto.DataLocation getDataLocation() {
                @SuppressWarnings("deprecation")
                ai.onnx.proto.OnnxMl.TensorProto.DataLocation result = ai.onnx.proto.OnnxMl.TensorProto.DataLocation.valueOf(dataLocation_);
                return result == null ? ai.onnx.proto.OnnxMl.TensorProto.DataLocation.DEFAULT : result;
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
             * @param value The dataLocation to set.
             * @return This builder for chaining.
             */
            public Builder setDataLocation(ai.onnx.proto.OnnxMl.TensorProto.DataLocation value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000800;
                dataLocation_ = value.getNumber();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
             * </pre>
             *
             * <code>optional .onnx.TensorProto.DataLocation data_location = 14;</code>
             * @return This builder for chaining.
             */
            public Builder clearDataLocation() {
                bitField0_ = (bitField0_ & ~0x00000800);
                dataLocation_ = 0;
                onChanged();
                return this;
            }

            private com.google.protobuf.Internal.DoubleList doubleData_ = emptyDoubleList();
            private void ensureDoubleDataIsMutable() {
                if (!((bitField0_ & 0x00001000) != 0)) {
                    doubleData_ = mutableCopy(doubleData_);
                    bitField0_ |= 0x00001000;
                }
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return A list containing the doubleData.
             */
            public java.util.List<java.lang.Double>
            getDoubleDataList() {
                return ((bitField0_ & 0x00001000) != 0) ?
                        java.util.Collections.unmodifiableList(doubleData_) : doubleData_;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return The count of doubleData.
             */
            public int getDoubleDataCount() {
                return doubleData_.size();
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The doubleData at the given index.
             */
            public double getDoubleData(int index) {
                return doubleData_.getDouble(index);
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The doubleData to set.
             * @return This builder for chaining.
             */
            public Builder setDoubleData(
                    int index, double value) {
                ensureDoubleDataIsMutable();
                doubleData_.setDouble(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param value The doubleData to add.
             * @return This builder for chaining.
             */
            public Builder addDoubleData(double value) {
                ensureDoubleDataIsMutable();
                doubleData_.addDouble(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @param values The doubleData to add.
             * @return This builder for chaining.
             */
            public Builder addAllDoubleData(
                    java.lang.Iterable<? extends java.lang.Double> values) {
                ensureDoubleDataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, doubleData_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For double
             * Complex128 tensors are encoded as a single array of doubles,
             * with the real components appearing in odd numbered positions,
             * and the corresponding imaginary component appearing in the
             * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
             * is encoded as [1.0, 2.0 ,3.0 ,4.0]
             * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
             * </pre>
             *
             * <code>repeated double double_data = 10 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearDoubleData() {
                doubleData_ = emptyDoubleList();
                bitField0_ = (bitField0_ & ~0x00001000);
                onChanged();
                return this;
            }

            private com.google.protobuf.Internal.LongList uint64Data_ = emptyLongList();
            private void ensureUint64DataIsMutable() {
                if (!((bitField0_ & 0x00002000) != 0)) {
                    uint64Data_ = mutableCopy(uint64Data_);
                    bitField0_ |= 0x00002000;
                }
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return A list containing the uint64Data.
             */
            public java.util.List<java.lang.Long>
            getUint64DataList() {
                return ((bitField0_ & 0x00002000) != 0) ?
                        java.util.Collections.unmodifiableList(uint64Data_) : uint64Data_;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return The count of uint64Data.
             */
            public int getUint64DataCount() {
                return uint64Data_.size();
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param index The index of the element to return.
             * @return The uint64Data at the given index.
             */
            public long getUint64Data(int index) {
                return uint64Data_.getLong(index);
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param index The index to set the value at.
             * @param value The uint64Data to set.
             * @return This builder for chaining.
             */
            public Builder setUint64Data(
                    int index, long value) {
                ensureUint64DataIsMutable();
                uint64Data_.setLong(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param value The uint64Data to add.
             * @return This builder for chaining.
             */
            public Builder addUint64Data(long value) {
                ensureUint64DataIsMutable();
                uint64Data_.addLong(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @param values The uint64Data to add.
             * @return This builder for chaining.
             */
            public Builder addAllUint64Data(
                    java.lang.Iterable<? extends java.lang.Long> values) {
                ensureUint64DataIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, uint64Data_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * For uint64 and uint32 values
             * When this field is present, the data_type field MUST be
             * UINT32 or UINT64
             * </pre>
             *
             * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
             * @return This builder for chaining.
             */
            public Builder clearUint64Data() {
                uint64Data_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00002000);
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.TensorProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.TensorProto)
        private static final ai.onnx.proto.OnnxMl.TensorProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TensorProto();
        }

        public static ai.onnx.proto.OnnxMl.TensorProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<TensorProto>
                PARSER = new com.google.protobuf.AbstractParser<TensorProto>() {
            @java.lang.Override
            public TensorProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new TensorProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<TensorProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<TensorProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface SparseTensorProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.SparseTensorProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         * @return Whether the values field is set.
         */
        boolean hasValues();
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         * @return The values.
         */
        ai.onnx.proto.OnnxMl.TensorProto getValues();
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder();

        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         * @return Whether the indices field is set.
         */
        boolean hasIndices();
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         * @return The indices.
         */
        ai.onnx.proto.OnnxMl.TensorProto getIndices();
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         */
        ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder();

        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return A list containing the dims.
         */
        java.util.List<java.lang.Long> getDimsList();
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return The count of dims.
         */
        int getDimsCount();
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        long getDims(int index);
    }
    /**
     * <pre>
     * A serialized sparse-tensor value
     * </pre>
     *
     * Protobuf type {@code onnx.SparseTensorProto}
     */
    public static final class SparseTensorProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.SparseTensorProto)
            SparseTensorProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use SparseTensorProto.newBuilder() to construct.
        private SparseTensorProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private SparseTensorProto() {
            dims_ = emptyLongList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new SparseTensorProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private SparseTensorProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            ai.onnx.proto.OnnxMl.TensorProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000001) != 0)) {
                                subBuilder = values_.toBuilder();
                            }
                            values_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(values_);
                                values_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000001;
                            break;
                        }
                        case 18: {
                            ai.onnx.proto.OnnxMl.TensorProto.Builder subBuilder = null;
                            if (((bitField0_ & 0x00000002) != 0)) {
                                subBuilder = indices_.toBuilder();
                            }
                            indices_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorProto.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom(indices_);
                                indices_ = subBuilder.buildPartial();
                            }
                            bitField0_ |= 0x00000002;
                            break;
                        }
                        case 24: {
                            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                                dims_ = newLongList();
                                mutable_bitField0_ |= 0x00000004;
                            }
                            dims_.addLong(input.readInt64());
                            break;
                        }
                        case 26: {
                            int length = input.readRawVarint32();
                            int limit = input.pushLimit(length);
                            if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
                                dims_ = newLongList();
                                mutable_bitField0_ |= 0x00000004;
                            }
                            while (input.getBytesUntilLimit() > 0) {
                                dims_.addLong(input.readInt64());
                            }
                            input.popLimit(limit);
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000004) != 0)) {
                    dims_.makeImmutable(); // C
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_SparseTensorProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.SparseTensorProto.class, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder.class);
        }

        private int bitField0_;
        public static final int VALUES_FIELD_NUMBER = 1;
        private ai.onnx.proto.OnnxMl.TensorProto values_;
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         * @return Whether the values field is set.
         */
        @java.lang.Override
        public boolean hasValues() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         * @return The values.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getValues() {
            return values_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : values_;
        }
        /**
         * <pre>
         * The sequence of non-default values are encoded as a tensor of shape [NNZ].
         * The default-value is zero for numeric tensors, and empty-string for string tensors.
         * values must have a non-empty name present which serves as a name for SparseTensorProto
         * when used in sparse_initializer list.
         * </pre>
         *
         * <code>optional .onnx.TensorProto values = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder() {
            return values_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : values_;
        }

        public static final int INDICES_FIELD_NUMBER = 2;
        private ai.onnx.proto.OnnxMl.TensorProto indices_;
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         * @return Whether the indices field is set.
         */
        @java.lang.Override
        public boolean hasIndices() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         * @return The indices.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProto getIndices() {
            return indices_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : indices_;
        }
        /**
         * <pre>
         * The indices of the non-default values, which may be stored in one of two formats.
         * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
         * corresponding to the j-th index of the i-th value (in the values tensor).
         * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
         * must be the linearized-index of the i-th value (in the values tensor).
         * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
         * using the shape provided below.
         * The indices must appear in ascending order without duplication.
         * In the first format, the ordering is lexicographic-ordering:
         * e.g., index-value [1,4] must appear before [2,1]
         * </pre>
         *
         * <code>optional .onnx.TensorProto indices = 2;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder() {
            return indices_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : indices_;
        }

        public static final int DIMS_FIELD_NUMBER = 3;
        private com.google.protobuf.Internal.LongList dims_;
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return A list containing the dims.
         */
        @java.lang.Override
        public java.util.List<java.lang.Long>
        getDimsList() {
            return dims_;
        }
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @return The count of dims.
         */
        public int getDimsCount() {
            return dims_.size();
        }
        /**
         * <pre>
         * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
         * </pre>
         *
         * <code>repeated int64 dims = 3;</code>
         * @param index The index of the element to return.
         * @return The dims at the given index.
         */
        public long getDims(int index) {
            return dims_.getLong(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                output.writeMessage(1, getValues());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeMessage(2, getIndices());
            }
            for (int i = 0; i < dims_.size(); i++) {
                output.writeInt64(3, dims_.getLong(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, getValues());
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(2, getIndices());
            }
            {
                int dataSize = 0;
                for (int i = 0; i < dims_.size(); i++) {
                    dataSize += com.google.protobuf.CodedOutputStream
                            .computeInt64SizeNoTag(dims_.getLong(i));
                }
                size += dataSize;
                size += 1 * getDimsList().size();
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.SparseTensorProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.SparseTensorProto other = (ai.onnx.proto.OnnxMl.SparseTensorProto) obj;

            if (hasValues() != other.hasValues()) return false;
            if (hasValues()) {
                if (!getValues()
                        .equals(other.getValues())) return false;
            }
            if (hasIndices() != other.hasIndices()) return false;
            if (hasIndices()) {
                if (!getIndices()
                        .equals(other.getIndices())) return false;
            }
            if (!getDimsList()
                    .equals(other.getDimsList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasValues()) {
                hash = (37 * hash) + VALUES_FIELD_NUMBER;
                hash = (53 * hash) + getValues().hashCode();
            }
            if (hasIndices()) {
                hash = (37 * hash) + INDICES_FIELD_NUMBER;
                hash = (53 * hash) + getIndices().hashCode();
            }
            if (getDimsCount() > 0) {
                hash = (37 * hash) + DIMS_FIELD_NUMBER;
                hash = (53 * hash) + getDimsList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.SparseTensorProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.SparseTensorProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * A serialized sparse-tensor value
         * </pre>
         *
         * Protobuf type {@code onnx.SparseTensorProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.SparseTensorProto)
                ai.onnx.proto.OnnxMl.SparseTensorProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_SparseTensorProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.SparseTensorProto.class, ai.onnx.proto.OnnxMl.SparseTensorProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.SparseTensorProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getValuesFieldBuilder();
                    getIndicesFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                if (valuesBuilder_ == null) {
                    values_ = null;
                } else {
                    valuesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                if (indicesBuilder_ == null) {
                    indices_ = null;
                } else {
                    indicesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000004);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_SparseTensorProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.SparseTensorProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.SparseTensorProto build() {
                ai.onnx.proto.OnnxMl.SparseTensorProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.SparseTensorProto buildPartial() {
                ai.onnx.proto.OnnxMl.SparseTensorProto result = new ai.onnx.proto.OnnxMl.SparseTensorProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    if (valuesBuilder_ == null) {
                        result.values_ = values_;
                    } else {
                        result.values_ = valuesBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000001;
                }
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    if (indicesBuilder_ == null) {
                        result.indices_ = indices_;
                    } else {
                        result.indices_ = indicesBuilder_.build();
                    }
                    to_bitField0_ |= 0x00000002;
                }
                if (((bitField0_ & 0x00000004) != 0)) {
                    dims_.makeImmutable();
                    bitField0_ = (bitField0_ & ~0x00000004);
                }
                result.dims_ = dims_;
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.SparseTensorProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.SparseTensorProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.SparseTensorProto other) {
                if (other == ai.onnx.proto.OnnxMl.SparseTensorProto.getDefaultInstance()) return this;
                if (other.hasValues()) {
                    mergeValues(other.getValues());
                }
                if (other.hasIndices()) {
                    mergeIndices(other.getIndices());
                }
                if (!other.dims_.isEmpty()) {
                    if (dims_.isEmpty()) {
                        dims_ = other.dims_;
                        bitField0_ = (bitField0_ & ~0x00000004);
                    } else {
                        ensureDimsIsMutable();
                        dims_.addAll(other.dims_);
                    }
                    onChanged();
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.SparseTensorProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.SparseTensorProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private ai.onnx.proto.OnnxMl.TensorProto values_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder> valuesBuilder_;
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             * @return Whether the values field is set.
             */
            public boolean hasValues() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             * @return The values.
             */
            public ai.onnx.proto.OnnxMl.TensorProto getValues() {
                if (valuesBuilder_ == null) {
                    return values_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : values_;
                } else {
                    return valuesBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public Builder setValues(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (valuesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    values_ = value;
                    onChanged();
                } else {
                    valuesBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public Builder setValues(
                    ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (valuesBuilder_ == null) {
                    values_ = builderForValue.build();
                    onChanged();
                } else {
                    valuesBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public Builder mergeValues(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (valuesBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0) &&
                            values_ != null &&
                            values_ != ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance()) {
                        values_ =
                                ai.onnx.proto.OnnxMl.TensorProto.newBuilder(values_).mergeFrom(value).buildPartial();
                    } else {
                        values_ = value;
                    }
                    onChanged();
                } else {
                    valuesBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000001;
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public Builder clearValues() {
                if (valuesBuilder_ == null) {
                    values_ = null;
                    onChanged();
                } else {
                    valuesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000001);
                return this;
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder getValuesBuilder() {
                bitField0_ |= 0x00000001;
                onChanged();
                return getValuesFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getValuesOrBuilder() {
                if (valuesBuilder_ != null) {
                    return valuesBuilder_.getMessageOrBuilder();
                } else {
                    return values_ == null ?
                            ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : values_;
                }
            }
            /**
             * <pre>
             * The sequence of non-default values are encoded as a tensor of shape [NNZ].
             * The default-value is zero for numeric tensors, and empty-string for string tensors.
             * values must have a non-empty name present which serves as a name for SparseTensorProto
             * when used in sparse_initializer list.
             * </pre>
             *
             * <code>optional .onnx.TensorProto values = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getValuesFieldBuilder() {
                if (valuesBuilder_ == null) {
                    valuesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>(
                            getValues(),
                            getParentForChildren(),
                            isClean());
                    values_ = null;
                }
                return valuesBuilder_;
            }

            private ai.onnx.proto.OnnxMl.TensorProto indices_;
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder> indicesBuilder_;
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             * @return Whether the indices field is set.
             */
            public boolean hasIndices() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             * @return The indices.
             */
            public ai.onnx.proto.OnnxMl.TensorProto getIndices() {
                if (indicesBuilder_ == null) {
                    return indices_ == null ? ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : indices_;
                } else {
                    return indicesBuilder_.getMessage();
                }
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public Builder setIndices(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (indicesBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    indices_ = value;
                    onChanged();
                } else {
                    indicesBuilder_.setMessage(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public Builder setIndices(
                    ai.onnx.proto.OnnxMl.TensorProto.Builder builderForValue) {
                if (indicesBuilder_ == null) {
                    indices_ = builderForValue.build();
                    onChanged();
                } else {
                    indicesBuilder_.setMessage(builderForValue.build());
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public Builder mergeIndices(ai.onnx.proto.OnnxMl.TensorProto value) {
                if (indicesBuilder_ == null) {
                    if (((bitField0_ & 0x00000002) != 0) &&
                            indices_ != null &&
                            indices_ != ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance()) {
                        indices_ =
                                ai.onnx.proto.OnnxMl.TensorProto.newBuilder(indices_).mergeFrom(value).buildPartial();
                    } else {
                        indices_ = value;
                    }
                    onChanged();
                } else {
                    indicesBuilder_.mergeFrom(value);
                }
                bitField0_ |= 0x00000002;
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public Builder clearIndices() {
                if (indicesBuilder_ == null) {
                    indices_ = null;
                    onChanged();
                } else {
                    indicesBuilder_.clear();
                }
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProto.Builder getIndicesBuilder() {
                bitField0_ |= 0x00000002;
                onChanged();
                return getIndicesFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorProtoOrBuilder getIndicesOrBuilder() {
                if (indicesBuilder_ != null) {
                    return indicesBuilder_.getMessageOrBuilder();
                } else {
                    return indices_ == null ?
                            ai.onnx.proto.OnnxMl.TensorProto.getDefaultInstance() : indices_;
                }
            }
            /**
             * <pre>
             * The indices of the non-default values, which may be stored in one of two formats.
             * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
             * corresponding to the j-th index of the i-th value (in the values tensor).
             * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
             * must be the linearized-index of the i-th value (in the values tensor).
             * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
             * using the shape provided below.
             * The indices must appear in ascending order without duplication.
             * In the first format, the ordering is lexicographic-ordering:
             * e.g., index-value [1,4] must appear before [2,1]
             * </pre>
             *
             * <code>optional .onnx.TensorProto indices = 2;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>
            getIndicesFieldBuilder() {
                if (indicesBuilder_ == null) {
                    indicesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorProto, ai.onnx.proto.OnnxMl.TensorProto.Builder, ai.onnx.proto.OnnxMl.TensorProtoOrBuilder>(
                            getIndices(),
                            getParentForChildren(),
                            isClean());
                    indices_ = null;
                }
                return indicesBuilder_;
            }

            private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
            private void ensureDimsIsMutable() {
                if (!((bitField0_ & 0x00000004) != 0)) {
                    dims_ = mutableCopy(dims_);
                    bitField0_ |= 0x00000004;
                }
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return A list containing the dims.
             */
            public java.util.List<java.lang.Long>
            getDimsList() {
                return ((bitField0_ & 0x00000004) != 0) ?
                        java.util.Collections.unmodifiableList(dims_) : dims_;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return The count of dims.
             */
            public int getDimsCount() {
                return dims_.size();
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param index The index of the element to return.
             * @return The dims at the given index.
             */
            public long getDims(int index) {
                return dims_.getLong(index);
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param index The index to set the value at.
             * @param value The dims to set.
             * @return This builder for chaining.
             */
            public Builder setDims(
                    int index, long value) {
                ensureDimsIsMutable();
                dims_.setLong(index, value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param value The dims to add.
             * @return This builder for chaining.
             */
            public Builder addDims(long value) {
                ensureDimsIsMutable();
                dims_.addLong(value);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @param values The dims to add.
             * @return This builder for chaining.
             */
            public Builder addAllDims(
                    java.lang.Iterable<? extends java.lang.Long> values) {
                ensureDimsIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, dims_);
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
             * </pre>
             *
             * <code>repeated int64 dims = 3;</code>
             * @return This builder for chaining.
             */
            public Builder clearDims() {
                dims_ = emptyLongList();
                bitField0_ = (bitField0_ & ~0x00000004);
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.SparseTensorProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.SparseTensorProto)
        private static final ai.onnx.proto.OnnxMl.SparseTensorProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.SparseTensorProto();
        }

        public static ai.onnx.proto.OnnxMl.SparseTensorProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<SparseTensorProto>
                PARSER = new com.google.protobuf.AbstractParser<SparseTensorProto>() {
            @java.lang.Override
            public SparseTensorProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new SparseTensorProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<SparseTensorProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<SparseTensorProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.SparseTensorProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface TensorShapeProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.TensorShapeProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension>
        getDimList();
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDim(int index);
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        int getDimCount();
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        java.util.List<? extends ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder>
        getDimOrBuilderList();
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
                int index);
    }
    /**
     * <pre>
     * Defines a tensor shape. A dimension can be either an integer value
     * or a symbolic variable. A symbolic variable represents an unknown
     * dimension.
     * </pre>
     *
     * Protobuf type {@code onnx.TensorShapeProto}
     */
    public static final class TensorShapeProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.TensorShapeProto)
            TensorShapeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use TensorShapeProto.newBuilder() to construct.
        private TensorShapeProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private TensorShapeProto() {
            dim_ = java.util.Collections.emptyList();
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new TensorShapeProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private TensorShapeProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                                dim_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension>();
                                mutable_bitField0_ |= 0x00000001;
                            }
                            dim_.add(
                                    input.readMessage(ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.PARSER, extensionRegistry));
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                if (((mutable_bitField0_ & 0x00000001) != 0)) {
                    dim_ = java.util.Collections.unmodifiableList(dim_);
                }
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.TensorShapeProto.class, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder.class);
        }

        public interface DimensionOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TensorShapeProto.Dimension)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <code>int64 dim_value = 1;</code>
             * @return Whether the dimValue field is set.
             */
            boolean hasDimValue();
            /**
             * <code>int64 dim_value = 1;</code>
             * @return The dimValue.
             */
            long getDimValue();

            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return Whether the dimParam field is set.
             */
            boolean hasDimParam();
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The dimParam.
             */
            java.lang.String getDimParam();
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The bytes for dimParam.
             */
            com.google.protobuf.ByteString
            getDimParamBytes();

            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return Whether the denotation field is set.
             */
            boolean hasDenotation();
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The denotation.
             */
            java.lang.String getDenotation();
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The bytes for denotation.
             */
            com.google.protobuf.ByteString
            getDenotationBytes();

            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.ValueCase getValueCase();
        }
        /**
         * Protobuf type {@code onnx.TensorShapeProto.Dimension}
         */
        public static final class Dimension extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TensorShapeProto.Dimension)
                DimensionOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Dimension.newBuilder() to construct.
            private Dimension(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Dimension() {
                denotation_ = "";
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Dimension();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Dimension(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                valueCase_ = 1;
                                value_ = input.readInt64();
                                break;
                            }
                            case 18: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                valueCase_ = 2;
                                value_ = bs;
                                break;
                            }
                            case 26: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                bitField0_ |= 0x00000004;
                                denotation_ = bs;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.class, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder.class);
            }

            private int bitField0_;
            private int valueCase_ = 0;
            private java.lang.Object value_;
            public enum ValueCase
                    implements com.google.protobuf.Internal.EnumLite,
                    com.google.protobuf.AbstractMessage.InternalOneOfEnum {
                DIM_VALUE(1),
                DIM_PARAM(2),
                VALUE_NOT_SET(0);
                private final int value;
                private ValueCase(int value) {
                    this.value = value;
                }
                /**
                 * @param value The number of the enum to look for.
                 * @return The enum associated with the given number.
                 * @deprecated Use {@link #forNumber(int)} instead.
                 */
                @java.lang.Deprecated
                public static ValueCase valueOf(int value) {
                    return forNumber(value);
                }

                public static ValueCase forNumber(int value) {
                    switch (value) {
                        case 1: return DIM_VALUE;
                        case 2: return DIM_PARAM;
                        case 0: return VALUE_NOT_SET;
                        default: return null;
                    }
                }
                public int getNumber() {
                    return this.value;
                }
            };

            public ValueCase
            getValueCase() {
                return ValueCase.forNumber(
                        valueCase_);
            }

            public static final int DIM_VALUE_FIELD_NUMBER = 1;
            /**
             * <code>int64 dim_value = 1;</code>
             * @return Whether the dimValue field is set.
             */
            @java.lang.Override
            public boolean hasDimValue() {
                return valueCase_ == 1;
            }
            /**
             * <code>int64 dim_value = 1;</code>
             * @return The dimValue.
             */
            @java.lang.Override
            public long getDimValue() {
                if (valueCase_ == 1) {
                    return (java.lang.Long) value_;
                }
                return 0L;
            }

            public static final int DIM_PARAM_FIELD_NUMBER = 2;
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return Whether the dimParam field is set.
             */
            public boolean hasDimParam() {
                return valueCase_ == 2;
            }
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The dimParam.
             */
            public java.lang.String getDimParam() {
                java.lang.Object ref = "";
                if (valueCase_ == 2) {
                    ref = value_;
                }
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8() && (valueCase_ == 2)) {
                        value_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * namespace Shape
             * </pre>
             *
             * <code>string dim_param = 2;</code>
             * @return The bytes for dimParam.
             */
            public com.google.protobuf.ByteString
            getDimParamBytes() {
                java.lang.Object ref = "";
                if (valueCase_ == 2) {
                    ref = value_;
                }
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    if (valueCase_ == 2) {
                        value_ = b;
                    }
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }

            public static final int DENOTATION_FIELD_NUMBER = 3;
            private volatile java.lang.Object denotation_;
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return Whether the denotation field is set.
             */
            @java.lang.Override
            public boolean hasDenotation() {
                return ((bitField0_ & 0x00000004) != 0);
            }
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The denotation.
             */
            @java.lang.Override
            public java.lang.String getDenotation() {
                java.lang.Object ref = denotation_;
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        denotation_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * Standard denotation can optionally be used to denote tensor
             * dimensions with standard semantic descriptions to ensure
             * that operations are applied to the correct axis of a tensor.
             * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
             * for pre-defined dimension denotations.
             * </pre>
             *
             * <code>optional string denotation = 3;</code>
             * @return The bytes for denotation.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString
            getDenotationBytes() {
                java.lang.Object ref = denotation_;
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    denotation_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (valueCase_ == 1) {
                    output.writeInt64(
                            1, (long)((java.lang.Long) value_));
                }
                if (valueCase_ == 2) {
                    com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
                }
                if (((bitField0_ & 0x00000004) != 0)) {
                    com.google.protobuf.GeneratedMessageV3.writeString(output, 3, denotation_);
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (valueCase_ == 1) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt64Size(
                                    1, (long)((java.lang.Long) value_));
                }
                if (valueCase_ == 2) {
                    size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
                }
                if (((bitField0_ & 0x00000004) != 0)) {
                    size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, denotation_);
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension other = (ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension) obj;

                if (hasDenotation() != other.hasDenotation()) return false;
                if (hasDenotation()) {
                    if (!getDenotation()
                            .equals(other.getDenotation())) return false;
                }
                if (!getValueCase().equals(other.getValueCase())) return false;
                switch (valueCase_) {
                    case 1:
                        if (getDimValue()
                                != other.getDimValue()) return false;
                        break;
                    case 2:
                        if (!getDimParam()
                                .equals(other.getDimParam())) return false;
                        break;
                    case 0:
                    default:
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasDenotation()) {
                    hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
                    hash = (53 * hash) + getDenotation().hashCode();
                }
                switch (valueCase_) {
                    case 1:
                        hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
                        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                                getDimValue());
                        break;
                    case 2:
                        hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
                        hash = (53 * hash) + getDimParam().hashCode();
                        break;
                    case 0:
                    default:
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code onnx.TensorShapeProto.Dimension}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TensorShapeProto.Dimension)
                    ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.class, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    denotation_ = "";
                    bitField0_ = (bitField0_ & ~0x00000004);
                    valueCase_ = 0;
                    value_ = null;
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension build() {
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension buildPartial() {
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension result = new ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (valueCase_ == 1) {
                        result.value_ = value_;
                    }
                    if (valueCase_ == 2) {
                        result.value_ = value_;
                    }
                    if (((from_bitField0_ & 0x00000004) != 0)) {
                        to_bitField0_ |= 0x00000004;
                    }
                    result.denotation_ = denotation_;
                    result.bitField0_ = to_bitField0_;
                    result.valueCase_ = valueCase_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension other) {
                    if (other == ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance()) return this;
                    if (other.hasDenotation()) {
                        bitField0_ |= 0x00000004;
                        denotation_ = other.denotation_;
                        onChanged();
                    }
                    switch (other.getValueCase()) {
                        case DIM_VALUE: {
                            setDimValue(other.getDimValue());
                            break;
                        }
                        case DIM_PARAM: {
                            valueCase_ = 2;
                            value_ = other.value_;
                            onChanged();
                            break;
                        }
                        case VALUE_NOT_SET: {
                            break;
                        }
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int valueCase_ = 0;
                private java.lang.Object value_;
                public ValueCase
                getValueCase() {
                    return ValueCase.forNumber(
                            valueCase_);
                }

                public Builder clearValue() {
                    valueCase_ = 0;
                    value_ = null;
                    onChanged();
                    return this;
                }

                private int bitField0_;

                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return Whether the dimValue field is set.
                 */
                public boolean hasDimValue() {
                    return valueCase_ == 1;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return The dimValue.
                 */
                public long getDimValue() {
                    if (valueCase_ == 1) {
                        return (java.lang.Long) value_;
                    }
                    return 0L;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @param value The dimValue to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimValue(long value) {
                    valueCase_ = 1;
                    value_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <code>int64 dim_value = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDimValue() {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                    return this;
                }

                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return Whether the dimParam field is set.
                 */
                @java.lang.Override
                public boolean hasDimParam() {
                    return valueCase_ == 2;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return The dimParam.
                 */
                @java.lang.Override
                public java.lang.String getDimParam() {
                    java.lang.Object ref = "";
                    if (valueCase_ == 2) {
                        ref = value_;
                    }
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                                (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (valueCase_ == 2) {
                            if (bs.isValidUtf8()) {
                                value_ = s;
                            }
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return The bytes for dimParam.
                 */
                @java.lang.Override
                public com.google.protobuf.ByteString
                getDimParamBytes() {
                    java.lang.Object ref = "";
                    if (valueCase_ == 2) {
                        ref = value_;
                    }
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                                com.google.protobuf.ByteString.copyFromUtf8(
                                        (java.lang.String) ref);
                        if (valueCase_ == 2) {
                            value_ = b;
                        }
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @param value The dimParam to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimParam(
                        java.lang.String value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    valueCase_ = 2;
                    value_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDimParam() {
                    if (valueCase_ == 2) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                    return this;
                }
                /**
                 * <pre>
                 * namespace Shape
                 * </pre>
                 *
                 * <code>string dim_param = 2;</code>
                 * @param value The bytes for dimParam to set.
                 * @return This builder for chaining.
                 */
                public Builder setDimParamBytes(
                        com.google.protobuf.ByteString value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    valueCase_ = 2;
                    value_ = value;
                    onChanged();
                    return this;
                }

                private java.lang.Object denotation_ = "";
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return Whether the denotation field is set.
                 */
                public boolean hasDenotation() {
                    return ((bitField0_ & 0x00000004) != 0);
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return The denotation.
                 */
                public java.lang.String getDenotation() {
                    java.lang.Object ref = denotation_;
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                                (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (bs.isValidUtf8()) {
                            denotation_ = s;
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return The bytes for denotation.
                 */
                public com.google.protobuf.ByteString
                getDenotationBytes() {
                    java.lang.Object ref = denotation_;
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                                com.google.protobuf.ByteString.copyFromUtf8(
                                        (java.lang.String) ref);
                        denotation_ = b;
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @param value The denotation to set.
                 * @return This builder for chaining.
                 */
                public Builder setDenotation(
                        java.lang.String value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000004;
                    denotation_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDenotation() {
                    bitField0_ = (bitField0_ & ~0x00000004);
                    denotation_ = getDefaultInstance().getDenotation();
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * Standard denotation can optionally be used to denote tensor
                 * dimensions with standard semantic descriptions to ensure
                 * that operations are applied to the correct axis of a tensor.
                 * Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
                 * for pre-defined dimension denotations.
                 * </pre>
                 *
                 * <code>optional string denotation = 3;</code>
                 * @param value The bytes for denotation to set.
                 * @return This builder for chaining.
                 */
                public Builder setDenotationBytes(
                        com.google.protobuf.ByteString value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000004;
                    denotation_ = value;
                    onChanged();
                    return this;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TensorShapeProto.Dimension)
            }

            // @@protoc_insertion_point(class_scope:onnx.TensorShapeProto.Dimension)
            private static final ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension();
            }

            public static ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Dimension>
                    PARSER = new com.google.protobuf.AbstractParser<Dimension>() {
                @java.lang.Override
                public Dimension parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Dimension(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Dimension> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Dimension> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        public static final int DIM_FIELD_NUMBER = 1;
        private java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension> dim_;
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension> getDimList() {
            return dim_;
        }
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder>
        getDimOrBuilderList() {
            return dim_;
        }
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public int getDimCount() {
            return dim_.size();
        }
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDim(int index) {
            return dim_.get(index);
        }
        /**
         * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
                int index) {
            return dim_.get(index);
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            for (int i = 0; i < dim_.size(); i++) {
                output.writeMessage(1, dim_.get(i));
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            for (int i = 0; i < dim_.size(); i++) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, dim_.get(i));
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.TensorShapeProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.TensorShapeProto other = (ai.onnx.proto.OnnxMl.TensorShapeProto) obj;

            if (!getDimList()
                    .equals(other.getDimList())) return false;
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (getDimCount() > 0) {
                hash = (37 * hash) + DIM_FIELD_NUMBER;
                hash = (53 * hash) + getDimList().hashCode();
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TensorShapeProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.TensorShapeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Defines a tensor shape. A dimension can be either an integer value
         * or a symbolic variable. A symbolic variable represents an unknown
         * dimension.
         * </pre>
         *
         * Protobuf type {@code onnx.TensorShapeProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.TensorShapeProto)
                ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TensorShapeProto.class, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.TensorShapeProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                    getDimFieldBuilder();
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                if (dimBuilder_ == null) {
                    dim_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                } else {
                    dimBuilder_.clear();
                }
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TensorShapeProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto build() {
                ai.onnx.proto.OnnxMl.TensorShapeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto buildPartial() {
                ai.onnx.proto.OnnxMl.TensorShapeProto result = new ai.onnx.proto.OnnxMl.TensorShapeProto(this);
                int from_bitField0_ = bitField0_;
                if (dimBuilder_ == null) {
                    if (((bitField0_ & 0x00000001) != 0)) {
                        dim_ = java.util.Collections.unmodifiableList(dim_);
                        bitField0_ = (bitField0_ & ~0x00000001);
                    }
                    result.dim_ = dim_;
                } else {
                    result.dim_ = dimBuilder_.build();
                }
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.TensorShapeProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.TensorShapeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.TensorShapeProto other) {
                if (other == ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance()) return this;
                if (dimBuilder_ == null) {
                    if (!other.dim_.isEmpty()) {
                        if (dim_.isEmpty()) {
                            dim_ = other.dim_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                        } else {
                            ensureDimIsMutable();
                            dim_.addAll(other.dim_);
                        }
                        onChanged();
                    }
                } else {
                    if (!other.dim_.isEmpty()) {
                        if (dimBuilder_.isEmpty()) {
                            dimBuilder_.dispose();
                            dimBuilder_ = null;
                            dim_ = other.dim_;
                            bitField0_ = (bitField0_ & ~0x00000001);
                            dimBuilder_ =
                                    com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                            getDimFieldBuilder() : null;
                        } else {
                            dimBuilder_.addAllMessages(other.dim_);
                        }
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.TensorShapeProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.TensorShapeProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension> dim_ =
                    java.util.Collections.emptyList();
            private void ensureDimIsMutable() {
                if (!((bitField0_ & 0x00000001) != 0)) {
                    dim_ = new java.util.ArrayList<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension>(dim_);
                    bitField0_ |= 0x00000001;
                }
            }

            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder, ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder> dimBuilder_;

            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension> getDimList() {
                if (dimBuilder_ == null) {
                    return java.util.Collections.unmodifiableList(dim_);
                } else {
                    return dimBuilder_.getMessageList();
                }
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public int getDimCount() {
                if (dimBuilder_ == null) {
                    return dim_.size();
                } else {
                    return dimBuilder_.getCount();
                }
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension getDim(int index) {
                if (dimBuilder_ == null) {
                    return dim_.get(index);
                } else {
                    return dimBuilder_.getMessage(index);
                }
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder setDim(
                    int index, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.set(index, value);
                    onChanged();
                } else {
                    dimBuilder_.setMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder setDim(
                    int index, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.set(index, builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.setMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.add(value);
                    onChanged();
                } else {
                    dimBuilder_.addMessage(value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                    int index, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension value) {
                if (dimBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    ensureDimIsMutable();
                    dim_.add(index, value);
                    onChanged();
                } else {
                    dimBuilder_.addMessage(index, value);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.add(builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.addMessage(builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addDim(
                    int index, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder builderForValue) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.add(index, builderForValue.build());
                    onChanged();
                } else {
                    dimBuilder_.addMessage(index, builderForValue.build());
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder addAllDim(
                    java.lang.Iterable<? extends ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension> values) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    com.google.protobuf.AbstractMessageLite.Builder.addAll(
                            values, dim_);
                    onChanged();
                } else {
                    dimBuilder_.addAllMessages(values);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder clearDim() {
                if (dimBuilder_ == null) {
                    dim_ = java.util.Collections.emptyList();
                    bitField0_ = (bitField0_ & ~0x00000001);
                    onChanged();
                } else {
                    dimBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public Builder removeDim(int index) {
                if (dimBuilder_ == null) {
                    ensureDimIsMutable();
                    dim_.remove(index);
                    onChanged();
                } else {
                    dimBuilder_.remove(index);
                }
                return this;
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder getDimBuilder(
                    int index) {
                return getDimFieldBuilder().getBuilder(index);
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
                    int index) {
                if (dimBuilder_ == null) {
                    return dim_.get(index);  } else {
                    return dimBuilder_.getMessageOrBuilder(index);
                }
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<? extends ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder>
            getDimOrBuilderList() {
                if (dimBuilder_ != null) {
                    return dimBuilder_.getMessageOrBuilderList();
                } else {
                    return java.util.Collections.unmodifiableList(dim_);
                }
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder addDimBuilder() {
                return getDimFieldBuilder().addBuilder(
                        ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance());
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder addDimBuilder(
                    int index) {
                return getDimFieldBuilder().addBuilder(
                        index, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.getDefaultInstance());
            }
            /**
             * <code>repeated .onnx.TensorShapeProto.Dimension dim = 1;</code>
             */
            public java.util.List<ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder>
            getDimBuilderList() {
                return getDimFieldBuilder().getBuilderList();
            }
            private com.google.protobuf.RepeatedFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder, ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder>
            getDimFieldBuilder() {
                if (dimBuilder_ == null) {
                    dimBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension, ai.onnx.proto.OnnxMl.TensorShapeProto.Dimension.Builder, ai.onnx.proto.OnnxMl.TensorShapeProto.DimensionOrBuilder>(
                            dim_,
                            ((bitField0_ & 0x00000001) != 0),
                            getParentForChildren(),
                            isClean());
                    dim_ = null;
                }
                return dimBuilder_;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.TensorShapeProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.TensorShapeProto)
        private static final ai.onnx.proto.OnnxMl.TensorShapeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TensorShapeProto();
        }

        public static ai.onnx.proto.OnnxMl.TensorShapeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<TensorShapeProto>
                PARSER = new com.google.protobuf.AbstractParser<TensorShapeProto>() {
            @java.lang.Override
            public TensorShapeProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new TensorShapeProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<TensorShapeProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<TensorShapeProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TensorShapeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface TypeProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.TypeProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return Whether the tensorType field is set.
         */
        boolean hasTensorType();
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return The tensorType.
         */
        ai.onnx.proto.OnnxMl.TypeProto.Tensor getTensorType();
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder();

        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return Whether the sequenceType field is set.
         */
        boolean hasSequenceType();
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return The sequenceType.
         */
        ai.onnx.proto.OnnxMl.TypeProto.Sequence getSequenceType();
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder();

        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         * @return Whether the mapType field is set.
         */
        boolean hasMapType();
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         * @return The mapType.
         */
        ai.onnx.proto.OnnxMl.TypeProto.Map getMapType();
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder();

        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return Whether the sparseTensorType field is set.
         */
        boolean hasSparseTensorType();
        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return The sparseTensorType.
         */
        ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getSparseTensorType();
        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder();

        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         * @return Whether the opaqueType field is set.
         */
        boolean hasOpaqueType();
        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         * @return The opaqueType.
         */
        ai.onnx.proto.OnnxMl.TypeProto.Opaque getOpaqueType();
        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         */
        ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder();

        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return Whether the denotation field is set.
         */
        boolean hasDenotation();
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The denotation.
         */
        java.lang.String getDenotation();
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The bytes for denotation.
         */
        com.google.protobuf.ByteString
        getDenotationBytes();

        public ai.onnx.proto.OnnxMl.TypeProto.ValueCase getValueCase();
    }
    /**
     * <pre>
     * Types
     * The standard ONNX data types.
     * </pre>
     *
     * Protobuf type {@code onnx.TypeProto}
     */
    public static final class TypeProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.TypeProto)
            TypeProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use TypeProto.newBuilder() to construct.
        private TypeProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private TypeProto() {
            denotation_ = "";
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new TypeProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private TypeProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder subBuilder = null;
                            if (valueCase_ == 1) {
                                subBuilder = ((ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_).toBuilder();
                            }
                            value_ =
                                    input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.Tensor.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_);
                                value_ = subBuilder.buildPartial();
                            }
                            valueCase_ = 1;
                            break;
                        }
                        case 34: {
                            ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder subBuilder = null;
                            if (valueCase_ == 4) {
                                subBuilder = ((ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_).toBuilder();
                            }
                            value_ =
                                    input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.Sequence.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_);
                                value_ = subBuilder.buildPartial();
                            }
                            valueCase_ = 4;
                            break;
                        }
                        case 42: {
                            ai.onnx.proto.OnnxMl.TypeProto.Map.Builder subBuilder = null;
                            if (valueCase_ == 5) {
                                subBuilder = ((ai.onnx.proto.OnnxMl.TypeProto.Map) value_).toBuilder();
                            }
                            value_ =
                                    input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.Map.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Map) value_);
                                value_ = subBuilder.buildPartial();
                            }
                            valueCase_ = 5;
                            break;
                        }
                        case 50: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000020;
                            denotation_ = bs;
                            break;
                        }
                        case 58: {
                            ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder subBuilder = null;
                            if (valueCase_ == 7) {
                                subBuilder = ((ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_).toBuilder();
                            }
                            value_ =
                                    input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.Opaque.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_);
                                value_ = subBuilder.buildPartial();
                            }
                            valueCase_ = 7;
                            break;
                        }
                        case 66: {
                            ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder subBuilder = null;
                            if (valueCase_ == 8) {
                                subBuilder = ((ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_).toBuilder();
                            }
                            value_ =
                                    input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.PARSER, extensionRegistry);
                            if (subBuilder != null) {
                                subBuilder.mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_);
                                value_ = subBuilder.buildPartial();
                            }
                            valueCase_ = 8;
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.TypeProto.class, ai.onnx.proto.OnnxMl.TypeProto.Builder.class);
        }

        public interface TensorOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TypeProto.Tensor)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            int getElemType();

            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            boolean hasShape();
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            ai.onnx.proto.OnnxMl.TensorShapeProto getShape();
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             */
            ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder();
        }
        /**
         * Protobuf type {@code onnx.TypeProto.Tensor}
         */
        public static final class Tensor extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TypeProto.Tensor)
                TensorOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Tensor.newBuilder() to construct.
            private Tensor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Tensor() {
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Tensor();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Tensor(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                bitField0_ |= 0x00000001;
                                elemType_ = input.readInt32();
                                break;
                            }
                            case 18: {
                                ai.onnx.proto.OnnxMl.TensorShapeProto.Builder subBuilder = null;
                                if (((bitField0_ & 0x00000002) != 0)) {
                                    subBuilder = shape_.toBuilder();
                                }
                                shape_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorShapeProto.PARSER, extensionRegistry);
                                if (subBuilder != null) {
                                    subBuilder.mergeFrom(shape_);
                                    shape_ = subBuilder.buildPartial();
                                }
                                bitField0_ |= 0x00000002;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.Tensor.class, ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder.class);
            }

            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private int elemType_;
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public int getElemType() {
                return elemType_;
            }

            public static final int SHAPE_FIELD_NUMBER = 2;
            private ai.onnx.proto.OnnxMl.TensorShapeProto shape_;
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            @java.lang.Override
            public boolean hasShape() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto getShape() {
                return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
            }
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getShape());
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32Size(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeMessageSize(2, getShape());
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto.Tensor)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TypeProto.Tensor other = (ai.onnx.proto.OnnxMl.TypeProto.Tensor) obj;

                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (getElemType()
                            != other.getElemType()) return false;
                }
                if (hasShape() != other.hasShape()) return false;
                if (hasShape()) {
                    if (!getShape()
                            .equals(other.getShape())) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType();
                }
                if (hasShape()) {
                    hash = (37 * hash) + SHAPE_FIELD_NUMBER;
                    hash = (53 * hash) + getShape().hashCode();
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto.Tensor prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code onnx.TypeProto.Tensor}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TypeProto.Tensor)
                    ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TypeProto.Tensor.class, ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TypeProto.Tensor.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                        getShapeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    elemType_ = 0;
                    bitField0_ = (bitField0_ & ~0x00000001);
                    if (shapeBuilder_ == null) {
                        shape_ = null;
                    } else {
                        shapeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Tensor_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Tensor getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Tensor build() {
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Tensor buildPartial() {
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor result = new ai.onnx.proto.OnnxMl.TypeProto.Tensor(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        if (shapeBuilder_ == null) {
                            result.shape_ = shape_;
                        } else {
                            result.shape_ = shapeBuilder_.build();
                        }
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TypeProto.Tensor) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Tensor)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto.Tensor other) {
                    if (other == ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        setElemType(other.getElemType());
                    }
                    if (other.hasShape()) {
                        mergeShape(other.getShape());
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto.Tensor) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private int elemType_ ;
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                @java.lang.Override
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return The elemType.
                 */
                @java.lang.Override
                public int getElemType() {
                    return elemType_;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @param value The elemType to set.
                 * @return This builder for chaining.
                 */
                public Builder setElemType(int value) {
                    bitField0_ |= 0x00000001;
                    elemType_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = 0;
                    onChanged();
                    return this;
                }

                private ai.onnx.proto.OnnxMl.TensorShapeProto shape_;
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder> shapeBuilder_;
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 * @return Whether the shape field is set.
                 */
                public boolean hasShape() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 * @return The shape.
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProto getShape() {
                    if (shapeBuilder_ == null) {
                        return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
                    } else {
                        return shapeBuilder_.getMessage();
                    }
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(ai.onnx.proto.OnnxMl.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        shape_ = value;
                        onChanged();
                    } else {
                        shapeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(
                        ai.onnx.proto.OnnxMl.TensorShapeProto.Builder builderForValue) {
                    if (shapeBuilder_ == null) {
                        shape_ = builderForValue.build();
                        onChanged();
                    } else {
                        shapeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder mergeShape(ai.onnx.proto.OnnxMl.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                                shape_ != null &&
                                shape_ != ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance()) {
                            shape_ =
                                    ai.onnx.proto.OnnxMl.TensorShapeProto.newBuilder(shape_).mergeFrom(value).buildPartial();
                        } else {
                            shape_ = value;
                        }
                        onChanged();
                    } else {
                        shapeBuilder_.mergeFrom(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder clearShape() {
                    if (shapeBuilder_ == null) {
                        shape_ = null;
                        onChanged();
                    } else {
                        shapeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProto.Builder getShapeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return getShapeFieldBuilder().getBuilder();
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                    if (shapeBuilder_ != null) {
                        return shapeBuilder_.getMessageOrBuilder();
                    } else {
                        return shape_ == null ?
                                ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
                    }
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder>
                getShapeFieldBuilder() {
                    if (shapeBuilder_ == null) {
                        shapeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                                ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder>(
                                getShape(),
                                getParentForChildren(),
                                isClean());
                        shape_ = null;
                    }
                    return shapeBuilder_;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TypeProto.Tensor)
            }

            // @@protoc_insertion_point(class_scope:onnx.TypeProto.Tensor)
            private static final ai.onnx.proto.OnnxMl.TypeProto.Tensor DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto.Tensor();
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Tensor getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Tensor>
                    PARSER = new com.google.protobuf.AbstractParser<Tensor>() {
                @java.lang.Override
                public Tensor parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Tensor(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Tensor> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Tensor> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Tensor getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        public interface SequenceOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TypeProto.Sequence)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            ai.onnx.proto.OnnxMl.TypeProto getElemType();
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             */
            ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder();
        }
        /**
         * <pre>
         * repeated T
         * </pre>
         *
         * Protobuf type {@code onnx.TypeProto.Sequence}
         */
        public static final class Sequence extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TypeProto.Sequence)
                SequenceOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Sequence.newBuilder() to construct.
            private Sequence(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Sequence() {
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Sequence();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Sequence(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                ai.onnx.proto.OnnxMl.TypeProto.Builder subBuilder = null;
                                if (((bitField0_ & 0x00000001) != 0)) {
                                    subBuilder = elemType_.toBuilder();
                                }
                                elemType_ = input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.PARSER, extensionRegistry);
                                if (subBuilder != null) {
                                    subBuilder.mergeFrom(elemType_);
                                    elemType_ = subBuilder.buildPartial();
                                }
                                bitField0_ |= 0x00000001;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.Sequence.class, ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder.class);
            }

            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private ai.onnx.proto.OnnxMl.TypeProto elemType_;
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto getElemType() {
                return elemType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : elemType_;
            }
            /**
             * <pre>
             * The type and optional shape of each element of the sequence.
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto elem_type = 1;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {
                return elemType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : elemType_;
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeMessage(1, getElemType());
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeMessageSize(1, getElemType());
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto.Sequence)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TypeProto.Sequence other = (ai.onnx.proto.OnnxMl.TypeProto.Sequence) obj;

                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (!getElemType()
                            .equals(other.getElemType())) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType().hashCode();
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto.Sequence prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * repeated T
             * </pre>
             *
             * Protobuf type {@code onnx.TypeProto.Sequence}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TypeProto.Sequence)
                    ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TypeProto.Sequence.class, ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TypeProto.Sequence.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                        getElemTypeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    if (elemTypeBuilder_ == null) {
                        elemType_ = null;
                    } else {
                        elemTypeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000001);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Sequence_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Sequence getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Sequence build() {
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Sequence buildPartial() {
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence result = new ai.onnx.proto.OnnxMl.TypeProto.Sequence(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        if (elemTypeBuilder_ == null) {
                            result.elemType_ = elemType_;
                        } else {
                            result.elemType_ = elemTypeBuilder_.build();
                        }
                        to_bitField0_ |= 0x00000001;
                    }
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TypeProto.Sequence) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Sequence)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto.Sequence other) {
                    if (other == ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        mergeElemType(other.getElemType());
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto.Sequence) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private ai.onnx.proto.OnnxMl.TypeProto elemType_;
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder> elemTypeBuilder_;
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 * @return The elemType.
                 */
                public ai.onnx.proto.OnnxMl.TypeProto getElemType() {
                    if (elemTypeBuilder_ == null) {
                        return elemType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : elemType_;
                    } else {
                        return elemTypeBuilder_.getMessage();
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(ai.onnx.proto.OnnxMl.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        elemType_ = value;
                        onChanged();
                    } else {
                        elemTypeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000001;
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder setElemType(
                        ai.onnx.proto.OnnxMl.TypeProto.Builder builderForValue) {
                    if (elemTypeBuilder_ == null) {
                        elemType_ = builderForValue.build();
                        onChanged();
                    } else {
                        elemTypeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000001;
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder mergeElemType(ai.onnx.proto.OnnxMl.TypeProto value) {
                    if (elemTypeBuilder_ == null) {
                        if (((bitField0_ & 0x00000001) != 0) &&
                                elemType_ != null &&
                                elemType_ != ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance()) {
                            elemType_ =
                                    ai.onnx.proto.OnnxMl.TypeProto.newBuilder(elemType_).mergeFrom(value).buildPartial();
                        } else {
                            elemType_ = value;
                        }
                        onChanged();
                    } else {
                        elemTypeBuilder_.mergeFrom(value);
                    }
                    bitField0_ |= 0x00000001;
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public Builder clearElemType() {
                    if (elemTypeBuilder_ == null) {
                        elemType_ = null;
                        onChanged();
                    } else {
                        elemTypeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000001);
                    return this;
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public ai.onnx.proto.OnnxMl.TypeProto.Builder getElemTypeBuilder() {
                    bitField0_ |= 0x00000001;
                    onChanged();
                    return getElemTypeFieldBuilder().getBuilder();
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getElemTypeOrBuilder() {
                    if (elemTypeBuilder_ != null) {
                        return elemTypeBuilder_.getMessageOrBuilder();
                    } else {
                        return elemType_ == null ?
                                ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : elemType_;
                    }
                }
                /**
                 * <pre>
                 * The type and optional shape of each element of the sequence.
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto elem_type = 1;</code>
                 */
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>
                getElemTypeFieldBuilder() {
                    if (elemTypeBuilder_ == null) {
                        elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                                ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>(
                                getElemType(),
                                getParentForChildren(),
                                isClean());
                        elemType_ = null;
                    }
                    return elemTypeBuilder_;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TypeProto.Sequence)
            }

            // @@protoc_insertion_point(class_scope:onnx.TypeProto.Sequence)
            private static final ai.onnx.proto.OnnxMl.TypeProto.Sequence DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto.Sequence();
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Sequence getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Sequence>
                    PARSER = new com.google.protobuf.AbstractParser<Sequence>() {
                @java.lang.Override
                public Sequence parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Sequence(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Sequence> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Sequence> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Sequence getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        public interface MapOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TypeProto.Map)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return Whether the keyType field is set.
             */
            boolean hasKeyType();
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return The keyType.
             */
            int getKeyType();

            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             * @return Whether the valueType field is set.
             */
            boolean hasValueType();
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             * @return The valueType.
             */
            ai.onnx.proto.OnnxMl.TypeProto getValueType();
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             */
            ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder();
        }
        /**
         * <pre>
         * map&lt;K,V&gt;
         * </pre>
         *
         * Protobuf type {@code onnx.TypeProto.Map}
         */
        public static final class Map extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TypeProto.Map)
                MapOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Map.newBuilder() to construct.
            private Map(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Map() {
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Map();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Map(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                bitField0_ |= 0x00000001;
                                keyType_ = input.readInt32();
                                break;
                            }
                            case 18: {
                                ai.onnx.proto.OnnxMl.TypeProto.Builder subBuilder = null;
                                if (((bitField0_ & 0x00000002) != 0)) {
                                    subBuilder = valueType_.toBuilder();
                                }
                                valueType_ = input.readMessage(ai.onnx.proto.OnnxMl.TypeProto.PARSER, extensionRegistry);
                                if (subBuilder != null) {
                                    subBuilder.mergeFrom(valueType_);
                                    valueType_ = subBuilder.buildPartial();
                                }
                                bitField0_ |= 0x00000002;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Map_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.Map.class, ai.onnx.proto.OnnxMl.TypeProto.Map.Builder.class);
            }

            private int bitField0_;
            public static final int KEY_TYPE_FIELD_NUMBER = 1;
            private int keyType_;
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return Whether the keyType field is set.
             */
            @java.lang.Override
            public boolean hasKeyType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
             * </pre>
             *
             * <code>optional int32 key_type = 1;</code>
             * @return The keyType.
             */
            @java.lang.Override
            public int getKeyType() {
                return keyType_;
            }

            public static final int VALUE_TYPE_FIELD_NUMBER = 2;
            private ai.onnx.proto.OnnxMl.TypeProto valueType_;
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             * @return Whether the valueType field is set.
             */
            @java.lang.Override
            public boolean hasValueType() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             * @return The valueType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto getValueType() {
                return valueType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : valueType_;
            }
            /**
             * <pre>
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional .onnx.TypeProto value_type = 2;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder() {
                return valueType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : valueType_;
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, keyType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getValueType());
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32Size(1, keyType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeMessageSize(2, getValueType());
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto.Map)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TypeProto.Map other = (ai.onnx.proto.OnnxMl.TypeProto.Map) obj;

                if (hasKeyType() != other.hasKeyType()) return false;
                if (hasKeyType()) {
                    if (getKeyType()
                            != other.getKeyType()) return false;
                }
                if (hasValueType() != other.hasValueType()) return false;
                if (hasValueType()) {
                    if (!getValueType()
                            .equals(other.getValueType())) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasKeyType()) {
                    hash = (37 * hash) + KEY_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getKeyType();
                }
                if (hasValueType()) {
                    hash = (37 * hash) + VALUE_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getValueType().hashCode();
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Map parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto.Map prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * <pre>
             * map&lt;K,V&gt;
             * </pre>
             *
             * Protobuf type {@code onnx.TypeProto.Map}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TypeProto.Map)
                    ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Map_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TypeProto.Map.class, ai.onnx.proto.OnnxMl.TypeProto.Map.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TypeProto.Map.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                        getValueTypeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    keyType_ = 0;
                    bitField0_ = (bitField0_ & ~0x00000001);
                    if (valueTypeBuilder_ == null) {
                        valueType_ = null;
                    } else {
                        valueTypeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Map_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Map getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Map build() {
                    ai.onnx.proto.OnnxMl.TypeProto.Map result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Map buildPartial() {
                    ai.onnx.proto.OnnxMl.TypeProto.Map result = new ai.onnx.proto.OnnxMl.TypeProto.Map(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.keyType_ = keyType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        if (valueTypeBuilder_ == null) {
                            result.valueType_ = valueType_;
                        } else {
                            result.valueType_ = valueTypeBuilder_.build();
                        }
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TypeProto.Map) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Map)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto.Map other) {
                    if (other == ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance()) return this;
                    if (other.hasKeyType()) {
                        setKeyType(other.getKeyType());
                    }
                    if (other.hasValueType()) {
                        mergeValueType(other.getValueType());
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TypeProto.Map parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto.Map) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private int keyType_ ;
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return Whether the keyType field is set.
                 */
                @java.lang.Override
                public boolean hasKeyType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return The keyType.
                 */
                @java.lang.Override
                public int getKeyType() {
                    return keyType_;
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @param value The keyType to set.
                 * @return This builder for chaining.
                 */
                public Builder setKeyType(int value) {
                    bitField0_ |= 0x00000001;
                    keyType_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
                 * </pre>
                 *
                 * <code>optional int32 key_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearKeyType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    keyType_ = 0;
                    onChanged();
                    return this;
                }

                private ai.onnx.proto.OnnxMl.TypeProto valueType_;
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder> valueTypeBuilder_;
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 * @return Whether the valueType field is set.
                 */
                public boolean hasValueType() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 * @return The valueType.
                 */
                public ai.onnx.proto.OnnxMl.TypeProto getValueType() {
                    if (valueTypeBuilder_ == null) {
                        return valueType_ == null ? ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : valueType_;
                    } else {
                        return valueTypeBuilder_.getMessage();
                    }
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public Builder setValueType(ai.onnx.proto.OnnxMl.TypeProto value) {
                    if (valueTypeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        valueType_ = value;
                        onChanged();
                    } else {
                        valueTypeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public Builder setValueType(
                        ai.onnx.proto.OnnxMl.TypeProto.Builder builderForValue) {
                    if (valueTypeBuilder_ == null) {
                        valueType_ = builderForValue.build();
                        onChanged();
                    } else {
                        valueTypeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public Builder mergeValueType(ai.onnx.proto.OnnxMl.TypeProto value) {
                    if (valueTypeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                                valueType_ != null &&
                                valueType_ != ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance()) {
                            valueType_ =
                                    ai.onnx.proto.OnnxMl.TypeProto.newBuilder(valueType_).mergeFrom(value).buildPartial();
                        } else {
                            valueType_ = value;
                        }
                        onChanged();
                    } else {
                        valueTypeBuilder_.mergeFrom(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public Builder clearValueType() {
                    if (valueTypeBuilder_ == null) {
                        valueType_ = null;
                        onChanged();
                    } else {
                        valueTypeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TypeProto.Builder getValueTypeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return getValueTypeFieldBuilder().getBuilder();
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TypeProtoOrBuilder getValueTypeOrBuilder() {
                    if (valueTypeBuilder_ != null) {
                        return valueTypeBuilder_.getMessageOrBuilder();
                    } else {
                        return valueType_ == null ?
                                ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance() : valueType_;
                    }
                }
                /**
                 * <pre>
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional .onnx.TypeProto value_type = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>
                getValueTypeFieldBuilder() {
                    if (valueTypeBuilder_ == null) {
                        valueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                                ai.onnx.proto.OnnxMl.TypeProto, ai.onnx.proto.OnnxMl.TypeProto.Builder, ai.onnx.proto.OnnxMl.TypeProtoOrBuilder>(
                                getValueType(),
                                getParentForChildren(),
                                isClean());
                        valueType_ = null;
                    }
                    return valueTypeBuilder_;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TypeProto.Map)
            }

            // @@protoc_insertion_point(class_scope:onnx.TypeProto.Map)
            private static final ai.onnx.proto.OnnxMl.TypeProto.Map DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto.Map();
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Map getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Map>
                    PARSER = new com.google.protobuf.AbstractParser<Map>() {
                @java.lang.Override
                public Map parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Map(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Map> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Map> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Map getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        public interface SparseTensorOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TypeProto.SparseTensor)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            boolean hasElemType();
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            int getElemType();

            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            boolean hasShape();
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            ai.onnx.proto.OnnxMl.TensorShapeProto getShape();
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             */
            ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder();
        }
        /**
         * Protobuf type {@code onnx.TypeProto.SparseTensor}
         */
        public static final class SparseTensor extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TypeProto.SparseTensor)
                SparseTensorOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use SparseTensor.newBuilder() to construct.
            private SparseTensor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private SparseTensor() {
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new SparseTensor();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private SparseTensor(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 8: {
                                bitField0_ |= 0x00000001;
                                elemType_ = input.readInt32();
                                break;
                            }
                            case 18: {
                                ai.onnx.proto.OnnxMl.TensorShapeProto.Builder subBuilder = null;
                                if (((bitField0_ & 0x00000002) != 0)) {
                                    subBuilder = shape_.toBuilder();
                                }
                                shape_ = input.readMessage(ai.onnx.proto.OnnxMl.TensorShapeProto.PARSER, extensionRegistry);
                                if (subBuilder != null) {
                                    subBuilder.mergeFrom(shape_);
                                    shape_ = subBuilder.buildPartial();
                                }
                                bitField0_ |= 0x00000002;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.class, ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder.class);
            }

            private int bitField0_;
            public static final int ELEM_TYPE_FIELD_NUMBER = 1;
            private int elemType_;
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return Whether the elemType field is set.
             */
            @java.lang.Override
            public boolean hasElemType() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * This field MUST NOT have the value of UNDEFINED
             * This field MUST have a valid TensorProto.DataType value
             * This field MUST be present for this version of the IR.
             * </pre>
             *
             * <code>optional int32 elem_type = 1;</code>
             * @return The elemType.
             */
            @java.lang.Override
            public int getElemType() {
                return elemType_;
            }

            public static final int SHAPE_FIELD_NUMBER = 2;
            private ai.onnx.proto.OnnxMl.TensorShapeProto shape_;
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return Whether the shape field is set.
             */
            @java.lang.Override
            public boolean hasShape() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             * @return The shape.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProto getShape() {
                return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
            }
            /**
             * <code>optional .onnx.TensorShapeProto shape = 2;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    output.writeInt32(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    output.writeMessage(2, getShape());
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeInt32Size(1, elemType_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.CodedOutputStream
                            .computeMessageSize(2, getShape());
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto.SparseTensor)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TypeProto.SparseTensor other = (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) obj;

                if (hasElemType() != other.hasElemType()) return false;
                if (hasElemType()) {
                    if (getElemType()
                            != other.getElemType()) return false;
                }
                if (hasShape() != other.hasShape()) return false;
                if (hasShape()) {
                    if (!getShape()
                            .equals(other.getShape())) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasElemType()) {
                    hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getElemType();
                }
                if (hasShape()) {
                    hash = (37 * hash) + SHAPE_FIELD_NUMBER;
                    hash = (53 * hash) + getShape().hashCode();
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto.SparseTensor prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code onnx.TypeProto.SparseTensor}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TypeProto.SparseTensor)
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.class, ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                        getShapeFieldBuilder();
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    elemType_ = 0;
                    bitField0_ = (bitField0_ & ~0x00000001);
                    if (shapeBuilder_ == null) {
                        shape_ = null;
                    } else {
                        shapeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_SparseTensor_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor build() {
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor buildPartial() {
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor result = new ai.onnx.proto.OnnxMl.TypeProto.SparseTensor(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        result.elemType_ = elemType_;
                        to_bitField0_ |= 0x00000001;
                    }
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        if (shapeBuilder_ == null) {
                            result.shape_ = shape_;
                        } else {
                            result.shape_ = shapeBuilder_.build();
                        }
                        to_bitField0_ |= 0x00000002;
                    }
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.SparseTensor)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto.SparseTensor other) {
                    if (other == ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance()) return this;
                    if (other.hasElemType()) {
                        setElemType(other.getElemType());
                    }
                    if (other.hasShape()) {
                        mergeShape(other.getShape());
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private int elemType_ ;
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return Whether the elemType field is set.
                 */
                @java.lang.Override
                public boolean hasElemType() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return The elemType.
                 */
                @java.lang.Override
                public int getElemType() {
                    return elemType_;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @param value The elemType to set.
                 * @return This builder for chaining.
                 */
                public Builder setElemType(int value) {
                    bitField0_ |= 0x00000001;
                    elemType_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * This field MUST NOT have the value of UNDEFINED
                 * This field MUST have a valid TensorProto.DataType value
                 * This field MUST be present for this version of the IR.
                 * </pre>
                 *
                 * <code>optional int32 elem_type = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearElemType() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    elemType_ = 0;
                    onChanged();
                    return this;
                }

                private ai.onnx.proto.OnnxMl.TensorShapeProto shape_;
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder> shapeBuilder_;
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 * @return Whether the shape field is set.
                 */
                public boolean hasShape() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 * @return The shape.
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProto getShape() {
                    if (shapeBuilder_ == null) {
                        return shape_ == null ? ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
                    } else {
                        return shapeBuilder_.getMessage();
                    }
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(ai.onnx.proto.OnnxMl.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (value == null) {
                            throw new NullPointerException();
                        }
                        shape_ = value;
                        onChanged();
                    } else {
                        shapeBuilder_.setMessage(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder setShape(
                        ai.onnx.proto.OnnxMl.TensorShapeProto.Builder builderForValue) {
                    if (shapeBuilder_ == null) {
                        shape_ = builderForValue.build();
                        onChanged();
                    } else {
                        shapeBuilder_.setMessage(builderForValue.build());
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder mergeShape(ai.onnx.proto.OnnxMl.TensorShapeProto value) {
                    if (shapeBuilder_ == null) {
                        if (((bitField0_ & 0x00000002) != 0) &&
                                shape_ != null &&
                                shape_ != ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance()) {
                            shape_ =
                                    ai.onnx.proto.OnnxMl.TensorShapeProto.newBuilder(shape_).mergeFrom(value).buildPartial();
                        } else {
                            shape_ = value;
                        }
                        onChanged();
                    } else {
                        shapeBuilder_.mergeFrom(value);
                    }
                    bitField0_ |= 0x00000002;
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public Builder clearShape() {
                    if (shapeBuilder_ == null) {
                        shape_ = null;
                        onChanged();
                    } else {
                        shapeBuilder_.clear();
                    }
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProto.Builder getShapeBuilder() {
                    bitField0_ |= 0x00000002;
                    onChanged();
                    return getShapeFieldBuilder().getBuilder();
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                public ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder getShapeOrBuilder() {
                    if (shapeBuilder_ != null) {
                        return shapeBuilder_.getMessageOrBuilder();
                    } else {
                        return shape_ == null ?
                                ai.onnx.proto.OnnxMl.TensorShapeProto.getDefaultInstance() : shape_;
                    }
                }
                /**
                 * <code>optional .onnx.TensorShapeProto shape = 2;</code>
                 */
                private com.google.protobuf.SingleFieldBuilderV3<
                        ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder>
                getShapeFieldBuilder() {
                    if (shapeBuilder_ == null) {
                        shapeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                                ai.onnx.proto.OnnxMl.TensorShapeProto, ai.onnx.proto.OnnxMl.TensorShapeProto.Builder, ai.onnx.proto.OnnxMl.TensorShapeProtoOrBuilder>(
                                getShape(),
                                getParentForChildren(),
                                isClean());
                        shape_ = null;
                    }
                    return shapeBuilder_;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TypeProto.SparseTensor)
            }

            // @@protoc_insertion_point(class_scope:onnx.TypeProto.SparseTensor)
            private static final ai.onnx.proto.OnnxMl.TypeProto.SparseTensor DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto.SparseTensor();
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<SparseTensor>
                    PARSER = new com.google.protobuf.AbstractParser<SparseTensor>() {
                @java.lang.Override
                public SparseTensor parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new SparseTensor(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<SparseTensor> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<SparseTensor> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        public interface OpaqueOrBuilder extends
                // @@protoc_insertion_point(interface_extends:onnx.TypeProto.Opaque)
                com.google.protobuf.MessageOrBuilder {

            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return Whether the domain field is set.
             */
            boolean hasDomain();
            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The domain.
             */
            java.lang.String getDomain();
            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The bytes for domain.
             */
            com.google.protobuf.ByteString
            getDomainBytes();

            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return Whether the name field is set.
             */
            boolean hasName();
            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The name.
             */
            java.lang.String getName();
            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The bytes for name.
             */
            com.google.protobuf.ByteString
            getNameBytes();
        }
        /**
         * Protobuf type {@code onnx.TypeProto.Opaque}
         */
        public static final class Opaque extends
                com.google.protobuf.GeneratedMessageV3 implements
                // @@protoc_insertion_point(message_implements:onnx.TypeProto.Opaque)
                OpaqueOrBuilder {
            private static final long serialVersionUID = 0L;
            // Use Opaque.newBuilder() to construct.
            private Opaque(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
                super(builder);
            }
            private Opaque() {
                domain_ = "";
                name_ = "";
            }

            @java.lang.Override
            @SuppressWarnings({"unused"})
            protected java.lang.Object newInstance(
                    UnusedPrivateParameter unused) {
                return new Opaque();
            }

            @java.lang.Override
            public final com.google.protobuf.UnknownFieldSet
            getUnknownFields() {
                return this.unknownFields;
            }
            private Opaque(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                this();
                if (extensionRegistry == null) {
                    throw new java.lang.NullPointerException();
                }
                int mutable_bitField0_ = 0;
                com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                        com.google.protobuf.UnknownFieldSet.newBuilder();
                try {
                    boolean done = false;
                    while (!done) {
                        int tag = input.readTag();
                        switch (tag) {
                            case 0:
                                done = true;
                                break;
                            case 10: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                bitField0_ |= 0x00000001;
                                domain_ = bs;
                                break;
                            }
                            case 18: {
                                com.google.protobuf.ByteString bs = input.readBytes();
                                bitField0_ |= 0x00000002;
                                name_ = bs;
                                break;
                            }
                            default: {
                                if (!parseUnknownField(
                                        input, unknownFields, extensionRegistry, tag)) {
                                    done = true;
                                }
                                break;
                            }
                        }
                    }
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    throw e.setUnfinishedMessage(this);
                } catch (java.io.IOException e) {
                    throw new com.google.protobuf.InvalidProtocolBufferException(
                            e).setUnfinishedMessage(this);
                } finally {
                    this.unknownFields = unknownFields.build();
                    makeExtensionsImmutable();
                }
            }
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Opaque_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.Opaque.class, ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder.class);
            }

            private int bitField0_;
            public static final int DOMAIN_FIELD_NUMBER = 1;
            private volatile java.lang.Object domain_;
            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return Whether the domain field is set.
             */
            @java.lang.Override
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The domain.
             */
            @java.lang.Override
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * When missing, the domain is the same as the model's.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The bytes for domain.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }

            public static final int NAME_FIELD_NUMBER = 2;
            private volatile java.lang.Object name_;
            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return Whether the name field is set.
             */
            @java.lang.Override
            public boolean hasName() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The name.
             */
            @java.lang.Override
            public java.lang.String getName() {
                java.lang.Object ref = name_;
                if (ref instanceof java.lang.String) {
                    return (java.lang.String) ref;
                } else {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        name_ = s;
                    }
                    return s;
                }
            }
            /**
             * <pre>
             * The name is optional but significant when provided.
             * </pre>
             *
             * <code>optional string name = 2;</code>
             * @return The bytes for name.
             */
            @java.lang.Override
            public com.google.protobuf.ByteString
            getNameBytes() {
                java.lang.Object ref = name_;
                if (ref instanceof java.lang.String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    name_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }

            private byte memoizedIsInitialized = -1;
            @java.lang.Override
            public final boolean isInitialized() {
                byte isInitialized = memoizedIsInitialized;
                if (isInitialized == 1) return true;
                if (isInitialized == 0) return false;

                memoizedIsInitialized = 1;
                return true;
            }

            @java.lang.Override
            public void writeTo(com.google.protobuf.CodedOutputStream output)
                    throws java.io.IOException {
                if (((bitField0_ & 0x00000001) != 0)) {
                    com.google.protobuf.GeneratedMessageV3.writeString(output, 1, domain_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
                }
                unknownFields.writeTo(output);
            }

            @java.lang.Override
            public int getSerializedSize() {
                int size = memoizedSize;
                if (size != -1) return size;

                size = 0;
                if (((bitField0_ & 0x00000001) != 0)) {
                    size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, domain_);
                }
                if (((bitField0_ & 0x00000002) != 0)) {
                    size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
                }
                size += unknownFields.getSerializedSize();
                memoizedSize = size;
                return size;
            }

            @java.lang.Override
            public boolean equals(final java.lang.Object obj) {
                if (obj == this) {
                    return true;
                }
                if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto.Opaque)) {
                    return super.equals(obj);
                }
                ai.onnx.proto.OnnxMl.TypeProto.Opaque other = (ai.onnx.proto.OnnxMl.TypeProto.Opaque) obj;

                if (hasDomain() != other.hasDomain()) return false;
                if (hasDomain()) {
                    if (!getDomain()
                            .equals(other.getDomain())) return false;
                }
                if (hasName() != other.hasName()) return false;
                if (hasName()) {
                    if (!getName()
                            .equals(other.getName())) return false;
                }
                if (!unknownFields.equals(other.unknownFields)) return false;
                return true;
            }

            @java.lang.Override
            public int hashCode() {
                if (memoizedHashCode != 0) {
                    return memoizedHashCode;
                }
                int hash = 41;
                hash = (19 * hash) + getDescriptor().hashCode();
                if (hasDomain()) {
                    hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                    hash = (53 * hash) + getDomain().hashCode();
                }
                if (hasName()) {
                    hash = (37 * hash) + NAME_FIELD_NUMBER;
                    hash = (53 * hash) + getName().hashCode();
                }
                hash = (29 * hash) + unknownFields.hashCode();
                memoizedHashCode = hash;
                return hash;
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    java.nio.ByteBuffer data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    java.nio.ByteBuffer data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    com.google.protobuf.ByteString data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    com.google.protobuf.ByteString data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(byte[] data)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    byte[] data,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return PARSER.parseFrom(data, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseDelimitedFrom(java.io.InputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseDelimitedFrom(
                    java.io.InputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    com.google.protobuf.CodedInputStream input)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input);
            }
            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque parseFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                return com.google.protobuf.GeneratedMessageV3
                        .parseWithIOException(PARSER, input, extensionRegistry);
            }

            @java.lang.Override
            public Builder newBuilderForType() { return newBuilder(); }
            public static Builder newBuilder() {
                return DEFAULT_INSTANCE.toBuilder();
            }
            public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto.Opaque prototype) {
                return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
            }
            @java.lang.Override
            public Builder toBuilder() {
                return this == DEFAULT_INSTANCE
                        ? new Builder() : new Builder().mergeFrom(this);
            }

            @java.lang.Override
            protected Builder newBuilderForType(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                Builder builder = new Builder(parent);
                return builder;
            }
            /**
             * Protobuf type {@code onnx.TypeProto.Opaque}
             */
            public static final class Builder extends
                    com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                    // @@protoc_insertion_point(builder_implements:onnx.TypeProto.Opaque)
                    ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder {
                public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;
                }

                @java.lang.Override
                protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
                internalGetFieldAccessorTable() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Opaque_fieldAccessorTable
                            .ensureFieldAccessorsInitialized(
                                    ai.onnx.proto.OnnxMl.TypeProto.Opaque.class, ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder.class);
                }

                // Construct using ai.onnx.proto.OnnxMl.TypeProto.Opaque.newBuilder()
                private Builder() {
                    maybeForceBuilderInitialization();
                }

                private Builder(
                        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                    super(parent);
                    maybeForceBuilderInitialization();
                }
                private void maybeForceBuilderInitialization() {
                    if (com.google.protobuf.GeneratedMessageV3
                            .alwaysUseFieldBuilders) {
                    }
                }
                @java.lang.Override
                public Builder clear() {
                    super.clear();
                    domain_ = "";
                    bitField0_ = (bitField0_ & ~0x00000001);
                    name_ = "";
                    bitField0_ = (bitField0_ & ~0x00000002);
                    return this;
                }

                @java.lang.Override
                public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
                    return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_Opaque_descriptor;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Opaque getDefaultInstanceForType() {
                    return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Opaque build() {
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque result = buildPartial();
                    if (!result.isInitialized()) {
                        throw newUninitializedMessageException(result);
                    }
                    return result;
                }

                @java.lang.Override
                public ai.onnx.proto.OnnxMl.TypeProto.Opaque buildPartial() {
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque result = new ai.onnx.proto.OnnxMl.TypeProto.Opaque(this);
                    int from_bitField0_ = bitField0_;
                    int to_bitField0_ = 0;
                    if (((from_bitField0_ & 0x00000001) != 0)) {
                        to_bitField0_ |= 0x00000001;
                    }
                    result.domain_ = domain_;
                    if (((from_bitField0_ & 0x00000002) != 0)) {
                        to_bitField0_ |= 0x00000002;
                    }
                    result.name_ = name_;
                    result.bitField0_ = to_bitField0_;
                    onBuilt();
                    return result;
                }

                @java.lang.Override
                public Builder clone() {
                    return super.clone();
                }
                @java.lang.Override
                public Builder setField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.setField(field, value);
                }
                @java.lang.Override
                public Builder clearField(
                        com.google.protobuf.Descriptors.FieldDescriptor field) {
                    return super.clearField(field);
                }
                @java.lang.Override
                public Builder clearOneof(
                        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                    return super.clearOneof(oneof);
                }
                @java.lang.Override
                public Builder setRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        int index, java.lang.Object value) {
                    return super.setRepeatedField(field, index, value);
                }
                @java.lang.Override
                public Builder addRepeatedField(
                        com.google.protobuf.Descriptors.FieldDescriptor field,
                        java.lang.Object value) {
                    return super.addRepeatedField(field, value);
                }
                @java.lang.Override
                public Builder mergeFrom(com.google.protobuf.Message other) {
                    if (other instanceof ai.onnx.proto.OnnxMl.TypeProto.Opaque) {
                        return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto.Opaque)other);
                    } else {
                        super.mergeFrom(other);
                        return this;
                    }
                }

                public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto.Opaque other) {
                    if (other == ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance()) return this;
                    if (other.hasDomain()) {
                        bitField0_ |= 0x00000001;
                        domain_ = other.domain_;
                        onChanged();
                    }
                    if (other.hasName()) {
                        bitField0_ |= 0x00000002;
                        name_ = other.name_;
                        onChanged();
                    }
                    this.mergeUnknownFields(other.unknownFields);
                    onChanged();
                    return this;
                }

                @java.lang.Override
                public final boolean isInitialized() {
                    return true;
                }

                @java.lang.Override
                public Builder mergeFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws java.io.IOException {
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque parsedMessage = null;
                    try {
                        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                        parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto.Opaque) e.getUnfinishedMessage();
                        throw e.unwrapIOException();
                    } finally {
                        if (parsedMessage != null) {
                            mergeFrom(parsedMessage);
                        }
                    }
                    return this;
                }
                private int bitField0_;

                private java.lang.Object domain_ = "";
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @return Whether the domain field is set.
                 */
                public boolean hasDomain() {
                    return ((bitField0_ & 0x00000001) != 0);
                }
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @return The domain.
                 */
                public java.lang.String getDomain() {
                    java.lang.Object ref = domain_;
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                                (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (bs.isValidUtf8()) {
                            domain_ = s;
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @return The bytes for domain.
                 */
                public com.google.protobuf.ByteString
                getDomainBytes() {
                    java.lang.Object ref = domain_;
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                                com.google.protobuf.ByteString.copyFromUtf8(
                                        (java.lang.String) ref);
                        domain_ = b;
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @param value The domain to set.
                 * @return This builder for chaining.
                 */
                public Builder setDomain(
                        java.lang.String value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000001;
                    domain_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearDomain() {
                    bitField0_ = (bitField0_ & ~0x00000001);
                    domain_ = getDefaultInstance().getDomain();
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * When missing, the domain is the same as the model's.
                 * </pre>
                 *
                 * <code>optional string domain = 1;</code>
                 * @param value The bytes for domain to set.
                 * @return This builder for chaining.
                 */
                public Builder setDomainBytes(
                        com.google.protobuf.ByteString value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000001;
                    domain_ = value;
                    onChanged();
                    return this;
                }

                private java.lang.Object name_ = "";
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @return Whether the name field is set.
                 */
                public boolean hasName() {
                    return ((bitField0_ & 0x00000002) != 0);
                }
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @return The name.
                 */
                public java.lang.String getName() {
                    java.lang.Object ref = name_;
                    if (!(ref instanceof java.lang.String)) {
                        com.google.protobuf.ByteString bs =
                                (com.google.protobuf.ByteString) ref;
                        java.lang.String s = bs.toStringUtf8();
                        if (bs.isValidUtf8()) {
                            name_ = s;
                        }
                        return s;
                    } else {
                        return (java.lang.String) ref;
                    }
                }
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @return The bytes for name.
                 */
                public com.google.protobuf.ByteString
                getNameBytes() {
                    java.lang.Object ref = name_;
                    if (ref instanceof String) {
                        com.google.protobuf.ByteString b =
                                com.google.protobuf.ByteString.copyFromUtf8(
                                        (java.lang.String) ref);
                        name_ = b;
                        return b;
                    } else {
                        return (com.google.protobuf.ByteString) ref;
                    }
                }
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @param value The name to set.
                 * @return This builder for chaining.
                 */
                public Builder setName(
                        java.lang.String value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000002;
                    name_ = value;
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @return This builder for chaining.
                 */
                public Builder clearName() {
                    bitField0_ = (bitField0_ & ~0x00000002);
                    name_ = getDefaultInstance().getName();
                    onChanged();
                    return this;
                }
                /**
                 * <pre>
                 * The name is optional but significant when provided.
                 * </pre>
                 *
                 * <code>optional string name = 2;</code>
                 * @param value The bytes for name to set.
                 * @return This builder for chaining.
                 */
                public Builder setNameBytes(
                        com.google.protobuf.ByteString value) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    bitField0_ |= 0x00000002;
                    name_ = value;
                    onChanged();
                    return this;
                }
                @java.lang.Override
                public final Builder setUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.setUnknownFields(unknownFields);
                }

                @java.lang.Override
                public final Builder mergeUnknownFields(
                        final com.google.protobuf.UnknownFieldSet unknownFields) {
                    return super.mergeUnknownFields(unknownFields);
                }


                // @@protoc_insertion_point(builder_scope:onnx.TypeProto.Opaque)
            }

            // @@protoc_insertion_point(class_scope:onnx.TypeProto.Opaque)
            private static final ai.onnx.proto.OnnxMl.TypeProto.Opaque DEFAULT_INSTANCE;
            static {
                DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto.Opaque();
            }

            public static ai.onnx.proto.OnnxMl.TypeProto.Opaque getDefaultInstance() {
                return DEFAULT_INSTANCE;
            }

            @java.lang.Deprecated public static final com.google.protobuf.Parser<Opaque>
                    PARSER = new com.google.protobuf.AbstractParser<Opaque>() {
                @java.lang.Override
                public Opaque parsePartialFrom(
                        com.google.protobuf.CodedInputStream input,
                        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                        throws com.google.protobuf.InvalidProtocolBufferException {
                    return new Opaque(input, extensionRegistry);
                }
            };

            public static com.google.protobuf.Parser<Opaque> parser() {
                return PARSER;
            }

            @java.lang.Override
            public com.google.protobuf.Parser<Opaque> getParserForType() {
                return PARSER;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Opaque getDefaultInstanceForType() {
                return DEFAULT_INSTANCE;
            }

        }

        private int bitField0_;
        private int valueCase_ = 0;
        private java.lang.Object value_;
        public enum ValueCase
                implements com.google.protobuf.Internal.EnumLite,
                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
            TENSOR_TYPE(1),
            SEQUENCE_TYPE(4),
            MAP_TYPE(5),
            SPARSE_TENSOR_TYPE(8),
            OPAQUE_TYPE(7),
            VALUE_NOT_SET(0);
            private final int value;
            private ValueCase(int value) {
                this.value = value;
            }
            /**
             * @param value The number of the enum to look for.
             * @return The enum associated with the given number.
             * @deprecated Use {@link #forNumber(int)} instead.
             */
            @java.lang.Deprecated
            public static ValueCase valueOf(int value) {
                return forNumber(value);
            }

            public static ValueCase forNumber(int value) {
                switch (value) {
                    case 1: return TENSOR_TYPE;
                    case 4: return SEQUENCE_TYPE;
                    case 5: return MAP_TYPE;
                    case 8: return SPARSE_TENSOR_TYPE;
                    case 7: return OPAQUE_TYPE;
                    case 0: return VALUE_NOT_SET;
                    default: return null;
                }
            }
            public int getNumber() {
                return this.value;
            }
        };

        public ValueCase
        getValueCase() {
            return ValueCase.forNumber(
                    valueCase_);
        }

        public static final int TENSOR_TYPE_FIELD_NUMBER = 1;
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return Whether the tensorType field is set.
         */
        @java.lang.Override
        public boolean hasTensorType() {
            return valueCase_ == 1;
        }
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         * @return The tensorType.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.Tensor getTensorType() {
            if (valueCase_ == 1) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a tensor.
         * </pre>
         *
         * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
            if (valueCase_ == 1) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
        }

        public static final int SEQUENCE_TYPE_FIELD_NUMBER = 4;
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return Whether the sequenceType field is set.
         */
        @java.lang.Override
        public boolean hasSequenceType() {
            return valueCase_ == 4;
        }
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         * @return The sequenceType.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.Sequence getSequenceType() {
            if (valueCase_ == 4) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a sequence.
         * </pre>
         *
         * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
            if (valueCase_ == 4) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
        }

        public static final int MAP_TYPE_FIELD_NUMBER = 5;
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         * @return Whether the mapType field is set.
         */
        @java.lang.Override
        public boolean hasMapType() {
            return valueCase_ == 5;
        }
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         * @return The mapType.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.Map getMapType() {
            if (valueCase_ == 5) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Map) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
        }
        /**
         * <pre>
         * The type of a map.
         * </pre>
         *
         * <code>.onnx.TypeProto.Map map_type = 5;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
            if (valueCase_ == 5) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Map) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
        }

        public static final int SPARSE_TENSOR_TYPE_FIELD_NUMBER = 8;
        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return Whether the sparseTensorType field is set.
         */
        @java.lang.Override
        public boolean hasSparseTensorType() {
            return valueCase_ == 8;
        }
        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         * @return The sparseTensorType.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getSparseTensorType() {
            if (valueCase_ == 8) {
                return (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
        }
        /**
         * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
            if (valueCase_ == 8) {
                return (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
        }

        public static final int OPAQUE_TYPE_FIELD_NUMBER = 7;
        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         * @return Whether the opaqueType field is set.
         */
        @java.lang.Override
        public boolean hasOpaqueType() {
            return valueCase_ == 7;
        }
        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         * @return The opaqueType.
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.Opaque getOpaqueType() {
            if (valueCase_ == 7) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
        }
        /**
         * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
         */
        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder() {
            if (valueCase_ == 7) {
                return (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_;
            }
            return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
        }

        public static final int DENOTATION_FIELD_NUMBER = 6;
        private volatile java.lang.Object denotation_;
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return Whether the denotation field is set.
         */
        @java.lang.Override
        public boolean hasDenotation() {
            return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The denotation.
         */
        @java.lang.Override
        public java.lang.String getDenotation() {
            java.lang.Object ref = denotation_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    denotation_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * An optional denotation can be used to denote the whole
         * type with a standard semantic description as to what is
         * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
         * for pre-defined type denotations.
         * </pre>
         *
         * <code>optional string denotation = 6;</code>
         * @return The bytes for denotation.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDenotationBytes() {
            java.lang.Object ref = denotation_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                denotation_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (valueCase_ == 1) {
                output.writeMessage(1, (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_);
            }
            if (valueCase_ == 4) {
                output.writeMessage(4, (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_);
            }
            if (valueCase_ == 5) {
                output.writeMessage(5, (ai.onnx.proto.OnnxMl.TypeProto.Map) value_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 6, denotation_);
            }
            if (valueCase_ == 7) {
                output.writeMessage(7, (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_);
            }
            if (valueCase_ == 8) {
                output.writeMessage(8, (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (valueCase_ == 1) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(1, (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_);
            }
            if (valueCase_ == 4) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(4, (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_);
            }
            if (valueCase_ == 5) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(5, (ai.onnx.proto.OnnxMl.TypeProto.Map) value_);
            }
            if (((bitField0_ & 0x00000020) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, denotation_);
            }
            if (valueCase_ == 7) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(7, (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_);
            }
            if (valueCase_ == 8) {
                size += com.google.protobuf.CodedOutputStream
                        .computeMessageSize(8, (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.TypeProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.TypeProto other = (ai.onnx.proto.OnnxMl.TypeProto) obj;

            if (hasDenotation() != other.hasDenotation()) return false;
            if (hasDenotation()) {
                if (!getDenotation()
                        .equals(other.getDenotation())) return false;
            }
            if (!getValueCase().equals(other.getValueCase())) return false;
            switch (valueCase_) {
                case 1:
                    if (!getTensorType()
                            .equals(other.getTensorType())) return false;
                    break;
                case 4:
                    if (!getSequenceType()
                            .equals(other.getSequenceType())) return false;
                    break;
                case 5:
                    if (!getMapType()
                            .equals(other.getMapType())) return false;
                    break;
                case 8:
                    if (!getSparseTensorType()
                            .equals(other.getSparseTensorType())) return false;
                    break;
                case 7:
                    if (!getOpaqueType()
                            .equals(other.getOpaqueType())) return false;
                    break;
                case 0:
                default:
            }
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasDenotation()) {
                hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
                hash = (53 * hash) + getDenotation().hashCode();
            }
            switch (valueCase_) {
                case 1:
                    hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getTensorType().hashCode();
                    break;
                case 4:
                    hash = (37 * hash) + SEQUENCE_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getSequenceType().hashCode();
                    break;
                case 5:
                    hash = (37 * hash) + MAP_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getMapType().hashCode();
                    break;
                case 8:
                    hash = (37 * hash) + SPARSE_TENSOR_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getSparseTensorType().hashCode();
                    break;
                case 7:
                    hash = (37 * hash) + OPAQUE_TYPE_FIELD_NUMBER;
                    hash = (53 * hash) + getOpaqueType().hashCode();
                    break;
                case 0:
                default:
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.TypeProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.TypeProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Types
         * The standard ONNX data types.
         * </pre>
         *
         * Protobuf type {@code onnx.TypeProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.TypeProto)
                ai.onnx.proto.OnnxMl.TypeProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.TypeProto.class, ai.onnx.proto.OnnxMl.TypeProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.TypeProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                denotation_ = "";
                bitField0_ = (bitField0_ & ~0x00000020);
                valueCase_ = 0;
                value_ = null;
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_TypeProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto build() {
                ai.onnx.proto.OnnxMl.TypeProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto buildPartial() {
                ai.onnx.proto.OnnxMl.TypeProto result = new ai.onnx.proto.OnnxMl.TypeProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (valueCase_ == 1) {
                    if (tensorTypeBuilder_ == null) {
                        result.value_ = value_;
                    } else {
                        result.value_ = tensorTypeBuilder_.build();
                    }
                }
                if (valueCase_ == 4) {
                    if (sequenceTypeBuilder_ == null) {
                        result.value_ = value_;
                    } else {
                        result.value_ = sequenceTypeBuilder_.build();
                    }
                }
                if (valueCase_ == 5) {
                    if (mapTypeBuilder_ == null) {
                        result.value_ = value_;
                    } else {
                        result.value_ = mapTypeBuilder_.build();
                    }
                }
                if (valueCase_ == 8) {
                    if (sparseTensorTypeBuilder_ == null) {
                        result.value_ = value_;
                    } else {
                        result.value_ = sparseTensorTypeBuilder_.build();
                    }
                }
                if (valueCase_ == 7) {
                    if (opaqueTypeBuilder_ == null) {
                        result.value_ = value_;
                    } else {
                        result.value_ = opaqueTypeBuilder_.build();
                    }
                }
                if (((from_bitField0_ & 0x00000020) != 0)) {
                    to_bitField0_ |= 0x00000020;
                }
                result.denotation_ = denotation_;
                result.bitField0_ = to_bitField0_;
                result.valueCase_ = valueCase_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.TypeProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.TypeProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.TypeProto other) {
                if (other == ai.onnx.proto.OnnxMl.TypeProto.getDefaultInstance()) return this;
                if (other.hasDenotation()) {
                    bitField0_ |= 0x00000020;
                    denotation_ = other.denotation_;
                    onChanged();
                }
                switch (other.getValueCase()) {
                    case TENSOR_TYPE: {
                        mergeTensorType(other.getTensorType());
                        break;
                    }
                    case SEQUENCE_TYPE: {
                        mergeSequenceType(other.getSequenceType());
                        break;
                    }
                    case MAP_TYPE: {
                        mergeMapType(other.getMapType());
                        break;
                    }
                    case SPARSE_TENSOR_TYPE: {
                        mergeSparseTensorType(other.getSparseTensorType());
                        break;
                    }
                    case OPAQUE_TYPE: {
                        mergeOpaqueType(other.getOpaqueType());
                        break;
                    }
                    case VALUE_NOT_SET: {
                        break;
                    }
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.TypeProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.TypeProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int valueCase_ = 0;
            private java.lang.Object value_;
            public ValueCase
            getValueCase() {
                return ValueCase.forNumber(
                        valueCase_);
            }

            public Builder clearValue() {
                valueCase_ = 0;
                value_ = null;
                onChanged();
                return this;
            }

            private int bitField0_;

            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor, ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder> tensorTypeBuilder_;
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             * @return Whether the tensorType field is set.
             */
            @java.lang.Override
            public boolean hasTensorType() {
                return valueCase_ == 1;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             * @return The tensorType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Tensor getTensorType() {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
                } else {
                    if (valueCase_ == 1) {
                        return tensorTypeBuilder_.getMessage();
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder setTensorType(ai.onnx.proto.OnnxMl.TypeProto.Tensor value) {
                if (tensorTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    tensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder setTensorType(
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder builderForValue) {
                if (tensorTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    tensorTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder mergeTensorType(ai.onnx.proto.OnnxMl.TypeProto.Tensor value) {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1 &&
                            value_ != ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance()) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Tensor.newBuilder((ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_)
                                .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 1) {
                        tensorTypeBuilder_.mergeFrom(value);
                    }
                    tensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 1;
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public Builder clearTensorType() {
                if (tensorTypeBuilder_ == null) {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 1) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    tensorTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder getTensorTypeBuilder() {
                return getTensorTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
                if ((valueCase_ == 1) && (tensorTypeBuilder_ != null)) {
                    return tensorTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 1) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a tensor.
             * </pre>
             *
             * <code>.onnx.TypeProto.Tensor tensor_type = 1;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Tensor, ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder>
            getTensorTypeFieldBuilder() {
                if (tensorTypeBuilder_ == null) {
                    if (!(valueCase_ == 1)) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Tensor.getDefaultInstance();
                    }
                    tensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto.Tensor, ai.onnx.proto.OnnxMl.TypeProto.Tensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.TensorOrBuilder>(
                            (ai.onnx.proto.OnnxMl.TypeProto.Tensor) value_,
                            getParentForChildren(),
                            isClean());
                    value_ = null;
                }
                valueCase_ = 1;
                onChanged();;
                return tensorTypeBuilder_;
            }

            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence, ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder, ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder> sequenceTypeBuilder_;
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             * @return Whether the sequenceType field is set.
             */
            @java.lang.Override
            public boolean hasSequenceType() {
                return valueCase_ == 4;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             * @return The sequenceType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Sequence getSequenceType() {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
                } else {
                    if (valueCase_ == 4) {
                        return sequenceTypeBuilder_.getMessage();
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder setSequenceType(ai.onnx.proto.OnnxMl.TypeProto.Sequence value) {
                if (sequenceTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    sequenceTypeBuilder_.setMessage(value);
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder setSequenceType(
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder builderForValue) {
                if (sequenceTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    sequenceTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder mergeSequenceType(ai.onnx.proto.OnnxMl.TypeProto.Sequence value) {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4 &&
                            value_ != ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance()) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Sequence.newBuilder((ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_)
                                .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 4) {
                        sequenceTypeBuilder_.mergeFrom(value);
                    }
                    sequenceTypeBuilder_.setMessage(value);
                }
                valueCase_ = 4;
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public Builder clearSequenceType() {
                if (sequenceTypeBuilder_ == null) {
                    if (valueCase_ == 4) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 4) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    sequenceTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder getSequenceTypeBuilder() {
                return getSequenceTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
                if ((valueCase_ == 4) && (sequenceTypeBuilder_ != null)) {
                    return sequenceTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 4) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a sequence.
             * </pre>
             *
             * <code>.onnx.TypeProto.Sequence sequence_type = 4;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Sequence, ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder, ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder>
            getSequenceTypeFieldBuilder() {
                if (sequenceTypeBuilder_ == null) {
                    if (!(valueCase_ == 4)) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Sequence.getDefaultInstance();
                    }
                    sequenceTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto.Sequence, ai.onnx.proto.OnnxMl.TypeProto.Sequence.Builder, ai.onnx.proto.OnnxMl.TypeProto.SequenceOrBuilder>(
                            (ai.onnx.proto.OnnxMl.TypeProto.Sequence) value_,
                            getParentForChildren(),
                            isClean());
                    value_ = null;
                }
                valueCase_ = 4;
                onChanged();;
                return sequenceTypeBuilder_;
            }

            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Map, ai.onnx.proto.OnnxMl.TypeProto.Map.Builder, ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder> mapTypeBuilder_;
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             * @return Whether the mapType field is set.
             */
            @java.lang.Override
            public boolean hasMapType() {
                return valueCase_ == 5;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             * @return The mapType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Map getMapType() {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Map) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
                } else {
                    if (valueCase_ == 5) {
                        return mapTypeBuilder_.getMessage();
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder setMapType(ai.onnx.proto.OnnxMl.TypeProto.Map value) {
                if (mapTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    mapTypeBuilder_.setMessage(value);
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder setMapType(
                    ai.onnx.proto.OnnxMl.TypeProto.Map.Builder builderForValue) {
                if (mapTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    mapTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder mergeMapType(ai.onnx.proto.OnnxMl.TypeProto.Map value) {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5 &&
                            value_ != ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance()) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Map.newBuilder((ai.onnx.proto.OnnxMl.TypeProto.Map) value_)
                                .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 5) {
                        mapTypeBuilder_.mergeFrom(value);
                    }
                    mapTypeBuilder_.setMessage(value);
                }
                valueCase_ = 5;
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            public Builder clearMapType() {
                if (mapTypeBuilder_ == null) {
                    if (valueCase_ == 5) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 5) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    mapTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.Map.Builder getMapTypeBuilder() {
                return getMapTypeFieldBuilder().getBuilder();
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
                if ((valueCase_ == 5) && (mapTypeBuilder_ != null)) {
                    return mapTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 5) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Map) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
                }
            }
            /**
             * <pre>
             * The type of a map.
             * </pre>
             *
             * <code>.onnx.TypeProto.Map map_type = 5;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Map, ai.onnx.proto.OnnxMl.TypeProto.Map.Builder, ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder>
            getMapTypeFieldBuilder() {
                if (mapTypeBuilder_ == null) {
                    if (!(valueCase_ == 5)) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Map.getDefaultInstance();
                    }
                    mapTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto.Map, ai.onnx.proto.OnnxMl.TypeProto.Map.Builder, ai.onnx.proto.OnnxMl.TypeProto.MapOrBuilder>(
                            (ai.onnx.proto.OnnxMl.TypeProto.Map) value_,
                            getParentForChildren(),
                            isClean());
                    value_ = null;
                }
                valueCase_ = 5;
                onChanged();;
                return mapTypeBuilder_;
            }

            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor, ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder> sparseTensorTypeBuilder_;
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             * @return Whether the sparseTensorType field is set.
             */
            @java.lang.Override
            public boolean hasSparseTensorType() {
                return valueCase_ == 8;
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             * @return The sparseTensorType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor getSparseTensorType() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
                } else {
                    if (valueCase_ == 8) {
                        return sparseTensorTypeBuilder_.getMessage();
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
                }
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder setSparseTensorType(ai.onnx.proto.OnnxMl.TypeProto.SparseTensor value) {
                if (sparseTensorTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    sparseTensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder setSparseTensorType(
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder builderForValue) {
                if (sparseTensorTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    sparseTensorTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder mergeSparseTensorType(ai.onnx.proto.OnnxMl.TypeProto.SparseTensor value) {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8 &&
                            value_ != ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance()) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.newBuilder((ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_)
                                .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 8) {
                        sparseTensorTypeBuilder_.mergeFrom(value);
                    }
                    sparseTensorTypeBuilder_.setMessage(value);
                }
                valueCase_ = 8;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public Builder clearSparseTensorType() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (valueCase_ == 8) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 8) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    sparseTensorTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder getSparseTensorTypeBuilder() {
                return getSparseTensorTypeFieldBuilder().getBuilder();
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
                if ((valueCase_ == 8) && (sparseTensorTypeBuilder_ != null)) {
                    return sparseTensorTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 8) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
                }
            }
            /**
             * <code>.onnx.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.SparseTensor, ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder>
            getSparseTensorTypeFieldBuilder() {
                if (sparseTensorTypeBuilder_ == null) {
                    if (!(valueCase_ == 8)) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.getDefaultInstance();
                    }
                    sparseTensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto.SparseTensor, ai.onnx.proto.OnnxMl.TypeProto.SparseTensor.Builder, ai.onnx.proto.OnnxMl.TypeProto.SparseTensorOrBuilder>(
                            (ai.onnx.proto.OnnxMl.TypeProto.SparseTensor) value_,
                            getParentForChildren(),
                            isClean());
                    value_ = null;
                }
                valueCase_ = 8;
                onChanged();;
                return sparseTensorTypeBuilder_;
            }

            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque, ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder, ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder> opaqueTypeBuilder_;
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             * @return Whether the opaqueType field is set.
             */
            @java.lang.Override
            public boolean hasOpaqueType() {
                return valueCase_ == 7;
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             * @return The opaqueType.
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.Opaque getOpaqueType() {
                if (opaqueTypeBuilder_ == null) {
                    if (valueCase_ == 7) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
                } else {
                    if (valueCase_ == 7) {
                        return opaqueTypeBuilder_.getMessage();
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
                }
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            public Builder setOpaqueType(ai.onnx.proto.OnnxMl.TypeProto.Opaque value) {
                if (opaqueTypeBuilder_ == null) {
                    if (value == null) {
                        throw new NullPointerException();
                    }
                    value_ = value;
                    onChanged();
                } else {
                    opaqueTypeBuilder_.setMessage(value);
                }
                valueCase_ = 7;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            public Builder setOpaqueType(
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder builderForValue) {
                if (opaqueTypeBuilder_ == null) {
                    value_ = builderForValue.build();
                    onChanged();
                } else {
                    opaqueTypeBuilder_.setMessage(builderForValue.build());
                }
                valueCase_ = 7;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            public Builder mergeOpaqueType(ai.onnx.proto.OnnxMl.TypeProto.Opaque value) {
                if (opaqueTypeBuilder_ == null) {
                    if (valueCase_ == 7 &&
                            value_ != ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance()) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Opaque.newBuilder((ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_)
                                .mergeFrom(value).buildPartial();
                    } else {
                        value_ = value;
                    }
                    onChanged();
                } else {
                    if (valueCase_ == 7) {
                        opaqueTypeBuilder_.mergeFrom(value);
                    }
                    opaqueTypeBuilder_.setMessage(value);
                }
                valueCase_ = 7;
                return this;
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            public Builder clearOpaqueType() {
                if (opaqueTypeBuilder_ == null) {
                    if (valueCase_ == 7) {
                        valueCase_ = 0;
                        value_ = null;
                        onChanged();
                    }
                } else {
                    if (valueCase_ == 7) {
                        valueCase_ = 0;
                        value_ = null;
                    }
                    opaqueTypeBuilder_.clear();
                }
                return this;
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            public ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder getOpaqueTypeBuilder() {
                return getOpaqueTypeFieldBuilder().getBuilder();
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            @java.lang.Override
            public ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder getOpaqueTypeOrBuilder() {
                if ((valueCase_ == 7) && (opaqueTypeBuilder_ != null)) {
                    return opaqueTypeBuilder_.getMessageOrBuilder();
                } else {
                    if (valueCase_ == 7) {
                        return (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_;
                    }
                    return ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
                }
            }
            /**
             * <code>.onnx.TypeProto.Opaque opaque_type = 7;</code>
             */
            private com.google.protobuf.SingleFieldBuilderV3<
                    ai.onnx.proto.OnnxMl.TypeProto.Opaque, ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder, ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder>
            getOpaqueTypeFieldBuilder() {
                if (opaqueTypeBuilder_ == null) {
                    if (!(valueCase_ == 7)) {
                        value_ = ai.onnx.proto.OnnxMl.TypeProto.Opaque.getDefaultInstance();
                    }
                    opaqueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                            ai.onnx.proto.OnnxMl.TypeProto.Opaque, ai.onnx.proto.OnnxMl.TypeProto.Opaque.Builder, ai.onnx.proto.OnnxMl.TypeProto.OpaqueOrBuilder>(
                            (ai.onnx.proto.OnnxMl.TypeProto.Opaque) value_,
                            getParentForChildren(),
                            isClean());
                    value_ = null;
                }
                valueCase_ = 7;
                onChanged();;
                return opaqueTypeBuilder_;
            }

            private java.lang.Object denotation_ = "";
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return Whether the denotation field is set.
             */
            public boolean hasDenotation() {
                return ((bitField0_ & 0x00000020) != 0);
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return The denotation.
             */
            public java.lang.String getDenotation() {
                java.lang.Object ref = denotation_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        denotation_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return The bytes for denotation.
             */
            public com.google.protobuf.ByteString
            getDenotationBytes() {
                java.lang.Object ref = denotation_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    denotation_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @param value The denotation to set.
             * @return This builder for chaining.
             */
            public Builder setDenotation(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000020;
                denotation_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @return This builder for chaining.
             */
            public Builder clearDenotation() {
                bitField0_ = (bitField0_ & ~0x00000020);
                denotation_ = getDefaultInstance().getDenotation();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * An optional denotation can be used to denote the whole
             * type with a standard semantic description as to what is
             * stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
             * for pre-defined type denotations.
             * </pre>
             *
             * <code>optional string denotation = 6;</code>
             * @param value The bytes for denotation to set.
             * @return This builder for chaining.
             */
            public Builder setDenotationBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000020;
                denotation_ = value;
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.TypeProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.TypeProto)
        private static final ai.onnx.proto.OnnxMl.TypeProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.TypeProto();
        }

        public static ai.onnx.proto.OnnxMl.TypeProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<TypeProto>
                PARSER = new com.google.protobuf.AbstractParser<TypeProto>() {
            @java.lang.Override
            public TypeProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new TypeProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<TypeProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<TypeProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.TypeProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    public interface OperatorSetIdProtoOrBuilder extends
            // @@protoc_insertion_point(interface_extends:onnx.OperatorSetIdProto)
            com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return Whether the domain field is set.
         */
        boolean hasDomain();
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The domain.
         */
        java.lang.String getDomain();
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The bytes for domain.
         */
        com.google.protobuf.ByteString
        getDomainBytes();

        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return Whether the version field is set.
         */
        boolean hasVersion();
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return The version.
         */
        long getVersion();
    }
    /**
     * <pre>
     * Operator Sets
     * OperatorSets are uniquely identified by a (domain, opset_version) pair.
     * </pre>
     *
     * Protobuf type {@code onnx.OperatorSetIdProto}
     */
    public static final class OperatorSetIdProto extends
            com.google.protobuf.GeneratedMessageV3 implements
            // @@protoc_insertion_point(message_implements:onnx.OperatorSetIdProto)
            OperatorSetIdProtoOrBuilder {
        private static final long serialVersionUID = 0L;
        // Use OperatorSetIdProto.newBuilder() to construct.
        private OperatorSetIdProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
            super(builder);
        }
        private OperatorSetIdProto() {
            domain_ = "";
        }

        @java.lang.Override
        @SuppressWarnings({"unused"})
        protected java.lang.Object newInstance(
                UnusedPrivateParameter unused) {
            return new OperatorSetIdProto();
        }

        @java.lang.Override
        public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
            return this.unknownFields;
        }
        private OperatorSetIdProto(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            this();
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            int mutable_bitField0_ = 0;
            com.google.protobuf.UnknownFieldSet.Builder unknownFields =
                    com.google.protobuf.UnknownFieldSet.newBuilder();
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            com.google.protobuf.ByteString bs = input.readBytes();
                            bitField0_ |= 0x00000001;
                            domain_ = bs;
                            break;
                        }
                        case 16: {
                            bitField0_ |= 0x00000002;
                            version_ = input.readInt64();
                            break;
                        }
                        default: {
                            if (!parseUnknownField(
                                    input, unknownFields, extensionRegistry, tag)) {
                                done = true;
                            }
                            break;
                        }
                    }
                }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(this);
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(
                        e).setUnfinishedMessage(this);
            } finally {
                this.unknownFields = unknownFields.build();
                makeExtensionsImmutable();
            }
        }
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return ai.onnx.proto.OnnxMl.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            ai.onnx.proto.OnnxMl.OperatorSetIdProto.class, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder.class);
        }

        private int bitField0_;
        public static final int DOMAIN_FIELD_NUMBER = 1;
        private volatile java.lang.Object domain_;
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return Whether the domain field is set.
         */
        @java.lang.Override
        public boolean hasDomain() {
            return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The domain.
         */
        @java.lang.Override
        public java.lang.String getDomain() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                return (java.lang.String) ref;
            } else {
                com.google.protobuf.ByteString bs =
                        (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                    domain_ = s;
                }
                return s;
            }
        }
        /**
         * <pre>
         * The domain of the operator set being identified.
         * The empty string ("") or absence of this field implies the operator
         * set that is defined as part of the ONNX specification.
         * This field MUST be present in this version of the IR when referring to any other operator set.
         * </pre>
         *
         * <code>optional string domain = 1;</code>
         * @return The bytes for domain.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
        getDomainBytes() {
            java.lang.Object ref = domain_;
            if (ref instanceof java.lang.String) {
                com.google.protobuf.ByteString b =
                        com.google.protobuf.ByteString.copyFromUtf8(
                                (java.lang.String) ref);
                domain_ = b;
                return b;
            } else {
                return (com.google.protobuf.ByteString) ref;
            }
        }

        public static final int VERSION_FIELD_NUMBER = 2;
        private long version_;
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return Whether the version field is set.
         */
        @java.lang.Override
        public boolean hasVersion() {
            return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The version of the operator set being identified.
         * This field MUST be present in this version of the IR.
         * </pre>
         *
         * <code>optional int64 version = 2;</code>
         * @return The version.
         */
        @java.lang.Override
        public long getVersion() {
            return version_;
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
                com.google.protobuf.GeneratedMessageV3.writeString(output, 1, domain_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                output.writeInt64(2, version_);
            }
            unknownFields.writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
                size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, domain_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
                size += com.google.protobuf.CodedOutputStream
                        .computeInt64Size(2, version_);
            }
            size += unknownFields.getSerializedSize();
            memoizedSize = size;
            return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
                return true;
            }
            if (!(obj instanceof ai.onnx.proto.OnnxMl.OperatorSetIdProto)) {
                return super.equals(obj);
            }
            ai.onnx.proto.OnnxMl.OperatorSetIdProto other = (ai.onnx.proto.OnnxMl.OperatorSetIdProto) obj;

            if (hasDomain() != other.hasDomain()) return false;
            if (hasDomain()) {
                if (!getDomain()
                        .equals(other.getDomain())) return false;
            }
            if (hasVersion() != other.hasVersion()) return false;
            if (hasVersion()) {
                if (getVersion()
                        != other.getVersion()) return false;
            }
            if (!unknownFields.equals(other.unknownFields)) return false;
            return true;
        }

        @java.lang.Override
        public int hashCode() {
            if (memoizedHashCode != 0) {
                return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasDomain()) {
                hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
                hash = (53 * hash) + getDomain().hashCode();
            }
            if (hasVersion()) {
                hash = (37 * hash) + VERSION_FIELD_NUMBER;
                hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                        getVersion());
            }
            hash = (29 * hash) + unknownFields.hashCode();
            memoizedHashCode = hash;
            return hash;
        }

        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                java.nio.ByteBuffer data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                java.nio.ByteBuffer data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                com.google.protobuf.ByteString data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                com.google.protobuf.ByteString data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(byte[] data)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                byte[] data,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseDelimitedFrom(java.io.InputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseDelimitedFrom(
                java.io.InputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                com.google.protobuf.CodedInputStream input)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input);
        }
        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto parseFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            return com.google.protobuf.GeneratedMessageV3
                    .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(ai.onnx.proto.OnnxMl.OperatorSetIdProto prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                    ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
        }
        /**
         * <pre>
         * Operator Sets
         * OperatorSets are uniquely identified by a (domain, opset_version) pair.
         * </pre>
         *
         * Protobuf type {@code onnx.OperatorSetIdProto}
         */
        public static final class Builder extends
                com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                // @@protoc_insertion_point(builder_implements:onnx.OperatorSetIdProto)
                ai.onnx.proto.OnnxMl.OperatorSetIdProtoOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
                        .ensureFieldAccessorsInitialized(
                                ai.onnx.proto.OnnxMl.OperatorSetIdProto.class, ai.onnx.proto.OnnxMl.OperatorSetIdProto.Builder.class);
            }

            // Construct using ai.onnx.proto.OnnxMl.OperatorSetIdProto.newBuilder()
            private Builder() {
                maybeForceBuilderInitialization();
            }

            private Builder(
                    com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
                super(parent);
                maybeForceBuilderInitialization();
            }
            private void maybeForceBuilderInitialization() {
                if (com.google.protobuf.GeneratedMessageV3
                        .alwaysUseFieldBuilders) {
                }
            }
            @java.lang.Override
            public Builder clear() {
                super.clear();
                domain_ = "";
                bitField0_ = (bitField0_ & ~0x00000001);
                version_ = 0L;
                bitField0_ = (bitField0_ & ~0x00000002);
                return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
                return ai.onnx.proto.OnnxMl.internal_static_onnx_OperatorSetIdProto_descriptor;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto getDefaultInstanceForType() {
                return ai.onnx.proto.OnnxMl.OperatorSetIdProto.getDefaultInstance();
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto build() {
                ai.onnx.proto.OnnxMl.OperatorSetIdProto result = buildPartial();
                if (!result.isInitialized()) {
                    throw newUninitializedMessageException(result);
                }
                return result;
            }

            @java.lang.Override
            public ai.onnx.proto.OnnxMl.OperatorSetIdProto buildPartial() {
                ai.onnx.proto.OnnxMl.OperatorSetIdProto result = new ai.onnx.proto.OnnxMl.OperatorSetIdProto(this);
                int from_bitField0_ = bitField0_;
                int to_bitField0_ = 0;
                if (((from_bitField0_ & 0x00000001) != 0)) {
                    to_bitField0_ |= 0x00000001;
                }
                result.domain_ = domain_;
                if (((from_bitField0_ & 0x00000002) != 0)) {
                    result.version_ = version_;
                    to_bitField0_ |= 0x00000002;
                }
                result.bitField0_ = to_bitField0_;
                onBuilt();
                return result;
            }

            @java.lang.Override
            public Builder clone() {
                return super.clone();
            }
            @java.lang.Override
            public Builder setField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.setField(field, value);
            }
            @java.lang.Override
            public Builder clearField(
                    com.google.protobuf.Descriptors.FieldDescriptor field) {
                return super.clearField(field);
            }
            @java.lang.Override
            public Builder clearOneof(
                    com.google.protobuf.Descriptors.OneofDescriptor oneof) {
                return super.clearOneof(oneof);
            }
            @java.lang.Override
            public Builder setRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    int index, java.lang.Object value) {
                return super.setRepeatedField(field, index, value);
            }
            @java.lang.Override
            public Builder addRepeatedField(
                    com.google.protobuf.Descriptors.FieldDescriptor field,
                    java.lang.Object value) {
                return super.addRepeatedField(field, value);
            }
            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
                if (other instanceof ai.onnx.proto.OnnxMl.OperatorSetIdProto) {
                    return mergeFrom((ai.onnx.proto.OnnxMl.OperatorSetIdProto)other);
                } else {
                    super.mergeFrom(other);
                    return this;
                }
            }

            public Builder mergeFrom(ai.onnx.proto.OnnxMl.OperatorSetIdProto other) {
                if (other == ai.onnx.proto.OnnxMl.OperatorSetIdProto.getDefaultInstance()) return this;
                if (other.hasDomain()) {
                    bitField0_ |= 0x00000001;
                    domain_ = other.domain_;
                    onChanged();
                }
                if (other.hasVersion()) {
                    setVersion(other.getVersion());
                }
                this.mergeUnknownFields(other.unknownFields);
                onChanged();
                return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
                return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws java.io.IOException {
                ai.onnx.proto.OnnxMl.OperatorSetIdProto parsedMessage = null;
                try {
                    parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
                } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                    parsedMessage = (ai.onnx.proto.OnnxMl.OperatorSetIdProto) e.getUnfinishedMessage();
                    throw e.unwrapIOException();
                } finally {
                    if (parsedMessage != null) {
                        mergeFrom(parsedMessage);
                    }
                }
                return this;
            }
            private int bitField0_;

            private java.lang.Object domain_ = "";
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return Whether the domain field is set.
             */
            public boolean hasDomain() {
                return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The domain.
             */
            public java.lang.String getDomain() {
                java.lang.Object ref = domain_;
                if (!(ref instanceof java.lang.String)) {
                    com.google.protobuf.ByteString bs =
                            (com.google.protobuf.ByteString) ref;
                    java.lang.String s = bs.toStringUtf8();
                    if (bs.isValidUtf8()) {
                        domain_ = s;
                    }
                    return s;
                } else {
                    return (java.lang.String) ref;
                }
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return The bytes for domain.
             */
            public com.google.protobuf.ByteString
            getDomainBytes() {
                java.lang.Object ref = domain_;
                if (ref instanceof String) {
                    com.google.protobuf.ByteString b =
                            com.google.protobuf.ByteString.copyFromUtf8(
                                    (java.lang.String) ref);
                    domain_ = b;
                    return b;
                } else {
                    return (com.google.protobuf.ByteString) ref;
                }
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @param value The domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomain(
                    java.lang.String value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                domain_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearDomain() {
                bitField0_ = (bitField0_ & ~0x00000001);
                domain_ = getDefaultInstance().getDomain();
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The domain of the operator set being identified.
             * The empty string ("") or absence of this field implies the operator
             * set that is defined as part of the ONNX specification.
             * This field MUST be present in this version of the IR when referring to any other operator set.
             * </pre>
             *
             * <code>optional string domain = 1;</code>
             * @param value The bytes for domain to set.
             * @return This builder for chaining.
             */
            public Builder setDomainBytes(
                    com.google.protobuf.ByteString value) {
                if (value == null) {
                    throw new NullPointerException();
                }
                bitField0_ |= 0x00000001;
                domain_ = value;
                onChanged();
                return this;
            }

            private long version_ ;
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return Whether the version field is set.
             */
            @java.lang.Override
            public boolean hasVersion() {
                return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return The version.
             */
            @java.lang.Override
            public long getVersion() {
                return version_;
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @param value The version to set.
             * @return This builder for chaining.
             */
            public Builder setVersion(long value) {
                bitField0_ |= 0x00000002;
                version_ = value;
                onChanged();
                return this;
            }
            /**
             * <pre>
             * The version of the operator set being identified.
             * This field MUST be present in this version of the IR.
             * </pre>
             *
             * <code>optional int64 version = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearVersion() {
                bitField0_ = (bitField0_ & ~0x00000002);
                version_ = 0L;
                onChanged();
                return this;
            }
            @java.lang.Override
            public final Builder setUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.setUnknownFields(unknownFields);
            }

            @java.lang.Override
            public final Builder mergeUnknownFields(
                    final com.google.protobuf.UnknownFieldSet unknownFields) {
                return super.mergeUnknownFields(unknownFields);
            }


            // @@protoc_insertion_point(builder_scope:onnx.OperatorSetIdProto)
        }

        // @@protoc_insertion_point(class_scope:onnx.OperatorSetIdProto)
        private static final ai.onnx.proto.OnnxMl.OperatorSetIdProto DEFAULT_INSTANCE;
        static {
            DEFAULT_INSTANCE = new ai.onnx.proto.OnnxMl.OperatorSetIdProto();
        }

        public static ai.onnx.proto.OnnxMl.OperatorSetIdProto getDefaultInstance() {
            return DEFAULT_INSTANCE;
        }

        @java.lang.Deprecated public static final com.google.protobuf.Parser<OperatorSetIdProto>
                PARSER = new com.google.protobuf.AbstractParser<OperatorSetIdProto>() {
            @java.lang.Override
            public OperatorSetIdProto parsePartialFrom(
                    com.google.protobuf.CodedInputStream input,
                    com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                    throws com.google.protobuf.InvalidProtocolBufferException {
                return new OperatorSetIdProto(input, extensionRegistry);
            }
        };

        public static com.google.protobuf.Parser<OperatorSetIdProto> parser() {
            return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<OperatorSetIdProto> getParserForType() {
            return PARSER;
        }

        @java.lang.Override
        public ai.onnx.proto.OnnxMl.OperatorSetIdProto getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
        }

    }

    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_AttributeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_AttributeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_ValueInfoProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_ValueInfoProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_NodeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_NodeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TrainingInfoProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TrainingInfoProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_ModelProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_ModelProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_StringStringEntryProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_StringStringEntryProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TensorAnnotation_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TensorAnnotation_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_GraphProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_GraphProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TensorProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TensorProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TensorProto_Segment_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TensorProto_Segment_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_SparseTensorProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_SparseTensorProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TensorShapeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TensorShapeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TensorShapeProto_Dimension_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_Tensor_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_Tensor_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_Sequence_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_Sequence_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_Map_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_Map_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_SparseTensor_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_TypeProto_Opaque_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_TypeProto_Opaque_fieldAccessorTable;
    private static final com.google.protobuf.Descriptors.Descriptor
            internal_static_onnx_OperatorSetIdProto_descriptor;
    private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internal_static_onnx_OperatorSetIdProto_fieldAccessorTable;

    public static com.google.protobuf.Descriptors.FileDescriptor
    getDescriptor() {
        return descriptor;
    }
    private static  com.google.protobuf.Descriptors.FileDescriptor
            descriptor;
    static {
        java.lang.String[] descriptorData = {
                "\n\ronnx-ml.proto\022\004onnx\"\350\004\n\016AttributeProto" +
                        "\022\014\n\004name\030\001 \001(\t\022\025\n\rref_attr_name\030\025 \001(\t\022\022\n" +
                        "\ndoc_string\030\r \001(\t\0220\n\004type\030\024 \001(\0162\".onnx.A" +
                        "ttributeProto.AttributeType\022\t\n\001f\030\002 \001(\002\022\t" +
                        "\n\001i\030\003 \001(\003\022\t\n\001s\030\004 \001(\014\022\034\n\001t\030\005 \001(\0132\021.onnx.T" +
                        "ensorProto\022\033\n\001g\030\006 \001(\0132\020.onnx.GraphProto\022" +
                        ".\n\rsparse_tensor\030\026 \001(\0132\027.onnx.SparseTens" +
                        "orProto\022\016\n\006floats\030\007 \003(\002\022\014\n\004ints\030\010 \003(\003\022\017\n" +
                        "\007strings\030\t \003(\014\022\"\n\007tensors\030\n \003(\0132\021.onnx.T" +
                        "ensorProto\022 \n\006graphs\030\013 \003(\0132\020.onnx.GraphP" +
                        "roto\022/\n\016sparse_tensors\030\027 \003(\0132\027.onnx.Spar" +
                        "seTensorProto\"\270\001\n\rAttributeType\022\r\n\tUNDEF" +
                        "INED\020\000\022\t\n\005FLOAT\020\001\022\007\n\003INT\020\002\022\n\n\006STRING\020\003\022\n" +
                        "\n\006TENSOR\020\004\022\t\n\005GRAPH\020\005\022\021\n\rSPARSE_TENSOR\020\013" +
                        "\022\n\n\006FLOATS\020\006\022\010\n\004INTS\020\007\022\013\n\007STRINGS\020\010\022\013\n\007T" +
                        "ENSORS\020\t\022\n\n\006GRAPHS\020\n\022\022\n\016SPARSE_TENSORS\020\014" +
                        "\"Q\n\016ValueInfoProto\022\014\n\004name\030\001 \001(\t\022\035\n\004type" +
                        "\030\002 \001(\0132\017.onnx.TypeProto\022\022\n\ndoc_string\030\003 " +
                        "\001(\t\"\226\001\n\tNodeProto\022\r\n\005input\030\001 \003(\t\022\016\n\006outp" +
                        "ut\030\002 \003(\t\022\014\n\004name\030\003 \001(\t\022\017\n\007op_type\030\004 \001(\t\022" +
                        "\016\n\006domain\030\007 \001(\t\022\'\n\tattribute\030\005 \003(\0132\024.onn" +
                        "x.AttributeProto\022\022\n\ndoc_string\030\006 \001(\t\"\326\001\n" +
                        "\021TrainingInfoProto\022(\n\016initialization\030\001 \001" +
                        "(\0132\020.onnx.GraphProto\022#\n\talgorithm\030\002 \001(\0132" +
                        "\020.onnx.GraphProto\022<\n\026initialization_bind" +
                        "ing\030\003 \003(\0132\034.onnx.StringStringEntryProto\022" +
                        "4\n\016update_binding\030\004 \003(\0132\034.onnx.StringStr" +
                        "ingEntryProto\"\303\002\n\nModelProto\022\022\n\nir_versi" +
                        "on\030\001 \001(\003\022.\n\014opset_import\030\010 \003(\0132\030.onnx.Op" +
                        "eratorSetIdProto\022\025\n\rproducer_name\030\002 \001(\t\022" +
                        "\030\n\020producer_version\030\003 \001(\t\022\016\n\006domain\030\004 \001(" +
                        "\t\022\025\n\rmodel_version\030\005 \001(\003\022\022\n\ndoc_string\030\006" +
                        " \001(\t\022\037\n\005graph\030\007 \001(\0132\020.onnx.GraphProto\0224\n" +
                        "\016metadata_props\030\016 \003(\0132\034.onnx.StringStrin" +
                        "gEntryProto\022.\n\rtraining_info\030\024 \003(\0132\027.onn" +
                        "x.TrainingInfoProto\"4\n\026StringStringEntry" +
                        "Proto\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"k\n\020Ten" +
                        "sorAnnotation\022\023\n\013tensor_name\030\001 \001(\t\022B\n\034qu" +
                        "ant_parameter_tensor_names\030\002 \003(\0132\034.onnx." +
                        "StringStringEntryProto\"\330\002\n\nGraphProto\022\035\n" +
                        "\004node\030\001 \003(\0132\017.onnx.NodeProto\022\014\n\004name\030\002 \001" +
                        "(\t\022&\n\013initializer\030\005 \003(\0132\021.onnx.TensorPro" +
                        "to\0223\n\022sparse_initializer\030\017 \003(\0132\027.onnx.Sp" +
                        "arseTensorProto\022\022\n\ndoc_string\030\n \001(\t\022#\n\005i" +
                        "nput\030\013 \003(\0132\024.onnx.ValueInfoProto\022$\n\006outp" +
                        "ut\030\014 \003(\0132\024.onnx.ValueInfoProto\022(\n\nvalue_" +
                        "info\030\r \003(\0132\024.onnx.ValueInfoProto\0227\n\027quan" +
                        "tization_annotation\030\016 \003(\0132\026.onnx.TensorA" +
                        "nnotation\"\270\005\n\013TensorProto\022\014\n\004dims\030\001 \003(\003\022" +
                        "\021\n\tdata_type\030\002 \001(\005\022*\n\007segment\030\003 \001(\0132\031.on" +
                        "nx.TensorProto.Segment\022\026\n\nfloat_data\030\004 \003" +
                        "(\002B\002\020\001\022\026\n\nint32_data\030\005 \003(\005B\002\020\001\022\023\n\013string" +
                        "_data\030\006 \003(\014\022\026\n\nint64_data\030\007 \003(\003B\002\020\001\022\014\n\004n" +
                        "ame\030\010 \001(\t\022\022\n\ndoc_string\030\014 \001(\t\022\020\n\010raw_dat" +
                        "a\030\t \001(\014\0223\n\rexternal_data\030\r \003(\0132\034.onnx.St" +
                        "ringStringEntryProto\0225\n\rdata_location\030\016 " +
                        "\001(\0162\036.onnx.TensorProto.DataLocation\022\027\n\013d" +
                        "ouble_data\030\n \003(\001B\002\020\001\022\027\n\013uint64_data\030\013 \003(" +
                        "\004B\002\020\001\032%\n\007Segment\022\r\n\005begin\030\001 \001(\003\022\013\n\003end\030\002" +
                        " \001(\003\"\332\001\n\010DataType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOA" +
                        "T\020\001\022\t\n\005UINT8\020\002\022\010\n\004INT8\020\003\022\n\n\006UINT16\020\004\022\t\n\005" +
                        "INT16\020\005\022\t\n\005INT32\020\006\022\t\n\005INT64\020\007\022\n\n\006STRING\020" +
                        "\010\022\010\n\004BOOL\020\t\022\013\n\007FLOAT16\020\n\022\n\n\006DOUBLE\020\013\022\n\n\006" +
                        "UINT32\020\014\022\n\n\006UINT64\020\r\022\r\n\tCOMPLEX64\020\016\022\016\n\nC" +
                        "OMPLEX128\020\017\022\014\n\010BFLOAT16\020\020\")\n\014DataLocatio" +
                        "n\022\013\n\007DEFAULT\020\000\022\014\n\010EXTERNAL\020\001\"h\n\021SparseTe" +
                        "nsorProto\022!\n\006values\030\001 \001(\0132\021.onnx.TensorP" +
                        "roto\022\"\n\007indices\030\002 \001(\0132\021.onnx.TensorProto" +
                        "\022\014\n\004dims\030\003 \003(\003\"\225\001\n\020TensorShapeProto\022-\n\003d" +
                        "im\030\001 \003(\0132 .onnx.TensorShapeProto.Dimensi" +
                        "on\032R\n\tDimension\022\023\n\tdim_value\030\001 \001(\003H\000\022\023\n\t" +
                        "dim_param\030\002 \001(\tH\000\022\022\n\ndenotation\030\003 \001(\tB\007\n" +
                        "\005value\"\302\004\n\tTypeProto\022-\n\013tensor_type\030\001 \001(" +
                        "\0132\026.onnx.TypeProto.TensorH\000\0221\n\rsequence_" +
                        "type\030\004 \001(\0132\030.onnx.TypeProto.SequenceH\000\022\'" +
                        "\n\010map_type\030\005 \001(\0132\023.onnx.TypeProto.MapH\000\022" +
                        ":\n\022sparse_tensor_type\030\010 \001(\0132\034.onnx.TypeP" +
                        "roto.SparseTensorH\000\022-\n\013opaque_type\030\007 \001(\013" +
                        "2\026.onnx.TypeProto.OpaqueH\000\022\022\n\ndenotation" +
                        "\030\006 \001(\t\032B\n\006Tensor\022\021\n\telem_type\030\001 \001(\005\022%\n\005s" +
                        "hape\030\002 \001(\0132\026.onnx.TensorShapeProto\032.\n\010Se" +
                        "quence\022\"\n\telem_type\030\001 \001(\0132\017.onnx.TypePro" +
                        "to\032<\n\003Map\022\020\n\010key_type\030\001 \001(\005\022#\n\nvalue_typ" +
                        "e\030\002 \001(\0132\017.onnx.TypeProto\032H\n\014SparseTensor" +
                        "\022\021\n\telem_type\030\001 \001(\005\022%\n\005shape\030\002 \001(\0132\026.onn" +
                        "x.TensorShapeProto\032&\n\006Opaque\022\016\n\006domain\030\001" +
                        " \001(\t\022\014\n\004name\030\002 \001(\tB\007\n\005value\"5\n\022OperatorS" +
                        "etIdProto\022\016\n\006domain\030\001 \001(\t\022\017\n\007version\030\002 \001" +
                        "(\003*\313\001\n\007Version\022\022\n\016_START_VERSION\020\000\022\031\n\025IR" +
                        "_VERSION_2017_10_10\020\001\022\031\n\025IR_VERSION_2017" +
                        "_10_30\020\002\022\030\n\024IR_VERSION_2017_11_3\020\003\022\030\n\024IR" +
                        "_VERSION_2019_1_22\020\004\022\030\n\024IR_VERSION_2019_" +
                        "3_18\020\005\022\030\n\024IR_VERSION_2019_9_19\020\006\022\016\n\nIR_V" +
                        "ERSION\020\007B\021\n\rai.onnx.protoH\003"
        };
        descriptor = com.google.protobuf.Descriptors.FileDescriptor
                .internalBuildGeneratedFileFrom(descriptorData,
                        new com.google.protobuf.Descriptors.FileDescriptor[] {
                        });
        internal_static_onnx_AttributeProto_descriptor =
                getDescriptor().getMessageTypes().get(0);
        internal_static_onnx_AttributeProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_AttributeProto_descriptor,
                new java.lang.String[] { "Name", "RefAttrName", "DocString", "Type", "F", "I", "S", "T", "G", "SparseTensor", "Floats", "Ints", "Strings", "Tensors", "Graphs", "SparseTensors", });
        internal_static_onnx_ValueInfoProto_descriptor =
                getDescriptor().getMessageTypes().get(1);
        internal_static_onnx_ValueInfoProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_ValueInfoProto_descriptor,
                new java.lang.String[] { "Name", "Type", "DocString", });
        internal_static_onnx_NodeProto_descriptor =
                getDescriptor().getMessageTypes().get(2);
        internal_static_onnx_NodeProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_NodeProto_descriptor,
                new java.lang.String[] { "Input", "Output", "Name", "OpType", "Domain", "Attribute", "DocString", });
        internal_static_onnx_TrainingInfoProto_descriptor =
                getDescriptor().getMessageTypes().get(3);
        internal_static_onnx_TrainingInfoProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TrainingInfoProto_descriptor,
                new java.lang.String[] { "Initialization", "Algorithm", "InitializationBinding", "UpdateBinding", });
        internal_static_onnx_ModelProto_descriptor =
                getDescriptor().getMessageTypes().get(4);
        internal_static_onnx_ModelProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_ModelProto_descriptor,
                new java.lang.String[] { "IrVersion", "OpsetImport", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "MetadataProps", "TrainingInfo", });
        internal_static_onnx_StringStringEntryProto_descriptor =
                getDescriptor().getMessageTypes().get(5);
        internal_static_onnx_StringStringEntryProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_StringStringEntryProto_descriptor,
                new java.lang.String[] { "Key", "Value", });
        internal_static_onnx_TensorAnnotation_descriptor =
                getDescriptor().getMessageTypes().get(6);
        internal_static_onnx_TensorAnnotation_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TensorAnnotation_descriptor,
                new java.lang.String[] { "TensorName", "QuantParameterTensorNames", });
        internal_static_onnx_GraphProto_descriptor =
                getDescriptor().getMessageTypes().get(7);
        internal_static_onnx_GraphProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_GraphProto_descriptor,
                new java.lang.String[] { "Node", "Name", "Initializer", "SparseInitializer", "DocString", "Input", "Output", "ValueInfo", "QuantizationAnnotation", });
        internal_static_onnx_TensorProto_descriptor =
                getDescriptor().getMessageTypes().get(8);
        internal_static_onnx_TensorProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TensorProto_descriptor,
                new java.lang.String[] { "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "ExternalData", "DataLocation", "DoubleData", "Uint64Data", });
        internal_static_onnx_TensorProto_Segment_descriptor =
                internal_static_onnx_TensorProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TensorProto_Segment_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TensorProto_Segment_descriptor,
                new java.lang.String[] { "Begin", "End", });
        internal_static_onnx_SparseTensorProto_descriptor =
                getDescriptor().getMessageTypes().get(9);
        internal_static_onnx_SparseTensorProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_SparseTensorProto_descriptor,
                new java.lang.String[] { "Values", "Indices", "Dims", });
        internal_static_onnx_TensorShapeProto_descriptor =
                getDescriptor().getMessageTypes().get(10);
        internal_static_onnx_TensorShapeProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TensorShapeProto_descriptor,
                new java.lang.String[] { "Dim", });
        internal_static_onnx_TensorShapeProto_Dimension_descriptor =
                internal_static_onnx_TensorShapeProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TensorShapeProto_Dimension_descriptor,
                new java.lang.String[] { "DimValue", "DimParam", "Denotation", "Value", });
        internal_static_onnx_TypeProto_descriptor =
                getDescriptor().getMessageTypes().get(11);
        internal_static_onnx_TypeProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_descriptor,
                new java.lang.String[] { "TensorType", "SequenceType", "MapType", "SparseTensorType", "OpaqueType", "Denotation", "Value", });
        internal_static_onnx_TypeProto_Tensor_descriptor =
                internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(0);
        internal_static_onnx_TypeProto_Tensor_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_Tensor_descriptor,
                new java.lang.String[] { "ElemType", "Shape", });
        internal_static_onnx_TypeProto_Sequence_descriptor =
                internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(1);
        internal_static_onnx_TypeProto_Sequence_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_Sequence_descriptor,
                new java.lang.String[] { "ElemType", });
        internal_static_onnx_TypeProto_Map_descriptor =
                internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(2);
        internal_static_onnx_TypeProto_Map_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_Map_descriptor,
                new java.lang.String[] { "KeyType", "ValueType", });
        internal_static_onnx_TypeProto_SparseTensor_descriptor =
                internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(3);
        internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_SparseTensor_descriptor,
                new java.lang.String[] { "ElemType", "Shape", });
        internal_static_onnx_TypeProto_Opaque_descriptor =
                internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(4);
        internal_static_onnx_TypeProto_Opaque_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_TypeProto_Opaque_descriptor,
                new java.lang.String[] { "Domain", "Name", });
        internal_static_onnx_OperatorSetIdProto_descriptor =
                getDescriptor().getMessageTypes().get(12);
        internal_static_onnx_OperatorSetIdProto_fieldAccessorTable = new
                com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
                internal_static_onnx_OperatorSetIdProto_descriptor,
                new java.lang.String[] { "Domain", "Version", });
    }

    // @@protoc_insertion_point(outer_class_scope)
}